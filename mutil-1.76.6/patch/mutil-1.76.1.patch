diff -rupN old1/man/cp.1 new/man/cp.1
--- old1/man/cp.1	2011-01-04 14:42:08.000000000 -0800
+++ new/man/cp.1	2012-10-08 13:50:49.400708311 -0700
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.35.
-.TH CP "1" "October 2010" "GNU coreutils 7.6" "User Commands"
+.TH CP "1" "August 2011" "GNU coreutils 7.6" "User Commands"
 .SH NAME
 cp \- copy files and directories
 .SH SYNOPSIS
@@ -20,26 +20,27 @@ Copy SOURCE to DEST, or multiple SOURCE(
 \fB\-\-buffer\-size\fR=\fIMBYTES\fR
 read/write buffer size [4]
 .TP
-\fB\-\-direct\-read\fR
-enable use of direct I/O for reads
+\fB\-\-check\-tree\fR
+print hash subtrees to pinpoint corruption
 .TP
-\fB\-\-direct\-write\fR
-enable use of direct I/O for writes
+\fB\-\-fadvise\-read\fR
+enable use of posix_fadvise during reads
 .TP
-\fB\-\-double\-buffer\fR
-enable use of double buffering during file I/O
-.TP
-\fB\-\-fadvise\fR
-enable use of posix_fadvise during file I/O
+\fB\-\-fadvise\-write\fR
+enable use of posix_fadvise during writes
 .TP
 \fB\-\-hash\-leaf\-size\fR=\fIKBYTES\fR
-granularity of hash tree [0]
+granularity of hash tree [1048576]
 .TP
 \fB\-\-hash\-type\fR=\fITYPE\fR
 hash type [MD5], with TYPE one of:
 md5 sha1 sha256 sha384 sha512 sha224 crc32
 crc32rfc1510 crc24rfc2440
 .TP
+\fB\-\-length\fR=\fILEN\fR
+copy LEN bytes beginning at \fB\-\-offset\fR
+(or 0 if \fB\-\-offset\fR not specified)
+.TP
 \fB\-\-listen\-port\fR=\fIPORT\fR
 listen on port PORT for requests from
 cooperating hosts
@@ -54,6 +55,19 @@ port on which to contact management thre
 \fB\-\-mpi\fR
 enable use of MPI for multi\-node copies
 .TP
+\fB\-\-no\-direct\-read\fR
+disable use of direct I/O for reads
+.TP
+\fB\-\-no\-direct\-write\fR
+disable use of direct I/O for writes
+.TP
+\fB\-\-no\-double\-buffer\fR
+disable use of double buffering during file I/O
+.TP
+\fB\-\-offset\fR=\fIPOS\fR
+copy \fB\-\-length\fR bytes beginning at POS
+(or to end if \fB\-\-length\fR not specified)
+.TP
 \fB\-\-password\-file\fR=\fIFILE\fR
 file to use for passwords (will be created
 if does not exist)
@@ -68,8 +82,21 @@ data written to disk was what was read
 \fB\-\-print\-stats\fR
 print performance per file to stderr
 .TP
+\fB\-\-print\-stripe\fR
+print striping changes to stderr
+.TP
+\fB\-\-read\-stdin\fR
+perform a batch of operations read over stdin
+in the form 'SRC DST RANGES' where SRC and DST
+must be URI\-escaped (RFC 3986) file names and
+RANGES is zero or more comma\-separated ranges of
+the form 'START\-END' for 0 <= START < END
+.TP
+\fB\-\-skip\-chmod\fR
+retain temporary permissions used during copy
+.TP
 \fB\-\-split\-size\fR=\fIMBYTES\fR
-size to split files for parallelization [0]
+size to split files for parallelization [1024]
 .TP
 \fB\-\-threads\fR=\fINUMBER\fR
 number of OpenMP worker threads to use [4]
diff -rupN old1/man/md5sum.1 new/man/md5sum.1
--- old1/man/md5sum.1	2011-01-04 14:42:08.000000000 -0800
+++ new/man/md5sum.1	2012-10-08 13:50:49.400708311 -0700
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.35.
-.TH MD5SUM "1" "October 2010" "GNU coreutils 7.6" "User Commands"
+.TH MD5SUM "1" "August 2011" "GNU coreutils 7.6" "User Commands"
 .SH NAME
 md5sum \- compute and check MD5 message digest
 .SH SYNOPSIS
@@ -15,23 +15,24 @@ With no FILE, or when FILE is \-, read s
 \fB\-\-buffer\-size\fR=\fIMBYTES\fR
 read/write buffer size [4]
 .TP
-\fB\-\-direct\-read\fR
-enable use of direct I/O for reads
+\fB\-\-check\-tree\fR
+print/check hash subtrees to pinpoint corruption
 .TP
-\fB\-\-double\-buffer\fR
-enable use of double buffering during file I/O
-.TP
-\fB\-\-fadvise\fR
-enable use of posix_fadvise during file I/O
+\fB\-\-fadvise\-read\fR
+enable use of posix_fadvise during reads
 .TP
 \fB\-\-hash\-leaf\-size\fR=\fIKBYTES\fR
-granularity of hash tree [0]
+granularity of hash tree [1048576]
 .TP
 \fB\-\-hash\-type\fR=\fITYPE\fR
 hash type [MD5], with TYPE one of:
 md5 sha1 sha256 sha384 sha512 sha224 crc32
 crc32rfc1510 crc24rfc2440
 .TP
+\fB\-\-length\fR=\fILEN\fR
+hash LEN bytes beginning at \fB\-\-offset\fR
+(or 0 if \fB\-\-offset\fR not specified)
+.TP
 \fB\-\-listen\-port\fR=\fIPORT\fR
 listen on port PORT for requests from
 cooperating hosts
@@ -46,12 +47,29 @@ port on which to contact management thre
 \fB\-\-mpi\fR
 enable use of MPI for multi\-node checksums
 .TP
+\fB\-\-no\-direct\-read\fR
+disable use of direct I/O for reads
+.TP
+\fB\-\-no\-double\-buffer\fR
+disable use of double buffering during file I/O
+.TP
+\fB\-\-offset\fR=\fIPOS\fR
+hash \fB\-\-length\fR bytes beginning at POS
+(or to end if \fB\-\-length\fR not specified)
+.TP
 \fB\-\-password\-file\fR=\fIFILE\fR
 file to use for passwords (will be created
 if does not exist)
 .TP
+\fB\-\-read\-stdin\fR
+perform a batch of operations read over stdin
+in the form 'FILE RANGES' where FILE must be
+a URI\-escaped (RFC 3986) file name and RANGES
+is zero or more comma\-separated ranges of the
+form 'START\-END' for 0 <= START < END
+.TP
 \fB\-\-split\-size\fR=\fIMBYTES\fR
-size to split files for parallelization [0]
+size to split files for parallelization [1024]
 .TP
 \fB\-\-threads\fR=\fINUMBER\fR
 number of OpenMP worker threads to use [4]
diff -rupN old1/src/copy.c new/src/copy.c
--- old1/src/copy.c	2011-01-04 14:42:08.000000000 -0800
+++ new/src/copy.c	2012-10-08 16:05:26.492692109 -0700
@@ -109,6 +109,29 @@
 #include "hash-triple.h"
 #include "ignore-value.h"
 // PZK >
+#ifndef SYNC_FILE_RANGE_WRITE
+# define SYNC_FILE_RANGE_WAIT_BEFORE     1
+# define SYNC_FILE_RANGE_WRITE           2
+# define SYNC_FILE_RANGE_WAIT_AFTER      4
+
+# ifdef __i386__
+#  define NR_sync_file_range 314
+# endif
+
+# ifdef __x86_64__
+#  define NR_sync_file_range 277
+# endif
+
+# ifdef __ia64__
+#  define NR_sync_file_range 1300
+# endif
+
+static inline int sync_file_range(
+        int fd, loff_t offset, loff_t nbytes, int flags) {
+    return syscall(NR_sync_file_range, fd, offset, nbytes, flags);
+}
+#endif
+
 #if HAVE_LIBLUSTREAPI
 # include <libgen.h>
 # include <lustre/liblustreapi.h>
@@ -117,11 +140,12 @@
 # define MAX_OSTS 1024
 # define LOV_EA_SIZE(lum, num) (sizeof(*lum) + num * sizeof(*lum->lmm_objects))
 # define LOV_EA_MAX(lum) LOV_EA_SIZE(lum, MAX_OSTS)
+//TODO: lustre_idl.h includes nonexistent files so define this here
+# define LOV_MAX_STRIPE_COUNT 160
 #endif
 
 #include "mcore.h"
 #include <aio.h>
-#include <sys/xattr.h>
 
 #if HAVE_LIBGCRYPT
 # include <gcrypt.h>
@@ -609,7 +633,7 @@ copy_reg_task (copy_reg_t *crt, struct c
 // PZK >
           blcm = co->buffer_size;
           if (co->read_mode || co->write_mode)
-            blcm = buffer_lcm (blcm, 512, blcm_max);
+            blcm = buffer_lcm (blcm, 4096, blcm_max);
 // < PZK
 
           /* Do not bother with a buffer larger than the input file, plus one
@@ -636,12 +660,13 @@ copy_reg_task (copy_reg_t *crt, struct c
 
 #if HAVE_LIBGCRYPT
       gcry_md_hd_t ctx;
-      if (co->print_hash) {
+      if (co->print_hash || co->store_hash) {
+        gcry_md_open(&ctx, co->hash_type, 0);
         if (crt->nsplits > 1) {
             htt.n_hash_total = 0;
-            htt.hash_buf = xmalloc(co->hash_leaf_size);
-            htt.hash_buf_len = 0;
-            htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
+            htt.hash_ctx = &ctx;
+            htt.hash_ctx_len = 0;
+//TODO:            if (co->store_hash) htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
             htt.xattr_len = 0;
             htt.fd = crt->dest_desc;
             htt.stack_len = 0;
@@ -653,8 +678,6 @@ copy_reg_task (copy_reg_t *crt, struct c
             while (leafs >>= 1) n++;
             // stack needs space for at most height of tree hashes
             htt.stack = xmalloc(n * co->hash_size);
-        } else {
-            gcry_md_open(&ctx, co->hash_type, 0);
         }
       }
 #endif
@@ -668,15 +691,15 @@ copy_reg_task (copy_reg_t *crt, struct c
 
       for (;;)
         {
-          if (crt->nsplits > 1 && n_read_total >= co->split_size) break;
+          if (n_read_total >= crt->stop_offset - crt->start_offset) break;
 
           ssize_t n_read;
           if (raiol[0] != NULL) {
               // this will be skipped during the first double buffer iteration
-              aio_suspend(raiol, 1, NULL);
+              aio_suspend((const struct aiocb * const *) raiol, 1, NULL);
               if (co->print_stats) clock_gettime(CLOCK_REALTIME, &rts[1]);
               if (waiol[0] != NULL) {
-                  aio_suspend(waiol, 1, NULL);
+                  aio_suspend((const struct aiocb * const *) waiol, 1, NULL);
                   if (co->print_stats) {
                     clock_gettime(CLOCK_REALTIME, &wts[1]);
                     crt->write_time += (double) (
@@ -688,9 +711,31 @@ copy_reg_task (copy_reg_t *crt, struct c
               }
               n_read = aio_return(raiol[0]);
           } else {
+              off_t to_read = MIN(buf_size,
+                crt->stop_offset - crt->start_offset - n_read_total);
+              // align offset for direct i/o and better performance when buffered
+              off_t align_read = (crt->start_offset + n_read_total) % 4096;
+              if (align_read != 0 && to_read > 4096) to_read = 4096 - align_read;
+              if (co->read_mode && to_read < buf_size) {
+                // turn off direct i/o if going to read unaligned block
+                int old_flags = fcntl(crt->source_desc, F_GETFL);
+                if (fcntl(crt->source_desc, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                    error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                        quote(crt->src_name));
+              }
+
               if (co->print_stats) clock_gettime(CLOCK_REALTIME, &rts[0]);
-              n_read = read (crt->source_desc, buf[aio_buf], buf_size);
+              n_read = read (crt->source_desc, buf[aio_buf], to_read);
               if (co->print_stats) clock_gettime(CLOCK_REALTIME, &rts[1]);
+
+              if (co->read_mode && align_read != 0) {
+                // turn direct i/o back on in case it was turned off
+                int old_flags = fcntl(crt->source_desc, F_GETFL);
+                if (!(old_flags & O_DIRECT) &&
+                    fcntl(crt->source_desc, F_SETFL, old_flags | O_DIRECT) != 0)
+                        error(0, errno, _("failed to turn on O_DIRECT: %s"),
+                            quote(crt->src_name));
+              }
           }
 
           if (co->print_stats) {
@@ -715,28 +760,40 @@ copy_reg_task (copy_reg_t *crt, struct c
             break;
 
 #ifdef POSIX_FADV_DONTNEED
-          if (co->fadvise) {
-            // indicate done with read data
-            posix_fadvise(crt->source_desc, crt->start_offset + n_read_total,
-                n_read, POSIX_FADV_DONTNEED);
-            if (n_read_total >= buf_size) {
-                fdatasync(crt->dest_desc);
-                posix_fadvise(crt->dest_desc,
-                    crt->start_offset + n_read_total - buf_size,
-                    buf_size, POSIX_FADV_DONTNEED);
-            }
+          if (co->fadvise_read) {
+              // indicate done with read data
+              posix_fadvise(crt->source_desc, crt->start_offset + n_read_total,
+                  n_read, POSIX_FADV_DONTNEED);
+          }
+          if (co->fadvise_write && n_read_total >= buf_size) {
+              sync_file_range(crt->dest_desc,
+                  crt->start_offset + n_read_total - buf_size,
+                  buf_size, SYNC_FILE_RANGE_WRITE|SYNC_FILE_RANGE_WAIT_AFTER);
+              posix_fadvise(crt->dest_desc,
+                  crt->start_offset + n_read_total - buf_size,
+                  buf_size, POSIX_FADV_DONTNEED);
           }
 #endif
 
           n_read_total += n_read;
 
-          if (co->double_buffer) {
+          off_t to_read = MIN(buf_size,
+            crt->stop_offset - crt->start_offset - n_read_total);
+          if (co->double_buffer && to_read > 0) {
+            if (co->read_mode && to_read < buf_size) {
+                // turn off direct i/o if going to read unaligned block
+                int old_flags = fcntl(crt->source_desc, F_GETFL);
+                if (fcntl(crt->source_desc, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                    error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                        quote(crt->src_name));
+            }
+
             if (co->print_stats) clock_gettime(CLOCK_REALTIME, &rts[0]);
             memset(&raio, 0, sizeof(struct aiocb));
             raio.aio_fildes = crt->source_desc;
             raio.aio_offset = crt->start_offset + n_read_total;
             raio.aio_buf = buf[!aio_buf];
-            raio.aio_nbytes = buf_size;
+            raio.aio_nbytes = to_read;
             raiol[0] = &raio;
             //TODO: error handling for bad aio_read
             int rc = aio_read(&raio);
@@ -839,18 +896,21 @@ copy_reg_task (copy_reg_t *crt, struct c
           if (co->print_hash && crt->nsplits == 1)
             gcry_md_write(ctx, buf[aio_buf], n_read);
           //TODO: this is wrong for store_hash when nsplits is 1
+          //TODO: is st_size right for partial files?
           if ((co->print_hash || co->store_hash) && crt->nsplits > 1)
             hash_tree(&htt, crt, co, buf[aio_buf], n_read_total, src_open_sb.st_size);
 #endif
           if (co->double_buffer) aio_buf = !aio_buf;
         }
-        if (waiol[0] != NULL) aio_suspend(waiol, 1, NULL);
+        if (waiol[0] != NULL)
+            aio_suspend((const struct aiocb * const *) waiol, 1, NULL);
 #ifdef POSIX_FADV_DONTNEED
-        if (co->fadvise && n_read_total >= buf_size) {
-            fdatasync(crt->dest_desc);
-            posix_fadvise(crt->dest_desc,
-                crt->start_offset + n_read_total - buf_size,
-                buf_size, POSIX_FADV_DONTNEED);
+        if (co->fadvise_write && n_read_total >= buf_size) {
+            sync_file_range(crt->dest_desc, waiol[0]->aio_offset,
+                waiol[0]->aio_nbytes,
+                SYNC_FILE_RANGE_WRITE|SYNC_FILE_RANGE_WAIT_AFTER);
+            posix_fadvise(crt->dest_desc, waiol[0]->aio_offset,
+                waiol[0]->aio_nbytes, POSIX_FADV_DONTNEED);
         }
 #endif
 
@@ -860,8 +920,9 @@ copy_reg_task (copy_reg_t *crt, struct c
          write a byte at the ending position.  Otherwise the kernel would
          truncate the file at the end of the last write operation.  */
 
-      if (last_write_made_hole &&
-            lseek(crt->source_desc, 0, SEEK_CUR) == src_open_sb.st_size)
+      if (last_write_made_hole && (co->double_buffer &&
+                crt->start_offset + n_read_total == src_open_sb.st_size ||
+            lseek(crt->source_desc, 0, SEEK_CUR) == src_open_sb.st_size))
         {
           if (HAVE_FTRUNCATE
               ? /* ftruncate sets the file size,
@@ -927,12 +988,12 @@ task_close_src_and_dst_desc:
   }
 
 #if HAVE_LIBGCRYPT
-  if ((co->print_hash || co->store_hash) && crt->nsplits > 1) {
-    free(htt.hash_buf);
-    free(htt.xattr);
-    free(htt.stack);
-  } else if (co->print_hash || co->store_hash) {
+  if (co->print_hash || co->store_hash) {
     gcry_md_close(ctx);
+    if (crt->nsplits > 1) {
+        if (co->store_hash) free(htt.xattr);
+        free(htt.stack);
+    }
   }
 #endif
 
@@ -980,6 +1041,12 @@ copy_reg (char const *src_name, char con
                        | x->read_mode
 // < PZK
                        | (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+
+// PZK >
+  if (source_desc < 0 && x->read_mode)
+    source_desc = open (src_name, (O_RDONLY | O_BINARY
+                       | (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+// < PZK
   if (source_desc < 0)
     {
       error (0, errno, _("cannot open %s for reading"), quote (src_name));
@@ -1009,7 +1076,11 @@ copy_reg (char const *src_name, char con
   if (! *new_dst)
     {
 // PZK >
-      dest_desc = open (dst_name, O_WRONLY | O_TRUNC | O_BINARY | x->write_mode);
+      if (x->offset || x->length)
+        // do not truncate when doing partial copy
+        dest_desc = open (dst_name, O_WRONLY | O_BINARY | x->write_mode);
+      else
+        dest_desc = open (dst_name, O_WRONLY | O_TRUNC | O_BINARY | x->write_mode);
 // < PZK
       dest_errno = errno;
 
@@ -1072,29 +1143,38 @@ copy_reg (char const *src_name, char con
 // PZK >
       int open_flags = O_WRONLY | O_CREAT | O_BINARY | x->write_mode;
 #if HAVE_LIBLUSTREAPI
-//TODO: need a way to disable stripe count preservation
-      // check if both src and dst are lustre
-      int lustre = 0;
+//TODO: need a way to disable stripe count preservation?
+      // check if dst is lustre
       struct statfs sfs;
-      int rc = fstatfs(source_desc, &sfs);
+      char *dir = xstrdup(dst_name);
+      int rc = statfs(dirname(dir), &sfs);
+      free(dir);
       if (!rc && sfs.f_type == LL_SUPER_MAGIC) {
-        char *dir = xstrdup(dst_name);
-        rc = statfs(dirname(dir), &sfs);
-        free(dir);
-        if (!rc && sfs.f_type == LL_SUPER_MAGIC) lustre = 1;
-      }
-      if (lustre) {
+        // dst is lustre
         int scount = 0;
         int ssize = 0;
-        struct lov_user_md *lum;
-        lum = xmalloc(LOV_EA_MAX(lum));
-        rc = llapi_file_get_stripe(src_name, lum);
-        if (!rc) {
-            scount = lum->lmm_stripe_count;
-            ssize = lum->lmm_stripe_size;
+        struct lov_user_md *lum = xmalloc(LOV_EA_MAX(lum));
+        // check if src is lustre
+        if (!fstatfs(source_desc, &sfs) && sfs.f_type == LL_SUPER_MAGIC) {
+            // src is lustre so get current src striping
+            if (!llapi_file_get_stripe(src_name, lum)) {
+                scount = lum->lmm_stripe_count;
+                ssize = lum->lmm_stripe_size;
+                // restripe to # of GBs if stripe count is the default
+                if (scount == 1 || scount == 4) {
+                    int scount0 = scount;
+                    scount = src_sb->st_size / 1000000000 + 1;
+                    if (x->print_stripe)
+                        error(0, 0, _("note: stripe count of %s has been adjusted from %d to %d"),
+                            quote(dst_name), scount0, scount);
+                }
+            }
+        } else {
+            // src is not lustre
+            scount = src_sb->st_size / 1000000000 + 1;
         }
-        rc = llapi_file_create(dst_name, ssize, -1, scount, 0);
-        if (!rc) {
+        if (scount > LOV_MAX_STRIPE_COUNT) scount = LOV_MAX_STRIPE_COUNT;
+        if (!llapi_file_create(dst_name, ssize, -1, scount, 0)) {
             dest_desc = open (dst_name, open_flags | O_LOV_DELAY_CREATE,
                 wdst_mode & ~omitted_permissions);
             if (dest_desc && !llapi_file_get_stripe(dst_name, lum) &&
@@ -1102,7 +1182,7 @@ copy_reg (char const *src_name, char con
                 //TODO: this probably shouldn't be printed for every
                 //      file, especially when physical OST counts differ
                 //      between file systems
-                error(0, 0, _("warning: allocated stripe count for %s does not match original stripe count of %s"),
+                error(0, 0, _("warning: allocated stripe count of %s does not match original stripe count of %s"),
                     quote_n(0, dst_name), quote_n(1, src_name));
             }
         } else {
@@ -1353,25 +1433,18 @@ copy_reg (char const *src_name, char con
 #ifdef _OPENMP
     } else if (data_copy_required) {
         off_t pos = 0;
+        if (x->offset && x->offset > src_sb->st_size) pos = src_sb->st_size;
+        else if (x->offset) pos = x->offset;
+        off_t end = src_sb->st_size;
+        if (x->length && pos + x->length < end) end = pos + x->length;
         size_t nsplits = 1, split = 0;
-        if (x->split_size > 0 && src_sb->st_size > 0)
-            nsplits = src_sb->st_size / x->split_size +
-                (src_sb->st_size % x->split_size ? 1 : 0);
-        while (pos == 0 || pos < src_sb->st_size) {
+        if (x->split_size > 0 && end - pos > 0)
+            nsplits = (end - pos) / x->split_size +
+                ((end - pos) % x->split_size ? 1 : 0);
+        while (pos == 0 || pos < end) {
             copy_reg_t *crt = xmalloc(sizeof(copy_reg_t));
             crt->src_name = xstrdup(src_name);
             crt->dst_name = xstrdup(dst_name);
-
-/* pre-MPI code
-            crt->source_desc =
-                open (src_name, (O_RDONLY | O_BINARY | x->read_mode |
-                    (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
-            crt->dest_desc = open (dst_name, O_WRONLY | O_BINARY | x->write_mode);
-            lseek(crt->source_desc, pos, SEEK_SET);
-            lseek(crt->dest_desc, pos, SEEK_SET);
-            //TODO: error handling if can't open or seek
-*/
-
             crt->dst_mode = sb.st_mode;
             crt->src_atime = get_stat_atime(src_sb);
             crt->src_mtime = get_stat_mtime(src_sb);
@@ -1382,20 +1455,22 @@ copy_reg (char const *src_name, char con
             crt->nsplits = nsplits;
             crt->split = split++;
             crt->start_offset = pos;
+            crt->partial = x->offset || end < src_sb->st_size ? true : false;
             crt->hash_stack = xmalloc(x->hash_size);
-            if (x->print_stats || x->print_hash ||
-                    x->store_hash && nsplits > 1)
+            if (x->print_stats || x->print_hash || x->store_hash && nsplits > 1)
                 *x->hash_stat_tasks += 1;
             pos += x->split_size;
             if (nsplits > 1) {
                 // stop after split size bytes
-                crt->stop_offset = MIN(pos, src_sb->st_size);
-                if (crt->start_offset == 0 &&
+                crt->stop_offset = MIN(pos, end);
+                if (crt->start_offset == x->offset &&
                         (x->print_hash || x->store_hash)) {
                     copy_reg_t *crtcp = xmalloc(sizeof(copy_reg_t));
                     crtcp->nsplits = nsplits;
                     crtcp->split = nsplits;
-                    crtcp->stop_offset = src_sb->st_size;
+                    crtcp->start_offset = x->offset;
+                    crtcp->stop_offset = end;
+                    crtcp->partial = crt->partial;
                     crtcp->src_name = xstrdup(src_name);
                     crtcp->dst_name = xstrdup(dst_name);
                     crtcp->hash_stack = xmalloc(nsplits * x->hash_size);
@@ -1414,7 +1489,7 @@ copy_reg (char const *src_name, char con
                 }
             } else {
                 // stop at end of file
-                crt->stop_offset = src_sb->st_size;
+                crt->stop_offset = end;
             }
             omp_q_push(x->task_q, crt);
             // wait until file has been opened
@@ -1482,6 +1557,7 @@ copy_reg (char const *src_name, char con
       omitted_permissions &= ~ cached_umask ();
 // PZK >
       if ((omitted_permissions || dst_mode != wdst_mode)
+          && !x->skip_chmod
 // < PZK
           && fchmod_or_lchmod (dest_desc, dst_name, dst_mode) != 0)
         {
@@ -2493,6 +2569,38 @@ copy_internal (char const *src_name, cha
                      quote (dst_name));
               goto un_backup;
             }
+// PZK >
+#if HAVE_LIBLUSTREAPI
+          else {
+//TODO: need a way to disable stripe count preservation?
+            // check if dst is lustre
+            struct statfs sfs;
+            if (!statfs(dst_name, &sfs) && sfs.f_type == LL_SUPER_MAGIC) {
+                // dst is lustre
+                // check if src is lustre
+                if (!statfs(src_name, &sfs) && sfs.f_type == LL_SUPER_MAGIC) {
+                    // src is lustre so get current src striping
+                    struct lov_user_md *lum = xmalloc(LOV_EA_MAX(lum));
+                    if (!llapi_file_get_stripe(src_name, lum)) {
+                        int scount = lum->lmm_stripe_count;
+                        int ssize = lum->lmm_stripe_size;
+                        // restripe to 0 if stripe count is the default
+                        if (scount == 1 || scount == 4) {
+                            if (x->print_stripe)
+                                error(0, 0, _("note: stripe count of %s has been adjusted from %d to 0"),
+                                    quote(dst_name), scount);
+                            scount = 0;
+                        }
+                        if (llapi_file_create(dst_name, ssize, -1, scount, 0))
+                            error(0, 0, _("warning: unable to set stripe count of %s"),
+                                quote(dst_name));
+                    }
+                    free(lum);
+                }
+            }
+          }
+#endif
+// < PZK
 
           /* We need search and write permissions to the new directory
              for writing the directory's contents. Check if these
diff -rupN old1/src/copy.h new/src/copy.h
--- old1/src/copy.h	2011-01-04 14:42:08.000000000 -0800
+++ new/src/copy.h	2012-10-08 13:50:49.056671471 -0700
@@ -172,34 +172,38 @@ enum Dereference_symlink
 struct cp_options
 {
 // PZK >
-  int threads;
-  bool print_hash;
-  bool store_hash;
-  int hash_type;
-  unsigned int hash_size;
-  off_t hash_leaf_size;
-  bool print_stats;
-  bool double_buffer;
   size_t buffer_size;
-  off_t split_size;
-  int read_mode;
-  int write_mode;
-  bool read_stdin;
-  bool mpi;
-  bool fadvise;
+  bool check_tree;
+  bool double_buffer;
+  bool fadvise_read;
+  bool fadvise_write;
+  off_t hash_leaf_size;
+  unsigned int hash_size;
   long long *hash_stat_tasks;
+  int hash_type;
+  off_t length;
   in_port_t listen_port;
-  in_port_t mgr_port;
   struct addrinfo *mgr_ai;
   char *mg_file;
-  char *pw_file;
-  char *user;
-  char *pass;
-# ifdef _OPENMP
-  omp_q_t *task_q;
+  in_port_t mgr_port;
+  bool mpi;
+  off_t offset;
   omp_q_t *open_q;
+  char *pass;
+  bool print_hash;
+  bool print_stats;
+  bool print_stripe;
+  char *pw_file;
+  int read_mode;
+  bool read_stdin;
   omp_q_t *send_q;
-# endif
+  bool skip_chmod;
+  off_t split_size;
+  bool store_hash;
+  omp_q_t *task_q;
+  int threads;
+  char *user;
+  int write_mode;
 // < PZK
 
   enum backup_type backup_type;
@@ -387,22 +391,23 @@ mode_t cached_umask (void);
 
 // PZK >
 typedef struct {
-    char *src_name;
-    char *dst_name;
-    int source_desc;
+    double copy_time;
     int dest_desc;
+    size_t dst_blksize;
     mode_t dst_mode;
+    char *dst_name;
+    unsigned char *hash_stack;
+    bool partial;
+    size_t nsplits;
+    double read_time;
+    int source_desc;
+    size_t split;
     struct timespec src_atime;
     struct timespec src_mtime;
-    size_t dst_blksize;
-    double read_time;
-    double write_time;
-    double copy_time;
+    char *src_name;
     off_t start_offset;
     off_t stop_offset;
-    size_t nsplits;
-    size_t split;
-    unsigned char *hash_stack;
+    double write_time;
 } copy_reg_t;
 
 bool copy_reg_task(copy_reg_t *crt, struct cp_options *co);
diff -rupN old1/src/cp.c new/src/cp.c
--- old1/src/cp.c	2011-01-04 14:42:08.000000000 -0800
+++ new/src/cp.c	2012-10-08 14:55:48.702518511 -0700
@@ -95,7 +95,6 @@
 #include "filenamecat.h"
 #include "ignore-value.h"
 // PZK >
-#include "math.h"
 #include "mcore.h"
 #include "mkancesdirs.h"
 #include "savewd.h"
@@ -145,7 +144,7 @@ GCRY_THREAD_OPTION_PTHREAD_IMPL;
 
 /* The official name of this program (e.g., no `g' prefix).  */
 // PZK >
-#define PROGRAM_NAME "mcp 1.76.1"
+#define PROGRAM_NAME "mcp 1.76.6"
 
 #define AUTHORS \
   proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
@@ -156,6 +155,21 @@ GCRY_THREAD_OPTION_PTHREAD_IMPL;
 #ifndef DEFAULT_BUFFER_SIZE
 # define DEFAULT_BUFFER_SIZE 4
 #endif
+#ifndef DEFAULT_DIRECT_READ
+# define DEFAULT_DIRECT_READ 0
+#endif
+#ifndef DEFAULT_DIRECT_WRITE
+# define DEFAULT_DIRECT_WRITE 0
+#endif
+#ifndef DEFAULT_DOUBLE_BUFFER
+# define DEFAULT_DOUBLE_BUFFER 0
+#endif
+#ifndef DEFAULT_FADVISE_READ
+# define DEFAULT_FADVISE_READ 0
+#endif
+#ifndef DEFAULT_FADVISE_WRITE
+# define DEFAULT_FADVISE_WRITE 0
+#endif
 #if !defined(DEFAULT_HASH_TYPE) && HAVE_LIBGCRYPT
 # define DEFAULT_HASH_TYPE GCRY_MD_MD5
 #endif
@@ -188,16 +202,29 @@ enum
   DIRECT_READ_OPTION,
   DIRECT_WRITE_OPTION,
   DOUBLE_BUFFER_OPTION,
+  LENGTH_OPTION,
+  NO_DIRECT_READ_OPTION,
+  NO_DIRECT_WRITE_OPTION,
+  NO_DOUBLE_BUFFER_OPTION,
+  OFFSET_OPTION,
   READ_STDIN_OPTION,
+  SKIP_CHMOD_OPTION,
 #ifdef POSIX_FADV_DONTNEED
-  FADVISE_OPTION,
+  FADVISE_READ_OPTION,
+  FADVISE_WRITE_OPTION,
+  NO_FADVISE_READ_OPTION,
+  NO_FADVISE_WRITE_OPTION,
 #endif
 #ifdef _OPENMP
   PRINT_STATS_OPTION,
   SPLIT_SIZE_OPTION,
   THREADS_OPTION,
 #endif
+#if HAVE_LIBLUSTREAPI
+  PRINT_STRIPE_OPTION,
+#endif
 #if HAVE_LIBGCRYPT
+  CHECK_TREE_OPTION,
   HASH_LEAF_SIZE_OPTION,
   HASH_TYPE_OPTION,
   PRINT_HASH_OPTION,
@@ -259,16 +286,29 @@ static struct option const long_opts[] =
   {"direct-read", no_argument, NULL, DIRECT_READ_OPTION},
   {"direct-write", no_argument, NULL, DIRECT_WRITE_OPTION},
   {"double-buffer", no_argument, NULL, DOUBLE_BUFFER_OPTION},
+  {"length", required_argument, NULL, LENGTH_OPTION},
+  {"no-direct-read", no_argument, NULL, NO_DIRECT_READ_OPTION},
+  {"no-direct-write", no_argument, NULL, NO_DIRECT_WRITE_OPTION},
+  {"no-double-buffer", no_argument, NULL, NO_DOUBLE_BUFFER_OPTION},
+  {"offset", required_argument, NULL, OFFSET_OPTION},
   {"read-stdin", no_argument, NULL, READ_STDIN_OPTION},
+  {"skip-chmod", no_argument, NULL, SKIP_CHMOD_OPTION},
 #ifdef POSIX_FADV_DONTNEED
-  {"fadvise", no_argument, NULL, FADVISE_OPTION},
+  {"fadvise-read", no_argument, NULL, FADVISE_READ_OPTION},
+  {"fadvise-write", no_argument, NULL, FADVISE_WRITE_OPTION},
+  {"no-fadvise-read", no_argument, NULL, NO_FADVISE_READ_OPTION},
+  {"no-fadvise-write", no_argument, NULL, NO_FADVISE_WRITE_OPTION},
 #endif
 #ifdef _OPENMP
   {"print-stats", no_argument, NULL, PRINT_STATS_OPTION},
   {"split-size", required_argument, NULL, SPLIT_SIZE_OPTION},
   {"threads", required_argument, NULL, THREADS_OPTION},
 #endif
+#if HAVE_LIBLUSTREAPI
+  {"print-stripe", no_argument, NULL, PRINT_STRIPE_OPTION},
+#endif
 #if HAVE_LIBGCRYPT
+  {"check-tree", no_argument, NULL, CHECK_TREE_OPTION},
   {"hash-leaf-size", required_argument, NULL, HASH_LEAF_SIZE_OPTION},
   {"hash-type", required_argument, NULL, HASH_TYPE_OPTION},
   {"print-hash", no_argument, NULL, PRINT_HASH_OPTION},
@@ -337,15 +377,37 @@ Copy SOURCE to DEST, or multiple SOURCE(
       fprintf (stdout, _("\
       --buffer-size=MBYTES     read/write buffer size [%d]\n"),
         DEFAULT_BUFFER_SIZE);
+#if HAVE_LIBGCRYPT
+      fputs (_("\
+      --check-tree             print hash subtrees to pinpoint corruption\n\
+"), stdout);
+#endif
+#if !DEFAULT_DIRECT_READ
       fputs (_("\
       --direct-read            enable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if !DEFAULT_DIRECT_WRITE
+      fputs (_("\
       --direct-write           enable use of direct I/O for writes\n\
+"), stdout);
+#endif
+#if !DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
       --double-buffer          enable use of double buffering during file I/O\n\
 "), stdout);
+#endif
 #ifdef POSIX_FADV_DONTNEED
+# if !DEFAULT_FADVISE_READ
+      fputs (_("\
+      --fadvise-read           enable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+# if !DEFAULT_FADVISE_WRITE
       fputs (_("\
-      --fadvise                enable use of posix_fadvise during file I/O\n\
+      --fadvise-write          enable use of posix_fadvise during writes\n\
 "), stdout);
+# endif
 #endif
 #if HAVE_LIBGCRYPT
       fprintf (stdout, _("\
@@ -368,6 +430,10 @@ Copy SOURCE to DEST, or multiple SOURCE(
       }
       fputs(_("\n"), stdout);
 #endif
+      fputs (_("\
+      --length=LEN             copy LEN bytes beginning at --offset\n\
+                                 (or 0 if --offset not specified)\n\
+"), stdout);
 #if HAVE_LIBGNUTLS
       fputs (_("\
       --listen-port=PORT       listen on port PORT for requests from\n\
@@ -382,6 +448,37 @@ Copy SOURCE to DEST, or multiple SOURCE(
       --mpi                    enable use of MPI for multi-node copies\n\
 "), stdout);
 #endif
+#if DEFAULT_DIRECT_READ
+      fputs (_("\
+      --no-direct-read         disable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if DEFAULT_DIRECT_WRITE
+      fputs (_("\
+      --no-direct-write        disable use of direct I/O for writes\n\
+"), stdout);
+#endif
+#if DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
+      --no-double-buffer       disable use of double buffering during file I/O\n\
+"), stdout);
+#endif
+#ifdef POSIX_FADV_DONTNEED
+# if DEFAULT_FADVISE_READ
+      fputs (_("\
+      --no-fadvise-read        disable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+# if DEFAULT_FADVISE_WRITE
+      fputs (_("\
+      --no-fadvise-write       disable use of posix_fadvise during writes\n\
+"), stdout);
+# endif
+#endif
+      fputs (_("\
+      --offset=POS             copy --length bytes beginning at POS\n\
+                                 (or to end if --length not specified)\n\
+"), stdout);
 #if HAVE_LIBGNUTLS && defined(_OPENMP)
       fputs (_("\
       --password-file=FILE     file to use for passwords (will be created\n\
@@ -401,6 +498,21 @@ Copy SOURCE to DEST, or multiple SOURCE(
       fputs (_("\
       --print-stats            print performance per file to stderr\n\
 "), stdout);
+#endif
+#if HAVE_LIBLUSTREAPI
+      fputs (_("\
+      --print-stripe           print striping changes to stderr\n\
+"), stdout);
+#endif
+#ifdef _OPENMP
+      fputs (_("\
+      --read-stdin             perform a batch of operations read over stdin\n\
+                                 in the form 'SRC DST RANGES' where SRC and DST\n\
+                                 must be URI-escaped (RFC 3986) file names and\n\
+                                 RANGES is zero or more comma-separated ranges of\n\
+                                 the form 'START-END' for 0 <= START < END\n\
+      --skip-chmod             retain temporary permissions used during copy\n\
+"), stdout);
       fprintf (stdout, _("\
       --split-size=MBYTES      size to split files for parallelization [%d]\n\
       --threads=NUMBER         number of OpenMP worker threads to use [%d]\n\
@@ -408,7 +520,6 @@ Copy SOURCE to DEST, or multiple SOURCE(
 "), DEFAULT_SPLIT_SIZE, DEFAULT_THREADS);
 #endif
 /* TODO: these options temporarily disabled
-//TODO: add --read-stdin
 TODO: fix hash-type to include stores
 #if HAVE_LIBGCRYPT
       fputs (_("\
@@ -826,6 +937,55 @@ target_directory_operand (char const *fi
 }
 
 // PZK >
+void print_hash(const struct cp_options *x, copy_reg_t *crt)
+{
+    size_t i;
+
+    // put non-standard output in comments
+    if (crt->nsplits > 1 || crt->partial) {
+        printf("#mutil#");
+        if (crt->partial)
+            printf("%lld-%lld", crt->start_offset, crt->stop_offset);
+        printf("#");
+    }
+
+    /* Output a leading backslash if the file name contains
+       a newline or backslash.  */
+    if (strchr(crt->dst_name, '\n') || strchr(crt->dst_name, '\\'))
+        putchar ('\\');
+
+    size_t bytes = x->hash_size;
+    if (x->check_tree) bytes *= crt->nsplits;
+
+    for (size_t i = 0; i < bytes; ++i)
+        printf ("%02x", crt->hash_stack[i]);
+
+    putchar (' ');
+/*TODO: do something with this binary stuff
+    if (file_is_binary)
+      putchar ('*');
+    else
+*/
+      putchar (' ');
+
+    /* Translate each NEWLINE byte to the string, "\\n",
+       and each backslash to "\\\\".  */
+    for (i = 0; i < strlen(crt->dst_name); ++i) {
+        switch (crt->dst_name[i]) {
+        case '\n':
+            fputs("\\n", stdout);
+            break;
+        case '\\':
+            fputs("\\\\", stdout);
+            break;
+        default:
+            putchar(crt->dst_name[i]);
+            break;
+        }
+    }
+    putchar ('\n');
+}
+
 /* Make ancestor directory DIR, whose last file name component is
    COMPONENT, with options OPTIONS.  Assume the working directory is
    COMPONENT's parent.  */
@@ -1042,13 +1202,8 @@ do_copy (int n_files, char **file, const
         fprintf(stderr, _("\n"));
       }
 
-      //TODO: change this to print official md5sum format
-      //      same with hash tree final below
       if (x->print_hash && crt->nsplits == 1) {
-        char hex[2 * x->hash_size + 1];
-        for (int i = 0; i < x->hash_size; i++)
-            sprintf(&hex[2 * i], "%02x", crt->hash_stack[i]);
-        printf(_("%s  %s\n"), hex, crt->dst_name);
+        print_hash(x, crt);
       }
 
       if (!x->print_hash || crt->nsplits <= 1) {
@@ -1098,27 +1253,31 @@ do_copy (int n_files, char **file, const
         if (--crt->split == 0) {
 # if HAVE_LIBGCRYPT
             // finalize hash if last
+            gcry_md_hd_t ctx;
+            gcry_md_open(&ctx, x->hash_type, 0);
             hash_tree_t htt;
             htt.n_hash_total = 0;
-            htt.hash_buf = xmalloc(x->hash_leaf_size);
-            htt.hash_buf_len = 0;
-            htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
+            htt.hash_ctx = &ctx;
+            htt.hash_ctx_len = 0;
+//TODO:            if (x->store_hash) htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
             htt.xattr_len = 0;
             // this works because dest_desc will be open in first crt received
             htt.fd = crt->dest_desc;
             htt.stack_len = 0;
-            hash_final(&htt, crt, x, 0, crt->nsplits, crt->stop_offset);
+            // don't compute root of tree when printing subtrees
+            if (!x->check_tree)
+                hash_final(&htt, crt, x, 0, crt->nsplits,
+                    crt->stop_offset - crt->start_offset);
             // print hash
             if (x->print_hash) {
-                char hex[2 * x->hash_size + 1];
-                for (int i = 0; i < x->hash_size; i++)
-                    sprintf(&hex[2 * i], "%02x", crt->hash_stack[i]);
-                printf(_("%s  %s\n"), hex, crt->dst_name);
+                print_hash(x, crt);
             }
             // clean up
-            if (x->store_hash) close(crt->dest_desc);
-            free(htt.hash_buf);
-            free(htt.xattr);
+            gcry_md_close(ctx);
+            if (x->store_hash) {
+                close(crt->dest_desc);
+                free(htt.xattr);
+            }
             free(crt->hash_stack);
 # endif
             free(crt->src_name);
@@ -1668,9 +1827,12 @@ do_copy (int n_files, char **file, const
       crt->source_desc =
         open(crt->src_name, (O_RDONLY | O_BINARY | x->read_mode |
           (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
-      crt->dest_desc = open(crt->dst_name, O_WRONLY | O_BINARY | x->write_mode);
+      if (crt->source_desc < 0 && x->read_mode)
+        crt->source_desc = open(crt->src_name, (O_RDONLY | O_BINARY |
+          (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
       if (crt->source_desc < 0)
         error(0, errno, _("warning: unable to open %s for read"), quote(crt->src_name));
+      crt->dest_desc = open(crt->dst_name, O_WRONLY | O_BINARY | x->write_mode);
       if (crt->dest_desc < 0)
         error(0, errno, _("warning: unable to open %s for write"), quote(crt->dst_name));
       if (lseek(crt->source_desc, crt->start_offset, SEEK_SET) < 0)
@@ -1805,7 +1967,6 @@ do_copy (int n_files, char **file, const
 // PZK >
   else if (x->read_stdin)
     {
-//TODO: --read-stdin then C-c = core dump
       /* Start with a buffer larger than PATH_MAX, but beware of systems
          on which PATH_MAX is very large -- e.g., INT_MAX.  */
       size_t buf_max = MIN(2 * PATH_MAX, 32 * 1024);
@@ -1823,8 +1984,15 @@ do_copy (int n_files, char **file, const
             continue;
         }
         size_t ifile2 = strcspn(buf, " ");
-        buf[ifile2++] = '\0';
         if (buf[ifile2] == '\0') continue;
+        buf[ifile2++] = '\0';
+        size_t irange = strcspn(&buf[ifile2], " ");
+        if (buf[ifile2 + irange] == '\0') {
+            irange = 0;
+        } else {
+            irange = ifile2 + irange;
+            buf[irange++] = '\0';
+        }
         source = unescape(buf, 0);
         dest = unescape(&buf[ifile2], 0);
         if (source == NULL || dest == NULL) {
@@ -1891,7 +2059,20 @@ do_copy (int n_files, char **file, const
               }
           }
 
-        ok = copy (source, new_dest, 0, x, &unused, NULL);
+        if (irange > 0) {
+            off_t x1, x2;
+            while (sscanf(&buf[irange], "%lld-%lld", &x1, &x2) == 2) {
+                x->offset = x1;
+                x->length = x2 - x1;
+                ok &= copy (source, new_dest, 0, x, &unused, NULL);
+                irange += strcspn(&buf[irange], ",");
+                if (buf[irange] == ',') irange++;
+            }
+        } else {
+            x->offset = 0;
+            x->length = 0;
+            ok = copy (source, new_dest, 0, x, &unused, NULL);
+        }
         free(source);
         free(dest);
       }
@@ -1965,12 +2146,17 @@ do_copy (int n_files, char **file, const
   if (x->mpi) MPI_Finalize();
 # endif
 
+  // destroy all queues
+  omp_q_destroy(&send_q);
+  omp_q_destroy(&open_q);
+  omp_q_destroy(&task_q);
+
   //TODO: this no longer works with mpi/tcp
   // reduce oks array to single value
   for (int i = 0; i < x->threads; i++)
     ok &= oks[i];
-// < PZK
 #endif
+// < PZK
 
   return ok;
 }
@@ -1980,33 +2166,58 @@ cp_option_init (struct cp_options *x)
 {
   cp_options_default (x);
 // PZK >
-  x->threads = DEFAULT_THREADS;
-  x->print_hash = false;
-  x->store_hash = false;
-#if HAVE_LIBGCRYPT
-  x->hash_type = DEFAULT_HASH_TYPE;
+  x->buffer_size = DEFAULT_BUFFER_SIZE * 1024 * 1024;
+  x->check_tree = false;
+#if DEFAULT_DOUBLE_BUFFER
+  x->double_buffer = true;
+#else
+  x->double_buffer = false;
+#endif
+#if DEFAULT_FADVISE_READ
+  x->fadvise_read = true;
+#else
+  x->fadvise_read = false;
+#endif
+#if DEFAULT_FADVISE_WRITE
+  x->fadvise_write = true;
+#else
+  x->fadvise_write = false;
 #endif
   x->hash_size = 0;
-  x->print_stats = false;
-  x->double_buffer = false;
-  x->buffer_size = DEFAULT_BUFFER_SIZE * 1024 * 1024;
-  x->split_size = DEFAULT_SPLIT_SIZE * 1024 * 1024;
-  x->hash_leaf_size = x->split_size;
-  x->read_mode = 0;
-  x->write_mode = 0;
-  x->read_stdin = false;
-  x->fadvise = false;
-  x->mpi = false;
   x->hash_stat_tasks = xcalloc(1, sizeof(long long));
+#if HAVE_LIBGCRYPT
+  x->hash_type = DEFAULT_HASH_TYPE;
+#endif
+  x->length = 0;
   x->listen_port = 0;
-  x->pw_file = 0;
   x->mg_file = 0;
-  x->mgr_port = 0;
   x->mgr_ai = NULL;
-  x->user = NULL;
+  x->mgr_port = 0;
+  x->mpi = false;
+  x->offset = 0;
+  x->open_q = NULL;
   x->pass = NULL;
+  x->print_hash = false;
+  x->print_stats = false;
+  x->pw_file = 0;
+#if DEFAULT_DIRECT_READ
+  x->read_mode = O_DIRECT;
+#else
+  x->read_mode = 0;
+#endif
+  x->read_stdin = false;
+  x->skip_chmod = false;
+  x->split_size = DEFAULT_SPLIT_SIZE * 1024 * 1024;
+  x->hash_leaf_size = x->split_size; // this must follow split_size
+  x->store_hash = false;
   x->task_q = NULL;
-  x->open_q = NULL;
+  x->threads = DEFAULT_THREADS;
+  x->user = NULL;
+#if DEFAULT_DIRECT_WRITE
+  x->write_mode = O_DIRECT;
+#else
+  x->write_mode = 0;
+#endif
 // < PZK
   x->copy_as_regular = true;
   x->dereference = DEREF_UNDEFINED;
@@ -2182,12 +2393,11 @@ main (int argc, char **argv)
           if (x.buffer_size < 1 || x.buffer_size > 128)
             error (EXIT_FAILURE, 0, _("invalid buffer size"));
           size_t tmp_bs = x.buffer_size;
-          int n_bs = 0;
-          while (tmp_bs >>= 1) n_bs++;
-          tmp_bs = pow(2, n_bs);
-          if (x.buffer_size != tmp_bs)
-            error(0, 0, _("Note: buffer size has been adjusted to %lld"), tmp_bs);
-          x.buffer_size = tmp_bs * 1024 * 1024;
+          size_t new_bs = 1;
+          while (tmp_bs >>= 1) new_bs <<= 1;
+          if (x.buffer_size != new_bs)
+            error(0, 0, _("note: buffer size has been adjusted to %lld"), new_bs);
+          x.buffer_size = new_bs * 1024 * 1024;
           break;
         case DIRECT_READ_OPTION:
           x.read_mode = O_DIRECT;
@@ -2198,12 +2408,43 @@ main (int argc, char **argv)
         case DOUBLE_BUFFER_OPTION:
           x.double_buffer = true;
           break;
+        case LENGTH_OPTION:
+          x.length = strtoll(optarg, (char **) NULL, 10);
+          if (x.length < 1)
+            error (EXIT_FAILURE, 0, _("invalid length"));
+          break;
+        case NO_DIRECT_READ_OPTION:
+          x.read_mode = 0;
+          break;
+        case NO_DIRECT_WRITE_OPTION:
+          x.write_mode = 0;
+          break;
+        case NO_DOUBLE_BUFFER_OPTION:
+          x.double_buffer = false;
+          break;
+        case OFFSET_OPTION:
+          x.offset = strtoll(optarg, (char **) NULL, 10);
+          if (x.offset < 0)
+            error (EXIT_FAILURE, 0, _("invalid offset"));
+          break;
         case READ_STDIN_OPTION:
           x.read_stdin = true;
           break;
+        case SKIP_CHMOD_OPTION:
+          x.skip_chmod = true;
+          break;
 #ifdef POSIX_FADV_DONTNEED
-        case FADVISE_OPTION:
-          x.fadvise = true;
+        case FADVISE_READ_OPTION:
+          x.fadvise_read = true;
+          break;
+        case FADVISE_WRITE_OPTION:
+          x.fadvise_write = true;
+          break;
+        case NO_FADVISE_READ_OPTION:
+          x.fadvise_read = false;
+          break;
+        case NO_FADVISE_WRITE_OPTION:
+          x.fadvise_write = false;
           break;
 #endif
 #ifdef _OPENMP
@@ -2211,17 +2452,16 @@ main (int argc, char **argv)
           x.print_stats = true;
           break;
         case SPLIT_SIZE_OPTION:
-          x.split_size = (int) strtol(optarg, (char **) NULL, 10);
+          x.split_size = strtoll(optarg, (char **) NULL, 10);
           if (x.split_size < 0)
             error (EXIT_FAILURE, 0, _("invalid split size"));
           if (x.split_size > 0) {
             off_t tmp_ss = x.split_size;
-            int n_ss = 0;
-            while (tmp_ss >>= 1) n_ss++;
-            tmp_ss = pow(2, n_ss);
-            if (x.split_size != tmp_ss)
-              error(0, 0, _("Note: split size has been adjusted to %lld"), tmp_ss);
-            x.split_size = tmp_ss * 1024 * 1024;
+            off_t new_ss = 1;
+            while (tmp_ss >>= 1) new_ss <<= 1;
+            if (x.split_size != new_ss)
+              error(0, 0, _("note: split size has been adjusted to %lld"), new_ss);
+            x.split_size = new_ss * 1024 * 1024;
           }
           break;
         case THREADS_OPTION:
@@ -2230,18 +2470,25 @@ main (int argc, char **argv)
             error (EXIT_FAILURE, 0, _("invalid number of threads"));
           break;
 #endif
+#if HAVE_LIBLUSTREAPI
+        case PRINT_STRIPE_OPTION:
+          x.print_stripe = true;
+          break;
+#endif
 #if HAVE_LIBGCRYPT
+        case CHECK_TREE_OPTION:
+          x.check_tree = true;
+          break;
         case HASH_LEAF_SIZE_OPTION:
-          x.hash_leaf_size = (int) strtol(optarg, (char **) NULL, 10);
+          x.hash_leaf_size = strtoll(optarg, (char **) NULL, 10);
           if (x.hash_leaf_size < 1)
             error (EXIT_FAILURE, 0, _("invalid hash leaf size"));
           off_t tmp_ls = x.hash_leaf_size;
-          int n_ls = 0;
-          while (tmp_ls >>= 1) n_ls++;
-          tmp_ls = pow(2, n_ls);
-          if (x.hash_leaf_size != tmp_ls)
-            error(0, 0, _("Note: hash leaf size has been adjusted to %lld"), tmp_ls);
-          x.hash_leaf_size = tmp_ls * 1024;
+          off_t new_ls = 1;
+          while (tmp_ls >>= 1) new_ls <<= 1;
+          if (x.hash_leaf_size != new_ls)
+            error(0, 0, _("note: hash leaf size has been adjusted to %lld"), new_ls);
+          x.hash_leaf_size = new_ls * 1024;
           break;
         case HASH_TYPE_OPTION:
           x.hash_type = -1;
@@ -2511,24 +2758,53 @@ main (int argc, char **argv)
 
 // PZK >
   if (target_directory && x.read_stdin)
-    error (EXIT_FAILURE, 0, _("cannot use --target-directory (-t) with --read_stdin"));
-  if ((x.read_mode || x.write_mode) && x.fadvise) {
-    error(0, 0, _("Note: --fadvise has been disabled as it is incompatible with direct I/O"));
-    x.fadvise = false;
+    error (EXIT_FAILURE, 0, _("cannot use --target-directory (-t) with --read-stdin"));
+  if (x.read_mode && x.fadvise_read) {
+#if DEFAULT_DIRECT_READ
+    x.read_mode = 0;
+#elif DEFAULT_FADVISE_READ
+    x.fadvise_read = false;
+#else
+    error(0, 0, _("note: --fadvise-read disabled in favor of --direct-read"));
+    x.fadvise_read = false;
+#endif
+  }
+  if (x.write_mode && x.fadvise_write) {
+#if DEFAULT_DIRECT_WRITE
+    x.write_mode = 0;
+#elif DEFAULT_FADVISE_WRITE
+    x.fadvise_write = false;
+#else
+    error(0, 0, _("note: --fadvise-write disabled in favor of --direct-write"));
+    x.fadvise_write = false;
+#endif
   }
 #if HAVE_LIBGCRYPT
   //TODO: temporarily disable options that excercise filesystem bugs
   if (x.store_hash) {
-    error(0, 0, _("Note: hash stores have been temporarily disabled in this version"));
+    error(0, 0, _("note: hash stores have been temporarily disabled in this version"));
     x.store_hash = false;
   }
   //TODO: reenable above when filesystem bugs are fixed
-  if (x.split_size > 0 && (
-        x.split_size < x.buffer_size || x.split_size < x.hash_leaf_size))
-    error (EXIT_FAILURE, 0, _("split size must be greater than "
-        "buffer size and hash leaf size"));
+  if ((x.offset || x.length) && x.store_hash)
+    error(EXIT_FAILURE, 0, _("cannot store hash during partial file copy"));
+  if (x.split_size > 0 && x.split_size < x.buffer_size) {
+    error(0, 0, _("note: split size has been adjusted to the buffer size"));
+    x.split_size = x.buffer_size;
+  }
+  if (x.split_size > 0 && x.split_size < x.hash_leaf_size) {
+    error(0, 0, _("note: hash leaf size has been adjusted to the split size"));
+    x.hash_leaf_size = x.split_size;
+  }
+  if (!x.hash_leaf_size) {
+    error(0, 0, _("note: hash leaf size has been adjusted to 1GiB"));
+    x.hash_leaf_size = 1024 * 1024 * 1024;
+  }
   x.hash_size = gcry_md_get_algo_dlen(x.hash_type);
 #endif
+#ifndef _OPENMP
+  x.threads = 0;
+#endif
 #if HAVE_LIBGNUTLS && defined(_OPENMP)
   if (x.mgr_ai != NULL && x.mgr_port)
     ((struct sockaddr_in *) x.mgr_ai->ai_addr)->sin_port = htons(x.mgr_port);
@@ -2570,13 +2846,6 @@ main (int argc, char **argv)
     x.pass[16] = 0;
   }
 #endif
-#if HAVE_LIBGCRYPT && HAVE_LIBMPI && defined(_OPENMP)
-//TODO: debug mpi to see why so much memory used in 8 thread case
-if (x.mpi && x.threads > 6 && (x.print_hash || x.store_hash)) {
-    error(0, 0, _("Note: threads adjusted to 6 to prevent memory exhaustion"));
-    x.threads = 6;
-}
-#endif
 // < PZK
 
   ok = do_copy (argc - optind, argv + optind,
diff -rupN old1/src/mcore-omp.h new/src/mcore-omp.h
--- old1/src/mcore-omp.h	2011-01-04 14:42:08.000000000 -0800
+++ new/src/mcore-omp.h	2012-10-08 13:50:49.056671471 -0700
@@ -81,9 +81,10 @@
 #ifndef MCORE_OMP_H
 # define MCORE_OMP_H
 
+# include <stdlib.h>
+
 # ifdef _OPENMP
 #  include <omp.h>
-#  include <stdlib.h>
 
 typedef struct {
     omp_lock_t mutex;
@@ -93,14 +94,19 @@ typedef struct {
 } omp_sem_t;
 
 void omp_sem_init(omp_sem_t *s, int size, int free);
+void omp_sem_destroy(omp_sem_t *s);
 void omp_sem_procure(omp_sem_t *s);
 void omp_sem_vacate(omp_sem_t *s);
 int omp_sem_free(omp_sem_t *s);
 
+# endif
+
 typedef struct {
+# ifdef _OPENMP
     omp_sem_t max_sem;
     omp_sem_t min_sem;
     omp_lock_t q_lock;
+# endif
     int size;
     size_t ptr_size;
     int i_read;
@@ -108,7 +114,10 @@ typedef struct {
     void **vals;
 } omp_q_t;
 
+# ifdef _OPENMP
+
 void omp_q_init(omp_q_t *q, int size, size_t ptr_size);
+void omp_q_destroy(omp_q_t *q);
 void omp_q_push(omp_q_t *q, void *val);
 void *omp_q_pop(omp_q_t *q);
 int omp_q_size(omp_q_t *q);
diff -rupN old1/src/mcore.c new/src/mcore.c
--- old1/src/mcore.c	2011-01-04 14:42:08.000000000 -0800
+++ new/src/mcore.c	2012-10-08 13:50:49.052715248 -0700
@@ -86,7 +86,6 @@
 
 #if HAVE_LIBGCRYPT
 # include <gcrypt.h>
-# include <sys/xattr.h>
 # include "copy.h"
 
 void hash_tree(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
@@ -95,38 +94,39 @@ void hash_tree(hash_tree_t *htt, copy_re
     off_t n_hash = 0;
     while (htt->n_hash_total + co->hash_leaf_size <= n_read_total) {
         hash_leaf(htt, crt, co, &buf[n_hash],
-            co->hash_leaf_size - htt->hash_buf_len);
-        n_hash += co->hash_leaf_size - htt->hash_buf_len;
-        htt->hash_buf_len = 0;
+            co->hash_leaf_size - htt->hash_ctx_len);
+        n_hash += co->hash_leaf_size - htt->hash_ctx_len;
+        htt->hash_ctx_len = 0;
         htt->n_hash_total += co->hash_leaf_size;
     }
     if (n_read_total >= crt->stop_offset - crt->start_offset) {
+        // last iteration
         if (n_read_total > htt->n_hash_total)
             hash_leaf(htt, crt, co, &buf[n_hash],
-                n_read_total - htt->n_hash_total - htt->hash_buf_len);
+                n_read_total - htt->n_hash_total - htt->hash_ctx_len);
         if (co->store_hash && crt->split == 0) {
             // first split will write summary info
             char val[128];
             sprintf(val, "%s", (char *) gcry_md_algo_name(co->hash_type));
-            fsetxattr(htt->fd, "user.hash.type", val, strlen(val), 0);
+            //TODO:fsetxattr(htt->fd, "user.hash.type", val, strlen(val), 0);
             //TODO: check for errors
             sprintf(val, "%lld", co->hash_leaf_size);
-            fsetxattr(htt->fd, "user.hash.leaf.size", val, strlen(val), 0);
+            //TODO:fsetxattr(htt->fd, "user.hash.leaf.size", val, strlen(val), 0);
         }
         if (co->store_hash && htt->xattr_len > 0) {
             // store leftover xattr buffer
             char name[128];
             sprintf(name, "user.hash.tree.%lld.%lld",
                 crt->start_offset, crt->stop_offset);
-            fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
+            //TODO:fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
             //TODO: check for errors
         }
     } else {
-        // store in hash buf for next iteration
+        // store in hash context for next iteration
         if (n_read_total - htt->n_hash_total > 0)
-            memcpy(&htt->hash_buf[htt->hash_buf_len], &buf[n_hash],
-                n_read_total - htt->n_hash_total - htt->hash_buf_len);
-        htt->hash_buf_len = n_read_total - htt->n_hash_total;
+            gcry_md_write(*htt->hash_ctx, &buf[n_hash],
+                n_read_total - htt->n_hash_total - htt->hash_ctx_len);
+        htt->hash_ctx_len = n_read_total - htt->n_hash_total;
     }
 }
 
@@ -172,11 +172,11 @@ void hash_final(hash_tree_t *htt, copy_r
         htt->xattr_len += co->hash_size;
 
         if (htt->xattr_len + co->hash_size + 2 * sizeof(off_t) >
-                ATTR_MAX_VALUELEN) {
+                1/*TODO:ATTR_MAX_VALUELEN*/) {
             // xattr is full so store contents and reset xattr buffer
             char name[128];
             sprintf(name, "user.hash.tree.%lld.%lld", start * co->split_size, end_off);
-            fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
+            //TODO:fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
             //TODO: check for errors
 
             htt->xattr_len = 0;
@@ -187,15 +187,12 @@ void hash_final(hash_tree_t *htt, copy_r
 void hash_leaf(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
         const char *buf, ssize_t buf_len)
 {
-    gcry_md_hd_t ctx;
-    gcry_md_open(&ctx, co->hash_type, 0);
-    if (htt->hash_buf_len + buf_len > 0 || htt->n_hash_total == 0) {
+    if (htt->hash_ctx_len + buf_len > 0 || htt->n_hash_total == 0) {
         // something to hash or zero-length file
 
         // compute hash of block [start, end)
-        if (htt->hash_buf_len > 0) gcry_md_write(ctx, htt->hash_buf, htt->hash_buf_len);
-        if (buf_len > 0) gcry_md_write(ctx, buf, buf_len);
-        unsigned char *hash = gcry_md_read(ctx, 0);
+        if (buf_len > 0) gcry_md_write(*htt->hash_ctx, buf, buf_len);
+        unsigned char *hash = gcry_md_read(*htt->hash_ctx, 0);
 
         // store hash on stack
         memcpy(&htt->stack[htt->stack_len], hash, co->hash_size);
@@ -209,7 +206,7 @@ void hash_leaf(hash_tree_t *htt, copy_re
 
             // store end off_t
             *((off_t *) &htt->xattr[htt->xattr_len]) =
-                crt->start_offset + htt->n_hash_total + htt->hash_buf_len + buf_len;
+                crt->start_offset + htt->n_hash_total + htt->hash_ctx_len + buf_len;
             htt->xattr_len += sizeof(off_t);
 
             // store hash in xattr buffer
@@ -217,14 +214,14 @@ void hash_leaf(hash_tree_t *htt, copy_re
             htt->xattr_len += co->hash_size;
 
             if (htt->xattr_len + co->hash_size + 2 * sizeof(off_t) >
-                    ATTR_MAX_VALUELEN) {
+                    1/*TODO:ATTR_MAX_VALUELEN*/) {
                 // xattr is full so store contents and reset xattr buffer
                 char name[128];
                 sprintf(name, "user.hash.tree.%lld.%lld",
                     crt->start_offset + htt->n_hash_total,
                     crt->start_offset + htt->n_hash_total +
-                        htt->hash_buf_len + buf_len);
-                fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
+                        htt->hash_ctx_len + buf_len);
+                //TODO:fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
                 //TODO: check for errors
 
                 htt->xattr_len = 0;
@@ -232,11 +229,11 @@ void hash_leaf(hash_tree_t *htt, copy_re
         }
     }
 
-    off_t total = htt->n_hash_total + htt->hash_buf_len + buf_len;
+    off_t total = htt->n_hash_total + htt->hash_ctx_len + buf_len;
     off_t total_pow2 = total;
 
     // for final partial leaf node, compute hash subtree as if it were full
-    if (htt->hash_buf_len + buf_len < co->hash_leaf_size) {
+    if (htt->hash_ctx_len + buf_len < co->hash_leaf_size) {
         off_t n = 1;
         double leafs = total / (double) co->hash_leaf_size;
         while (n < leafs) n <<= 1;
@@ -249,13 +246,13 @@ void hash_leaf(hash_tree_t *htt, copy_re
             total_pow2 / (i * co->hash_leaf_size) % 2 == 0) {
         if (total_pow2 - i * co->hash_leaf_size < total) {
             // compute hash of last two hashes on stack
-            gcry_md_reset(ctx);
-            gcry_md_write(ctx, &htt->stack[htt->stack_len - 2 * co->hash_size],
+            gcry_md_reset(*htt->hash_ctx);
+            gcry_md_write(*htt->hash_ctx,&htt->stack[htt->stack_len - 2 * co->hash_size],
                 co->hash_size);
-            gcry_md_write(ctx, &htt->stack[htt->stack_len - co->hash_size],
+            gcry_md_write(*htt->hash_ctx, &htt->stack[htt->stack_len - co->hash_size],
                 co->hash_size);
             htt->stack_len -= 2 * co->hash_size;
-            unsigned char *hash = gcry_md_read(ctx, 0);
+            unsigned char *hash = gcry_md_read(*htt->hash_ctx, 0);
 
             // store hash on stack
             memcpy(&htt->stack[htt->stack_len], hash, co->hash_size);
@@ -277,13 +274,13 @@ void hash_leaf(hash_tree_t *htt, copy_re
                 htt->xattr_len += co->hash_size;
 
                 if (htt->xattr_len + co->hash_size + 2 * sizeof(off_t) >
-                        ATTR_MAX_VALUELEN) {
+                        1/*TODO:ATTR_MAX_VALUELEN*/) {
                     // xattr is full so store contents and reset xattr buffer
                     char name[128];
                     sprintf(name, "user.hash.tree.%lld.%lld",
                         crt->start_offset + total_pow2 - 2 * i * co->hash_leaf_size,
                         crt->start_offset + total);
-                    fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
+                    //TODO:fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
                     //TODO: check for errors
 
                     htt->xattr_len = 0;
@@ -292,7 +289,7 @@ void hash_leaf(hash_tree_t *htt, copy_re
         }
         i *= 2;
     }
-    gcry_md_close(ctx);
+    gcry_md_reset(*htt->hash_ctx);
 }
 
 #endif
@@ -319,6 +316,14 @@ void omp_sem_init(omp_sem_t *s, int size
     }
 }
 
+void omp_sem_destroy(omp_sem_t *s) {
+    for (int i = 0; i < s->size; i++) {
+        omp_destroy_lock(&s->waits[i]);
+    }
+    free(s->waits);
+    omp_destroy_lock(&s->mutex);
+}
+
 void omp_sem_procure(omp_sem_t *s) {
     omp_set_lock(&s->mutex);
     s->free--;
@@ -355,6 +360,13 @@ void omp_q_init(omp_q_t *q, int size, si
     q->vals = (void **) calloc(size, ptr_size);
 }
 
+void omp_q_destroy(omp_q_t *q) {
+    free(q->vals);
+    omp_destroy_lock(&q->q_lock);
+    omp_sem_destroy(&q->min_sem);
+    omp_sem_destroy(&q->max_sem);
+}
+
 void omp_q_push(omp_q_t *q, void *val) {
     omp_sem_procure(&q->max_sem);
     omp_set_lock(&q->q_lock);
diff -rupN old1/src/mcore.h new/src/mcore.h
--- old1/src/mcore.h	2011-01-04 14:42:08.000000000 -0800
+++ new/src/mcore.h	2012-10-08 13:50:49.052715248 -0700
@@ -90,17 +90,12 @@
 ///////////////////
 
 # if HAVE_LIBGCRYPT
-
-//TODO: this is not consistently defined across even altix systems
-//      need to test max of dest filesystem at start of transfer
-#  ifndef ATTR_MAX_VALUELEN
-#   define ATTR_MAX_VALUELEN 65536
-#  endif
+#  include <gcrypt.h>
 
 typedef struct {
     off_t n_hash_total;
-    char *hash_buf;
-    size_t hash_buf_len;
+    gcry_md_hd_t *hash_ctx;
+    size_t hash_ctx_len;
     char *xattr;
     size_t xattr_len;
     char *stack;
diff -rupN old1/src/md5sum.c new/src/md5sum.c
--- old1/src/md5sum.c	2011-01-04 14:42:08.000000000 -0800
+++ new/src/md5sum.c	2012-10-08 16:05:38.772661658 -0700
@@ -105,7 +105,6 @@
 
 // PZK >
 #include "buffer-lcm.h"
-#include "math.h"
 #include "mcore.h"
 #include "mkancesdirs.h"
 #include "quote.h"
@@ -139,7 +138,7 @@ GCRY_THREAD_OPTION_PTHREAD_IMPL;
 
 /* The official name of this program (e.g., no `g' prefix).  */
 #if HASH_ALGO_MD5
-# define PROGRAM_NAME "msum 1.76.1"
+# define PROGRAM_NAME "msum 1.76.6"
 # define DIGEST_TYPE_STRING "MD5"
 # define DIGEST_STREAM md5_stream
 # define DIGEST_BITS 128
@@ -197,6 +196,15 @@ GCRY_THREAD_OPTION_PTHREAD_IMPL;
 #ifndef DEFAULT_BUFFER_SIZE
 # define DEFAULT_BUFFER_SIZE 4
 #endif
+#ifndef DEFAULT_DIRECT_READ
+# define DEFAULT_DIRECT_READ 0
+#endif
+#ifndef DEFAULT_DOUBLE_BUFFER
+# define DEFAULT_DOUBLE_BUFFER 0
+#endif
+#ifndef DEFAULT_FADVISE_READ
+# define DEFAULT_FADVISE_READ 0
+#endif
 #if !defined(DEFAULT_HASH_TYPE) && HAVE_LIBGCRYPT
 # define DEFAULT_HASH_TYPE GCRY_MD_MD5
 #endif
@@ -244,8 +252,14 @@ enum
   BUFFER_SIZE_OPTION,
   DIRECT_READ_OPTION,
   DOUBLE_BUFFER_OPTION,
+  LENGTH_OPTION,
+  NO_DIRECT_READ_OPTION,
+  NO_DOUBLE_BUFFER_OPTION,
+  OFFSET_OPTION,
+  READ_STDIN_OPTION,
 #ifdef POSIX_FADV_DONTNEED
-  FADVISE_OPTION,
+  FADVISE_READ_OPTION,
+  NO_FADVISE_READ_OPTION,
 #endif
 #ifdef _OPENMP
   PRINT_STATS_OPTION,
@@ -253,6 +267,7 @@ enum
   THREADS_OPTION,
 #endif
 #if HAVE_LIBGCRYPT
+  CHECK_TREE_OPTION,
   HASH_LEAF_SIZE_OPTION,
   HASH_TYPE_OPTION,
   STORE_HASH_OPTION,
@@ -276,8 +291,14 @@ static struct option const long_options[
   {"buffer-size", required_argument, NULL, BUFFER_SIZE_OPTION},
   {"direct-read", no_argument, NULL, DIRECT_READ_OPTION},
   {"double-buffer", no_argument, NULL, DOUBLE_BUFFER_OPTION},
+  {"length", required_argument, NULL, LENGTH_OPTION},
+  {"no-direct-read", no_argument, NULL, NO_DIRECT_READ_OPTION},
+  {"no-double-buffer", no_argument, NULL, NO_DOUBLE_BUFFER_OPTION},
+  {"offset", required_argument, NULL, OFFSET_OPTION},
+  {"read-stdin", no_argument, NULL, READ_STDIN_OPTION},
 #ifdef POSIX_FADV_DONTNEED
-  {"fadvise", no_argument, NULL, FADVISE_OPTION},
+  {"fadvise-read", no_argument, NULL, FADVISE_READ_OPTION},
+  {"no-fadvise-read", no_argument, NULL, NO_FADVISE_READ_OPTION},
 #endif
 #ifdef _OPENMP
   {"print-stats", no_argument, NULL, PRINT_STATS_OPTION},
@@ -285,6 +306,7 @@ static struct option const long_options[
   {"threads", required_argument, NULL, THREADS_OPTION},
 #endif
 #if HAVE_LIBGCRYPT
+  {"check-tree", no_argument, NULL, CHECK_TREE_OPTION},
   {"hash-leaf-size", required_argument, NULL, HASH_LEAF_SIZE_OPTION},
   {"hash-type", required_argument, NULL, HASH_TYPE_OPTION},
   {"store-hash", no_argument, NULL, STORE_HASH_OPTION},
@@ -320,29 +342,45 @@ static struct option const long_options[
 static void
 sum_option_init (struct sum_options *x)
 {
-  x->threads = DEFAULT_THREADS;
-  x->store_hash = false;
-#if HAVE_LIBGCRYPT
-  x->hash_type = DEFAULT_HASH_TYPE;
+  x->buffer_size = DEFAULT_BUFFER_SIZE * 1024 * 1024;
+  x->check_tree = false;
+#if DEFAULT_DOUBLE_BUFFER
+  x->double_buffer = true;
+#else
+  x->double_buffer = false;
+#endif
+#if DEFAULT_FADVISE_READ
+  x->fadvise_read = true;
+#else
+  x->fadvise_read = false;
 #endif
   x->hash_size = 0;
-  x->print_stats = false;
-  x->double_buffer = false;
-  x->buffer_size = DEFAULT_BUFFER_SIZE * 1024 * 1024;
-  x->split_size = DEFAULT_SPLIT_SIZE * 1024 * 1024;
-  x->hash_leaf_size = x->split_size;
-  x->read_mode = 0;
-  x->fadvise = false;
-  x->mpi = false;
   x->hash_stat_tasks = xcalloc(1, sizeof(long long));
+#if HAVE_LIBGCRYPT
+  x->hash_type = DEFAULT_HASH_TYPE;
+#endif
+  x->length = 0;
   x->listen_port = 0;
-  x->pw_file = 0;
   x->mg_file = NULL;
-  x->mgr_port = 0;
   x->mgr_ai = NULL;
-  x->user = NULL;
+  x->mgr_port = 0;
+  x->mpi = false;
+  x->offset = 0;
   x->pass = NULL;
+  x->print_stats = false;
+  x->pw_file = 0;
+#if DEFAULT_DIRECT_READ
+  x->read_mode = O_DIRECT;
+#else
+  x->read_mode = 0;
+#endif
+  x->read_stdin = false;
+  x->split_size = DEFAULT_SPLIT_SIZE * 1024 * 1024;
+  x->hash_leaf_size = x->split_size; // this must follow split_size
+  x->store_hash = false;
   x->task_q = NULL;
+  x->threads = DEFAULT_THREADS;
+  x->user = NULL;
 }
 
 extern bool
@@ -414,13 +452,12 @@ sum_task(sum_task_t *stt, struct sum_opt
 
 #if HAVE_LIBGCRYPT
   gcry_md_hd_t ctx;
-  if (stt->nsplits == 1) {
-    gcry_md_open(&ctx, so->hash_type, 0);
-  } else {
+  gcry_md_open(&ctx, so->hash_type, 0);
+  if (stt->nsplits > 1) {
     htt.n_hash_total = 0;
-    htt.hash_buf = xmalloc(so->hash_leaf_size);
-    htt.hash_buf_len = 0;
-    htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
+    htt.hash_ctx = &ctx;
+    htt.hash_ctx_len = 0;
+//TODO:    if (so->store_hash) htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
     htt.xattr_len = 0;
     //TODO: this is wrong since there is no writable dst
     //htt.fd = stt->dest_desc;
@@ -445,16 +482,38 @@ sum_task(sum_task_t *stt, struct sum_opt
 
   for (;;)
     {
-      if (stt->nsplits > 1 && n_read_total >= so->split_size) break;
+      if (n_read_total >= stt->stop_offset - stt->start_offset) break;
 
       ssize_t n_read;
       if (aiol[0] != NULL) {
         // this will be skipped during the first double buffer iteration
-        aio_suspend(aiol, 1, NULL);
+        aio_suspend((const struct aiocb * const *) aiol, 1, NULL);
         n_read = aio_return(aiol[0]);
       } else {
+        off_t to_read = MIN(buf_size,
+            stt->stop_offset - stt->start_offset - n_read_total);
+        // align offset for direct i/o and better performance when buffered
+        off_t align_read = (stt->start_offset + n_read_total) % 4096;
+        if (align_read != 0 && to_read > 4096) to_read = 4096 - align_read;
+        if (so->read_mode && to_read < buf_size) {
+            // turn off direct i/o if going to read unaligned block
+            int old_flags = fcntl(source_desc, F_GETFL);
+            if (fcntl(source_desc, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                    quote (stt->src_name));
+        }
+
         if (so->print_stats) clock_gettime(CLOCK_REALTIME, &rts[0]);
-        n_read = read (source_desc, buf[aio_buf], buf_size);
+        n_read = read (source_desc, buf[aio_buf], to_read);
+
+        if (so->read_mode && align_read != 0) {
+            // turn direct i/o back on in case it was turned off
+            int old_flags = fcntl(source_desc, F_GETFL);
+            if (old_flags & O_DIRECT == 0 &&
+                fcntl(source_desc, F_SETFL, old_flags | O_DIRECT) != 0)
+                    error(0, errno, _("failed to turn on O_DIRECT: %s"),
+                        quote(stt->src_name));
+        }
       }
 
       if (so->print_stats) {
@@ -478,7 +537,7 @@ sum_task(sum_task_t *stt, struct sum_opt
         break;
 
 #ifdef POSIX_FADV_DONTNEED
-      if (so->fadvise) {
+      if (so->fadvise_read) {
         // indicate done with read data
         posix_fadvise(source_desc, stt->start_offset + n_read_total,
             n_read, POSIX_FADV_DONTNEED);
@@ -487,13 +546,23 @@ sum_task(sum_task_t *stt, struct sum_opt
 
       n_read_total += n_read;
 
-      if (so->double_buffer) {
+      off_t to_read = MIN(buf_size,
+        stt->stop_offset - stt->start_offset - n_read_total);
+      if (so->double_buffer && to_read > 0) {
+        if (so->read_mode && to_read < buf_size) {
+            // turn off direct i/o if going to read unaligned block
+            int old_flags = fcntl(source_desc, F_GETFL);
+            if (fcntl(source_desc, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                    quote (stt->src_name));
+        }
+
         if (so->print_stats) clock_gettime(CLOCK_REALTIME, &rts[0]);
         memset(&aio, 0, sizeof(struct aiocb));
         aio.aio_fildes = source_desc;
         aio.aio_offset = stt->start_offset + n_read_total;
         aio.aio_buf = buf[!aio_buf];
-        aio.aio_nbytes = buf_size;
+        aio.aio_nbytes = to_read;
         aiol[0] = &aio;
         //TODO: error handling for bad aio_read
         aio_read(&aio);
@@ -501,6 +570,7 @@ sum_task(sum_task_t *stt, struct sum_opt
 
       if (so->print_stats) clock_gettime(CLOCK_REALTIME, &hts[0]);
 #if HAVE_LIBGCRYPT
+       //TODO: is st_size right for partial files?
       if (stt->nsplits > 1)
         hash_tree(&htt, stt, so, buf[aio_buf], n_read_total, src_open_sb.st_size);
       else
@@ -538,20 +608,17 @@ task_close_src_and_dst_desc:
   }
 
 #if HAVE_LIBGCRYPT
+  gcry_md_close(ctx);
   if (stt->nsplits > 1) {
-    free(htt.hash_buf);
-    free(htt.xattr);
+    if (so->store_hash) free(htt.xattr);
     free(htt.stack);
-  } else {
-    gcry_md_close(ctx);
   }
 #endif
 
   return return_val;
 }
 
-void print_check(struct sum_options *x, char *filename,
-    unsigned char *hash_check, unsigned char *hash_stack)
+void print_check(struct sum_options *x, sum_task_t *stt)
 {
 //TODO: need to make this for general hash length
     static const char bin2hex[] = { '0', '1', '2', '3',
@@ -559,45 +626,78 @@ void print_check(struct sum_options *x,
                                     '8', '9', 'a', 'b',
                                     'c', 'd', 'e', 'f' };
     size_t digest_bin_bytes = digest_hex_bytes / 2;
-    size_t cnt;
+    size_t cnt, s;
+    unsigned char *stack = stt->hash_stack;
+    unsigned char *check = stt->hash_check;
+    int fail = 0;
+    if (!status_only) printf("%s: ", stt->src_name);
+
     /* Compare generated binary number with text representation
        in check file.  Ignore case of hex digits.  */
-    for (cnt = 0; cnt < digest_bin_bytes; ++cnt)
-      {
-        if (tolower (hash_check[2 * cnt])
-            != bin2hex[hash_stack[cnt] >> 4]
-            || (tolower (hash_check[2 * cnt + 1])
-                != (bin2hex[hash_stack[cnt] & 0xf])))
-          break;
-      }
+    int nsplits = x->check_tree ? stt->nsplits : 1;
+    for (s = 0; s < nsplits; s++) {
+        for (cnt = 0; cnt < digest_bin_bytes; ++cnt) {
+            if (tolower (check[2 * cnt])
+                != bin2hex[stack[cnt] >> 4]
+                || (tolower (check[2 * cnt + 1])
+                    != (bin2hex[stack[cnt] & 0xf])))
+            break;
+        }
+        if (!status_only) {
+            if (cnt != digest_bin_bytes) {
+                if (!fail) {
+                    printf("%s", _("FAILED"));
+                    fail = 1;
+                }
+                if (stt->partial || x->check_tree) {
+                    off_t end = stt->start_offset + (s + 1) * x->split_size;
+                    if (end > stt->stop_offset) end = stt->stop_offset;
+                    printf(",%lld-%lld",
+                        stt->start_offset + s * x->split_size, end);
+                }
+            }
+        }
+        stack += digest_bin_bytes;
+        check += digest_hex_bytes;
+    }
 /*TODO: do something with this in hash thread
     if (cnt != digest_bin_bytes)
       ++n_mismatched_checksums;
 */
-
-    if (!status_only)
-      {
-        if (cnt != digest_bin_bytes)
-          printf ("%s: %s\n", filename, _("FAILED"));
-        else if (!quiet)
-          printf ("%s: %s\n", filename, _("OK"));
+    if (!status_only) {
+        if (!quiet && !fail) {
+            printf("%s", _("OK"));
+            if (stt->partial)
+                printf(",%lld-%lld", stt->start_offset, stt->stop_offset);
+        }
+        if (fail || !quiet) printf("\n");
         fflush (stdout);
-      }
+    }
 }
 
+
 //TODO: general hash length
-void print_hash(struct sum_options *x, char *file,
-    unsigned char *hash_stack)
+void print_hash(struct sum_options *x, sum_task_t *stt)
 {
     size_t i;
 
+    // put non-standard output in comments
+    if (stt->nsplits > 1 || stt->partial) {
+        printf("#mutil#");
+        if (stt->partial)
+            printf("%lld-%lld", stt->start_offset, stt->stop_offset);
+        printf("#");
+    }
+
     /* Output a leading backslash if the file name contains
        a newline or backslash.  */
-    if (strchr (file, '\n') || strchr (file, '\\'))
+    if (strchr (stt->src_name, '\n') || strchr (stt->src_name, '\\'))
       putchar ('\\');
 
-    for (i = 0; i < (digest_hex_bytes / 2); ++i)
-      printf ("%02x", hash_stack[i]);
+    size_t bytes = digest_hex_bytes / 2;
+    if (x->check_tree) bytes *= stt->nsplits;
+    for (i = 0; i < bytes; ++i)
+      printf ("%02x", stt->hash_stack[i]);
 
     putchar (' ');
 /*TODO: do something with this binary stuff
@@ -609,9 +709,9 @@ void print_hash(struct sum_options *x, c
 
     /* Translate each NEWLINE byte to the string, "\\n",
        and each backslash to "\\\\".  */
-    for (i = 0; i < strlen (file); ++i)
+    for (i = 0; i < strlen (stt->src_name); ++i)
       {
-        switch (file[i])
+        switch (stt->src_name[i])
           {
           case '\n':
             fputs ("\\n", stdout);
@@ -622,7 +722,7 @@ void print_hash(struct sum_options *x, c
             break;
 
           default:
-            putchar (file[i]);
+            putchar (stt->src_name[i]);
             break;
           }
       }
@@ -650,14 +750,27 @@ With no FILE, or when FILE is -, read st
       fprintf (stdout, _("\
       --buffer-size=MBYTES     read/write buffer size [%d]\n"),
         DEFAULT_BUFFER_SIZE);
+#if HAVE_LIBGCRYPT
+      fputs (_("\
+      --check-tree             print/check hash subtrees to pinpoint corruption\n\
+"), stdout);
+#endif
+#if !DEFAULT_DIRECT_READ
       fputs (_("\
       --direct-read            enable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if !DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
       --double-buffer          enable use of double buffering during file I/O\n\
 "), stdout);
+#endif
 #ifdef POSIX_FADV_DONTNEED
+# if !DEFAULT_FADVISE_READ
       fputs (_("\
-      --fadvise                enable use of posix_fadvise during file I/O\n\
+      --fadvise-read           enable use of posix_fadvise during reads\n\
 "), stdout);
+# endif
 #endif
 #if HAVE_LIBGCRYPT
       fprintf (stdout, _("\
@@ -680,6 +793,10 @@ With no FILE, or when FILE is -, read st
       }
       fputs(_("\n"), stdout);
 #endif
+      fputs (_("\
+      --length=LEN             hash LEN bytes beginning at --offset\n\
+                                 (or 0 if --offset not specified)\n\
+"), stdout);
 #if HAVE_LIBGNUTLS && defined(_OPENMP)
       fputs (_("\
       --listen-port=PORT       listen on port PORT for requests from\n\
@@ -694,6 +811,27 @@ With no FILE, or when FILE is -, read st
       --mpi                    enable use of MPI for multi-node checksums\n\
 "), stdout);
 #endif
+#if DEFAULT_DIRECT_READ
+      fputs (_("\
+      --no-direct-read         disable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
+      --no-double-buffer       disable use of double buffering during file I/O\n\
+"), stdout);
+#endif
+#ifdef POSIX_FADV_DONTNEED
+# if DEFAULT_FADVISE_READ
+      fputs (_("\
+      --no-fadvise-read        disable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+#endif
+      fputs (_("\
+      --offset=POS             hash --length bytes beginning at POS\n\
+                                 (or to end if --length not specified)\n\
+"), stdout);
 #if HAVE_LIBGNUTLS && defined(_OPENMP)
       fputs (_("\
       --password-file=FILE     file to use for passwords (will be created\n\
@@ -702,6 +840,11 @@ With no FILE, or when FILE is -, read st
 #endif
 #ifdef _OPENMP
       fprintf (stdout, _("\
+      --read-stdin             perform a batch of operations read over stdin\n\
+                                 in the form 'FILE RANGES' where FILE must be\n\
+                                 a URI-escaped (RFC 3986) file name and RANGES\n\
+                                 is zero or more comma-separated ranges of the\n\
+                                 form 'START-END' for 0 <= START < END\n\
       --split-size=MBYTES      size to split files for parallelization [%d]\n\
       --threads=NUMBER         number of OpenMP worker threads to use [%d]\n\
 \n\
@@ -844,6 +987,11 @@ split_3 (char *s, size_t s_len,
      representation of the message digest.  If it is not followed
      immediately by a white space it's an error.  */
   i += digest_hex_bytes;
+// PZK >
+  //TODO: put this in for checktree
+  while (!ISWHITE (s[i]))
+    i++;
+// < PZK
   if (!ISWHITE (s[i]))
     return false;
 
@@ -909,6 +1057,10 @@ split_3 (char *s, size_t s_len,
 static bool
 hex_digits (unsigned char const *s)
 {
+// PZK >
+    //TODO: temporarily set this true until check-tree finalized
+    return true;
+// < PZK
   unsigned int i;
   for (i = 0; i < digest_hex_bytes; i++)
     {
@@ -942,8 +1094,7 @@ digest_file (struct sum_options *x, unsi
 
 // PZK >
 #if HAVE_LIBGCRYPT && defined(_OPENMP)
-  if (is_stdin)
-    error (EXIT_FAILURE, 0, _("stdin is not support yet in this version"));
+  if (is_stdin) goto do_stdin;
 
   struct stat src_sb;
   if (stat (filename, &src_sb) != 0) {
@@ -958,11 +1109,15 @@ digest_file (struct sum_options *x, unsi
 
 //TODO:  do something with binary?  why should that matter?
   off_t pos = 0;
+  if (x->offset && x->offset > src_sb.st_size) pos = src_sb.st_size;
+  else if (x->offset) pos = x->offset;
+  off_t end = src_sb.st_size;
+  if (x->length && pos + x->length < end) end = pos + x->length;
   size_t nsplits = 1, split = 0;
-  if (x->split_size > 0 && src_sb.st_size > 0)
-      nsplits = src_sb.st_size / x->split_size +
-          (src_sb.st_size % x->split_size ? 1 : 0);
-  while (pos == 0 || pos < src_sb.st_size) {
+  if (x->split_size > 0 && end - pos > 0)
+      nsplits = (end - pos) / x->split_size +
+          ((end - pos) % x->split_size ? 1 : 0);
+  while (pos == 0 || pos < end) {
       sum_task_t *stt = xmalloc(sizeof(sum_task_t));
       stt->src_name = xstrdup(filename);
       stt->dst_blksize = io_blksize(src_sb);
@@ -972,18 +1127,21 @@ digest_file (struct sum_options *x, unsi
       stt->nsplits = nsplits;
       stt->split = split++;
       stt->start_offset = pos;
+      stt->partial = x->offset || end < src_sb.st_size ? true : false;
       stt->hash_stack = xmalloc(x->hash_size);
       stt->hash_check = NULL;
       *x->hash_stat_tasks += 1;
       pos += x->split_size;
       if (nsplits > 1) {
           // stop after split size bytes
-          stt->stop_offset = MIN(pos, src_sb.st_size);
-          if (stt->start_offset == 0) {
+          stt->stop_offset = MIN(pos, end);
+          if (stt->start_offset == x->offset) {
               sum_task_t *sttcp = xmalloc(sizeof(sum_task_t));
               sttcp->nsplits = nsplits;
               sttcp->split = nsplits;
-              sttcp->stop_offset = src_sb.st_size;
+              sttcp->start_offset = x->offset;
+              sttcp->stop_offset = end;
+              sttcp->partial = stt->partial;
               sttcp->src_name = xstrdup(filename);
               sttcp->hash_stack = xmalloc(nsplits * x->hash_size);
               sttcp->hash_check = h_check;
@@ -1004,13 +1162,14 @@ digest_file (struct sum_options *x, unsi
           }
       } else {
           // stop at end of file
-          stt->stop_offset = src_sb.st_size;
+          stt->stop_offset = end;
           stt->hash_check = h_check;
       }
       omp_q_push(x->task_q, stt);
       if (nsplits == 1) break;
   }
   return true;
+do_stdin:
 #endif
 // < PZK
 
@@ -1106,15 +1265,30 @@ digest_check (struct sum_options *x, con
       if (line_length <= 0)
         break;
 
-      /* Ignore comment lines, which begin with a '#' character.  */
-      if (line[0] == '#')
-        continue;
-
       /* Remove any trailing newline.  */
       if (line[line_length - 1] == '\n')
         line[--line_length] = '\0';
 
-      if (! (split_3 (line, line_length, &hex_digest, &binary, &filename)
+// PZK >
+      off_t stop;
+      if (sscanf(line, "#mutil#%lld-%lld", &x->offset, &stop) != 2) {
+        x->offset = 0;
+        x->length = 0;
+      } else {
+        x->length = stop - x->offset;
+      }
+      size_t iline = 0;
+      if (!strncmp(line, "#mutil#", 7)) {
+        iline = strcspn(&line[7], "#") + 8;
+        if (iline > line_length) continue;
+        line_length -= iline;
+      } else
+      /* Ignore comment lines, which begin with a '#' character.  */
+      if (line[0] == '#')
+        continue;
+
+      if (! (split_3(&line[iline], line_length, &hex_digest, &binary, &filename)
+// < PZK
              && ! (is_stdin && STREQ (filename, "-"))
              && hex_digits (hex_digest)))
         {
@@ -1235,6 +1409,74 @@ digest_check (struct sum_options *x, con
           && n_open_or_read_failures == 0);
 }
 
+// PZK >
+/* unescape() based on curl_easy_escape() to which the following applies
+COPYRIGHT AND PERMISSION NOTICE
+
+Copyright (c) 1996 - 2009, Daniel Stenberg, <daniel@haxx.se>.
+
+All rights reserved.
+
+Permission to use, copy, modify, and distribute this software for any purpose
+with or without fee is hereby granted, provided that the above copyright
+notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN
+NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of a copyright holder shall not
+be used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization of the copyright holder.
+*/
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string.
+ * If length == 0, the length is assumed to be strlen(string).
+ */
+char *unescape(const char *string, int length)
+{
+  int alloc = (length?length:(int)strlen(string))+1;
+  char *ns = xmalloc(alloc);
+  unsigned char in;
+  int strindex=0;
+  long hex;
+
+  if( !ns )
+    return NULL;
+
+  while(--alloc > 0) {
+    in = *string;
+    if(('%' == in) && isxdigit(string[1]) && isxdigit(string[2])) {
+      /* this is two hexadecimal digits following a '%' */
+      char hexstr[3];
+      char *ptr;
+      hexstr[0] = string[1];
+      hexstr[1] = string[2];
+      hexstr[2] = 0;
+
+      hex = strtol(hexstr, &ptr, 16);
+
+      in = (unsigned char)hex; /* this long is never bigger than 255 anyway */
+
+      string+=2;
+      alloc-=2;
+    }
+
+    ns[strindex++] = in;
+    string++;
+  }
+  ns[strindex]=0; /* terminate it */
+
+  return ns;
+}
+// < PZK
+
 int
 main (int argc, char **argv)
 {
@@ -1269,12 +1511,11 @@ main (int argc, char **argv)
           if (x.buffer_size < 1 || x.buffer_size > 128)
             error (EXIT_FAILURE, 0, _("invalid buffer size"));
           size_t tmp_bs = x.buffer_size;
-          int n_bs = 0;
-          while (tmp_bs >>= 1) n_bs++;
-          tmp_bs = pow(2, n_bs);
-          if (x.buffer_size != tmp_bs)
-            error(0, 0, _("Note: buffer size has been adjusted to %lld"), tmp_bs);
-          x.buffer_size = tmp_bs * 1024 * 1024;
+          size_t new_bs = 1;
+          while (tmp_bs >>= 1) new_bs <<= 1;
+          if (x.buffer_size != new_bs)
+            error(0, 0, _("Note: buffer size has been adjusted to %lld"), new_bs);
+          x.buffer_size = new_bs * 1024 * 1024;
           break;
         case DIRECT_READ_OPTION:
           x.read_mode = O_DIRECT;
@@ -1282,9 +1523,31 @@ main (int argc, char **argv)
         case DOUBLE_BUFFER_OPTION:
           x.double_buffer = true;
           break;
+        case LENGTH_OPTION:
+          x.length = strtoll(optarg, (char **) NULL, 10);
+          if (x.length < 1)
+            error (EXIT_FAILURE, 0, _("invalid length"));
+          break;
+        case NO_DIRECT_READ_OPTION:
+          x.read_mode = 0;
+          break;
+        case NO_DOUBLE_BUFFER_OPTION:
+          x.double_buffer = false;
+          break;
+        case OFFSET_OPTION:
+          x.offset = strtoll(optarg, (char **) NULL, 10);
+          if (x.offset < 0)
+            error (EXIT_FAILURE, 0, _("invalid offset"));
+          break;
+        case READ_STDIN_OPTION:
+          x.read_stdin = true;
+          break;
 #ifdef POSIX_FADV_DONTNEED
-        case FADVISE_OPTION:
-          x.fadvise = true;
+        case FADVISE_READ_OPTION:
+          x.fadvise_read = true;
+          break;
+        case NO_FADVISE_READ_OPTION:
+          x.fadvise_read = false;
           break;
 #endif
 #ifdef _OPENMP
@@ -1292,17 +1555,16 @@ main (int argc, char **argv)
           x.print_stats = true;
           break;
         case SPLIT_SIZE_OPTION:
-          x.split_size = (int) strtol(optarg, (char **) NULL, 10);
+          x.split_size = strtoll(optarg, (char **) NULL, 10);
           if (x.split_size < 0)
             error (EXIT_FAILURE, 0, _("invalid split size"));
           if (x.split_size > 0) {
             off_t tmp_ss = x.split_size;
-            int n_ss = 0;
-            while (tmp_ss >>= 1) n_ss++;
-            tmp_ss = pow(2, n_ss);
-            if (x.split_size != tmp_ss)
-              error(0, 0, _("Note: split size has been adjusted to %lld"), tmp_ss);
-            x.split_size = tmp_ss * 1024 * 1024;
+            off_t new_ss = 1;
+            while (tmp_ss >>= 1) new_ss <<= 1;
+            if (x.split_size != new_ss)
+              error(0, 0, _("Note: split size has been adjusted to %lld"), new_ss);
+            x.split_size = new_ss * 1024 * 1024;
           }
           break;
         case THREADS_OPTION:
@@ -1312,17 +1574,19 @@ main (int argc, char **argv)
           break;
 #endif
 #if HAVE_LIBGCRYPT
+        case CHECK_TREE_OPTION:
+          x.check_tree = true;
+          break;
         case HASH_LEAF_SIZE_OPTION:
-          x.hash_leaf_size = (int) strtol(optarg, (char **) NULL, 10);
+          x.hash_leaf_size = strtoll(optarg, (char **) NULL, 10);
           if (x.hash_leaf_size < 1)
             error (EXIT_FAILURE, 0, _("invalid hash leaf size"));
           off_t tmp_ls = x.hash_leaf_size;
-          int n_ls = 0;
-          while (tmp_ls >>= 1) n_ls++;
-          tmp_ls = pow(2, n_ls);
-          if (x.hash_leaf_size != tmp_ls)
-            error(0, 0, _("Note: hash leaf size has been adjusted to %lld"), tmp_ls);
-          x.hash_leaf_size = tmp_ls * 1024;
+          off_t new_ls = 1;
+          while (tmp_ls >>= 1) new_ls <<= 1;
+          if (x.hash_leaf_size != new_ls)
+            error(0, 0, _("Note: hash leaf size has been adjusted to %lld"), new_ls);
+          x.hash_leaf_size = new_ls * 1024;
           break;
         case HASH_TYPE_OPTION:
           x.hash_type = -1;
@@ -1431,11 +1695,20 @@ main (int argc, char **argv)
 
   if (optind == argc)
     argv[argc++] = bad_cast ("-");
-
 // PZK >
-  if (x.read_mode && x.fadvise) {
-    error(0, 0, _("Note: --fadvise has been disabled as it is incompatible with direct I/O"));
-    x.fadvise = false;
+  else if (x.read_stdin)
+    error (EXIT_FAILURE, 0, _("--read-stdin cannot be used with other arguments"));
+  if (x.read_stdin && do_check)
+    error (EXIT_FAILURE, 0, _("--read-stdin cannot be used with -c/--check"));
+  if (x.read_mode && x.fadvise_read) {
+#if DEFAULT_DIRECT_READ
+    x.read_mode = 0;
+#elif DEFAULT_FADVISE_READ
+    x.fadvise_read = false;
+#else
+    error(0, 0, _("Note: --fadvise-read disabled in favor of --direct-read"));
+    x.fadvise_read = false;
+#endif
   }
 #if HAVE_LIBGCRYPT
   //TODO: temporarily disable options that excercise filesystem bugs
@@ -1444,12 +1717,22 @@ main (int argc, char **argv)
     x.store_hash = false;
   }
   //TODO: reenable above when filesystem bugs are fixed
+  if ((x.offset || x.length) && x.store_hash)
+    error(EXIT_FAILURE, 0, _("cannot store hash during partial file copy"));
   if (do_check && x.store_hash)
     error (EXIT_FAILURE, 0, _("cannot use --store-hash when verifying checksums"));
-  if (x.split_size > 0 && (
-        x.split_size < x.buffer_size || x.split_size < x.hash_leaf_size))
-    error (EXIT_FAILURE, 0, _("split size must be greater than "
-        "buffer size and hash leaf size"));
+  if (x.split_size > 0 && x.split_size < x.buffer_size) {
+    error(0, 0, _("Note: split size has been adjusted to the buffer size"));
+    x.split_size = x.buffer_size;
+  }
+  if (x.split_size > 0 && x.split_size < x.hash_leaf_size) {
+    error(0, 0, _("Note: hash leaf size has been adjusted to the split size"));
+    x.hash_leaf_size = x.split_size;
+  }
+  if (!x.hash_leaf_size) {
+    error(0, 0, _("Note: hash leaf size has been adjusted to 1GiB"));
+    x.hash_leaf_size = 1024 * 1024 * 1024;
+  }
   x.hash_size = gcry_md_get_algo_dlen(x.hash_type);
   min_digest_line_length = 2 * x.hash_size + 2 + 1;
   digest_hex_bytes = 2 * x.hash_size;
@@ -1495,13 +1778,6 @@ main (int argc, char **argv)
     x.pass[16] = 0;
   }
 #endif
-#if HAVE_LIBMPI && defined(_OPENMP)
-//TODO: debug mpi to see why so much memory used in 8 thread case
-if (x.mpi && x.threads > 6) {
-    error(0, 0, _("Note: threads adjusted to 6 to prevent memory exhaustion"));
-    x.threads = 6;
-}
-#endif
 
 #ifdef _OPENMP
   int pid = 0, procs = 1;
@@ -1588,9 +1864,9 @@ if (x.mpi && x.threads > 6) {
 
       if (stt->nsplits == 1) {
         if (stt->hash_check != NULL) {
-            print_check(&x, stt->src_name, stt->hash_check, stt->hash_stack);
+            print_check(&x, stt);
         } else {
-            print_hash(&x, stt->src_name, stt->hash_stack);
+            print_hash(&x, stt);
         }
       }
 
@@ -1640,26 +1916,31 @@ if (x.mpi && x.threads > 6) {
         if (--stt->split == 0) {
 #if HAVE_LIBGCRYPT
             // finalize hash if last
+            gcry_md_hd_t ctx;
+            gcry_md_open(&ctx, x.hash_type, 0);
             hash_tree_t htt;
             htt.n_hash_total = 0;
-            htt.hash_buf = xmalloc(x.hash_leaf_size);
-            htt.hash_buf_len = 0;
-            htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
+            htt.hash_ctx = &ctx;
+            htt.hash_ctx_len = 0;
+//TODO:            if (x.store_hash) htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
             htt.xattr_len = 0;
             // this works because dest_desc will be open in first stt received
             //TODO: htt.fd = stt->dest_desc;
             htt.stack_len = 0;
-            hash_final(&htt, stt, &x, 0, stt->nsplits, stt->stop_offset);
+            // don't compute root of tree when printing/checking subtrees
+            if (!x.check_tree)
+                hash_final(&htt, stt, &x, 0, stt->nsplits,
+                    stt->stop_offset - stt->start_offset);
             // print or check hash
             if (stt->hash_check != NULL) {
-                print_check(&x, stt->src_name, stt->hash_check, stt->hash_stack);
+                print_check(&x, stt);
             } else {
-                print_hash(&x, stt->src_name, stt->hash_stack);
+                print_hash(&x, stt);
             }
             // clean up
             //TODO if (x.store_hash) close(stt->dest_desc);
-            free(htt.hash_buf);
-            free(htt.xattr);
+            gcry_md_close(ctx);
+            if (x.store_hash) free(htt.xattr);
             free(stt->hash_stack);
             free(stt->hash_check);
 #endif
@@ -2199,7 +2480,46 @@ if (x.mpi && x.threads > 6) {
   for (; optind < argc; ++optind)
     {
       char *file = argv[optind];
-
+// PZK >
+      if (x.read_stdin) {
+        size_t buf_max = MIN(PATH_MAX, 32 * 1024);
+        char *buf = xmalloc(buf_max);
+
+        while (fgets(buf, buf_max, stdin) != NULL) {
+            buf[strcspn(buf, "\n")] = '\0';
+            if (file[0] == '\0') {
+                //TODO: error handling if string too long
+                continue;
+            }
+            size_t irange = strcspn(buf, " ");
+            if (buf[irange] == '\0') irange = 0;
+            else buf[irange++] = '\0';
+            file = unescape(buf, 0);
+            if (file == NULL) {
+                //TODO: error handling if can't unescape
+                continue;
+            }
+            int file_is_binary = binary;
+            if (irange > 0) {
+                off_t x1, x2;
+                while (sscanf(&buf[irange], "%lld-%lld", &x1, &x2) == 2) {
+                    x.offset = x1;
+                    x.length = x2 - x1;
+                    if (! digest_file (&x, NULL, file, &file_is_binary,
+                            bin_buffer)) ok = false;
+                    irange += strcspn(&buf[irange], ",");
+                    if (buf[irange] == ',') irange++;
+                }
+            } else {
+                x.offset = 0;
+                x.length = 0;
+                if (! digest_file (&x, NULL, file, &file_is_binary, bin_buffer))
+                    ok = false;
+            }
+        }
+        break;
+      }
+// < PZK
       if (do_check)
         ok &= digest_check (&x, file);
       else
@@ -2212,7 +2532,7 @@ if (x.mpi && x.threads > 6) {
             {
 // PZK >
 #ifdef _OPENMP
-              continue;
+              if (!STREQ (file, "-")) continue;
 #endif
 // < PZK
               size_t i;
@@ -2278,6 +2598,10 @@ if (x.mpi && x.threads > 6) {
   if (x.mpi) MPI_Finalize();
 # endif
 
+  // destroy all queues
+  omp_q_destroy(&send_q);
+  omp_q_destroy(&task_q);
+
   //TODO: this no longer works with mpi/tcp
   // reduce oks array to single value
   for (int i = 0; i < x.threads; i++)
