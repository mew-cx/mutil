diff -rupN orig/COPYING new/COPYING
--- orig/COPYING	2009-09-01 04:01:16.000000000 -0700
+++ new/COPYING	2012-10-08 13:50:50.312673687 -0700
@@ -1,3 +1,8 @@
+#####################################################################
+#### NOTE: ADDITIONAL TERMS APPLY PER SECTION 7 OF THIS LICENSE. ####
+####       SEE INDIVIDUAL SOURCE FILES FOR THESE TERMS.          ####
+#####################################################################
+
                     GNU GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007
 
diff -rupN orig/Makefile.in new/Makefile.in
--- orig/Makefile.in	2009-09-10 22:56:45.000000000 -0700
+++ new/Makefile.in	2012-10-08 13:50:50.304691404 -0700
@@ -145,27 +145,27 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/0
 	$(top_srcdir)/m4/mbiter.m4 $(top_srcdir)/m4/mbrlen.m4 \
 	$(top_srcdir)/m4/mbrtowc.m4 $(top_srcdir)/m4/mbsinit.m4 \
 	$(top_srcdir)/m4/mbsrtowcs.m4 $(top_srcdir)/m4/mbstate_t.m4 \
-	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/md5.m4 \
-	$(top_srcdir)/m4/memcasecmp.m4 $(top_srcdir)/m4/memchr.m4 \
-	$(top_srcdir)/m4/memcmp.m4 $(top_srcdir)/m4/memcoll.m4 \
-	$(top_srcdir)/m4/memcpy.m4 $(top_srcdir)/m4/memmove.m4 \
-	$(top_srcdir)/m4/mempcpy.m4 $(top_srcdir)/m4/memrchr.m4 \
-	$(top_srcdir)/m4/memset.m4 $(top_srcdir)/m4/memxfrm.m4 \
-	$(top_srcdir)/m4/mgetgroups.m4 $(top_srcdir)/m4/mkancesdirs.m4 \
-	$(top_srcdir)/m4/mkdir-p.m4 $(top_srcdir)/m4/mkdir-slash.m4 \
-	$(top_srcdir)/m4/mkstemp.m4 $(top_srcdir)/m4/mktime.m4 \
-	$(top_srcdir)/m4/mmap-anon.m4 $(top_srcdir)/m4/mode_t.m4 \
-	$(top_srcdir)/m4/modechange.m4 $(top_srcdir)/m4/mountlist.m4 \
-	$(top_srcdir)/m4/mpsort.m4 $(top_srcdir)/m4/multiarch.m4 \
-	$(top_srcdir)/m4/nanosleep.m4 $(top_srcdir)/m4/netdb_h.m4 \
-	$(top_srcdir)/m4/netinet_in_h.m4 $(top_srcdir)/m4/nls.m4 \
-	$(top_srcdir)/m4/nocrash.m4 $(top_srcdir)/m4/open.m4 \
-	$(top_srcdir)/m4/openat.m4 $(top_srcdir)/m4/pathmax.m4 \
-	$(top_srcdir)/m4/perl.m4 $(top_srcdir)/m4/perror.m4 \
-	$(top_srcdir)/m4/physmem.m4 $(top_srcdir)/m4/po.m4 \
-	$(top_srcdir)/m4/posix-shell.m4 $(top_srcdir)/m4/posixtm.m4 \
-	$(top_srcdir)/m4/posixver.m4 $(top_srcdir)/m4/prereq.m4 \
-	$(top_srcdir)/m4/printf-frexp.m4 \
+	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/mcore.m4 \
+	$(top_srcdir)/m4/md5.m4 $(top_srcdir)/m4/memcasecmp.m4 \
+	$(top_srcdir)/m4/memchr.m4 $(top_srcdir)/m4/memcmp.m4 \
+	$(top_srcdir)/m4/memcoll.m4 $(top_srcdir)/m4/memcpy.m4 \
+	$(top_srcdir)/m4/memmove.m4 $(top_srcdir)/m4/mempcpy.m4 \
+	$(top_srcdir)/m4/memrchr.m4 $(top_srcdir)/m4/memset.m4 \
+	$(top_srcdir)/m4/memxfrm.m4 $(top_srcdir)/m4/mgetgroups.m4 \
+	$(top_srcdir)/m4/mkancesdirs.m4 $(top_srcdir)/m4/mkdir-p.m4 \
+	$(top_srcdir)/m4/mkdir-slash.m4 $(top_srcdir)/m4/mkstemp.m4 \
+	$(top_srcdir)/m4/mktime.m4 $(top_srcdir)/m4/mmap-anon.m4 \
+	$(top_srcdir)/m4/mode_t.m4 $(top_srcdir)/m4/modechange.m4 \
+	$(top_srcdir)/m4/mountlist.m4 $(top_srcdir)/m4/mpsort.m4 \
+	$(top_srcdir)/m4/multiarch.m4 $(top_srcdir)/m4/nanosleep.m4 \
+	$(top_srcdir)/m4/netdb_h.m4 $(top_srcdir)/m4/netinet_in_h.m4 \
+	$(top_srcdir)/m4/nls.m4 $(top_srcdir)/m4/nocrash.m4 \
+	$(top_srcdir)/m4/open.m4 $(top_srcdir)/m4/openat.m4 \
+	$(top_srcdir)/m4/pathmax.m4 $(top_srcdir)/m4/perl.m4 \
+	$(top_srcdir)/m4/perror.m4 $(top_srcdir)/m4/physmem.m4 \
+	$(top_srcdir)/m4/po.m4 $(top_srcdir)/m4/posix-shell.m4 \
+	$(top_srcdir)/m4/posixtm.m4 $(top_srcdir)/m4/posixver.m4 \
+	$(top_srcdir)/m4/prereq.m4 $(top_srcdir)/m4/printf-frexp.m4 \
 	$(top_srcdir)/m4/printf-frexpl.m4 $(top_srcdir)/m4/printf.m4 \
 	$(top_srcdir)/m4/priv-set.m4 $(top_srcdir)/m4/progtest.m4 \
 	$(top_srcdir)/m4/putenv.m4 $(top_srcdir)/m4/quote.m4 \
@@ -810,6 +810,7 @@ NEXT_WCHAR_H = @NEXT_WCHAR_H@
 NEXT_WCTYPE_H = @NEXT_WCTYPE_H@
 NO_INSTALL_PROGS_DEFAULT = @NO_INSTALL_PROGS_DEFAULT@
 OBJEXT = @OBJEXT@
+OPENMP_CFLAGS = @OPENMP_CFLAGS@
 OPTIONAL_BIN_PROGS = @OPTIONAL_BIN_PROGS@
 OPTIONAL_PKGLIB_PROGS = @OPTIONAL_PKGLIB_PROGS@
 PACKAGE = @PACKAGE@
@@ -1144,7 +1145,7 @@ $(am__aclocal_m4_deps):
 #     (which will cause the Makefiles to be regenerated when you run `make');
 # (2) otherwise, pass the desired values on the `make' command line.
 $(RECURSIVE_TARGETS):
-	@failcom='exit 1'; \
+	@fail= failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
 	    *=* | --[!k]*);; \
@@ -1169,7 +1170,7 @@ $(RECURSIVE_TARGETS):
 	fi; test -z "$$fail"
 
 $(RECURSIVE_CLEAN_TARGETS):
-	@failcom='exit 1'; \
+	@fail= failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
 	    *=* | --[!k]*);; \
@@ -1336,7 +1337,8 @@ distdir: $(DISTFILES)
 	  top_distdir="$(top_distdir)" distdir="$(distdir)" \
 	  dist-hook
 	-test -n "$(am__skip_mode_fix)" \
-	|| find "$(distdir)" -type d ! -perm -777 -exec chmod a+rwx {} \; -o \
+	|| find "$(distdir)" -type d ! -perm -755 \
+		-exec chmod u+rwx,go+rx {} \; -o \
 	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
 	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
 	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
@@ -1380,17 +1382,17 @@ dist dist-all: distdir
 distcheck: dist
 	case '$(DIST_ARCHIVES)' in \
 	*.tar.gz*) \
-	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(am__untar) ;;\
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
 	*.tar.bz2*) \
-	  bunzip2 -c $(distdir).tar.bz2 | $(am__untar) ;;\
+	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
 	*.tar.lzma*) \
-	  unlzma -c $(distdir).tar.lzma | $(am__untar) ;;\
+	  lzma -dc $(distdir).tar.lzma | $(am__untar) ;;\
 	*.tar.xz*) \
 	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
 	*.tar.Z*) \
 	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
 	*.shar.gz*) \
-	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).shar.gz | unshar ;;\
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\
 	*.zip*) \
 	  unzip $(distdir).zip ;;\
 	esac
diff -rupN orig/aclocal.m4 new/aclocal.m4
--- orig/aclocal.m4	2009-09-10 22:56:36.000000000 -0700
+++ new/aclocal.m4	2012-10-08 13:50:50.316684142 -0700
@@ -1205,6 +1205,9 @@ m4_include([m4/mbsinit.m4])
 m4_include([m4/mbsrtowcs.m4])
 m4_include([m4/mbstate_t.m4])
 m4_include([m4/mbswidth.m4])
+# PZK >
+m4_include([m4/mcore.m4])
+# < PZK
 m4_include([m4/md5.m4])
 m4_include([m4/memcasecmp.m4])
 m4_include([m4/memchr.m4])
diff -rupN orig/configure new/configure
--- orig/configure	2009-09-10 22:56:40.000000000 -0700
+++ new/configure	2012-10-08 13:50:50.320685798 -0700
@@ -1,13 +1,13 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64.27-5b5d for GNU coreutils 7.6.
+# Generated by GNU Autoconf 2.67 for GNU coreutils 7.6.
 #
 # Report bugs to <bug-coreutils@gnu.org>.
 #
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation,
-# Inc.
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
+# Foundation, Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
@@ -319,7 +319,7 @@ $as_echo X"$as_dir" |
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
@@ -359,19 +359,19 @@ else
 fi # as_fn_arith
 
 
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
+# script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $1" >&2
+  $as_echo "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -529,10 +529,11 @@ as_tr_cpp="eval sed 'y%*$as_cr_letters%P
 as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
-exec 7<&0 </dev/null 6>&1
+test -n "$DJDIR" || exec 7<&0 </dev/null
+exec 6>&1
 
 # Name of the host.
-# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
 # so uname gets run too.
 ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
 
@@ -719,6 +720,7 @@ REPLACE_STRPTIME
 REPLACE_NANOSLEEP
 REPLACE_MKTIME
 REPLACE_LOCALTIME_R
+OPENMP_CFLAGS
 UNDEFINE_STRTOK_R
 REPLACE_STRTOK_R
 REPLACE_STRSIGNAL
@@ -1334,6 +1336,7 @@ enable_assert
 with_gnu_ld
 enable_rpath
 with_libiconv_prefix
+enable_openmp
 enable_largefile
 with_included_regex
 with_packager
@@ -1422,8 +1425,9 @@ do
   fi
 
   case $ac_option in
-  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *)	ac_optarg=yes ;;
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
   esac
 
   # Accept the important Cygnus configure options, so we can diagnose typos.
@@ -1468,7 +1472,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1494,7 +1498,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1698,7 +1702,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1714,7 +1718,7 @@ do
     ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1744,8 +1748,8 @@ do
   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
     x_libraries=$ac_optarg ;;
 
-  -*) as_fn_error "unrecognized option: \`$ac_option'
-Try \`$0 --help' for more information."
+  -*) as_fn_error $? "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information"
     ;;
 
   *=*)
@@ -1753,7 +1757,7 @@ Try \`$0 --help' for more information."
     # Reject names that are not valid shell variable names.
     case $ac_envvar in #(
       '' | [0-9]* | *[!_$as_cr_alnum]* )
-      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
+      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
     esac
     eval $ac_envvar=\$ac_optarg
     export $ac_envvar ;;
@@ -1771,13 +1775,13 @@ done
 
 if test -n "$ac_prev"; then
   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  as_fn_error "missing argument to $ac_option"
+  as_fn_error $? "missing argument to $ac_option"
 fi
 
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
     *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
@@ -1800,7 +1804,7 @@ do
     [\\/$]* | ?:[\\/]* )  continue;;
     NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
   esac
-  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
 done
 
 # There might be people who depend on the old broken behavior: `$host'
@@ -1814,8 +1818,8 @@ target=$target_alias
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used." >&2
+    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used" >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1830,9 +1834,9 @@ test "$silent" = yes && exec 6>/dev/null
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  as_fn_error "working directory cannot be determined"
+  as_fn_error $? "working directory cannot be determined"
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  as_fn_error "pwd does not report name of working directory"
+  as_fn_error $? "pwd does not report name of working directory"
 
 
 # Find the source files, if location was not specified.
@@ -1871,11 +1875,11 @@ else
 fi
 if test ! -r "$srcdir/$ac_unique_file"; then
   test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
 fi
 ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
 ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
 	pwd)`
 # When building in place, set srcdir=.
 if test "$ac_abs_confdir" = "$ac_pwd"; then
@@ -1915,7 +1919,7 @@ Configuration:
       --help=short        display options specific to this package
       --help=recursive    display the short help of all the included packages
   -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking...' messages
+  -q, --quiet, --silent   do not print \`checking ...' messages
       --cache-file=FILE   cache test results in FILE [disabled]
   -C, --config-cache      alias for \`--cache-file=config.cache'
   -n, --no-create         do not create output files
@@ -1986,6 +1990,7 @@ Optional Features:
   --disable-acl           do not support ACLs
   --disable-assert        turn off assertions
   --disable-rpath         do not hardcode runtime library paths
+  --disable-openmp        do not use OpenMP
   --disable-largefile     omit support for large files
   --disable-xattr         do not support extended attributes
   --disable-libcap        disable libcap support
@@ -2023,7 +2028,7 @@ Some influential environment variables:
   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
               nonstandard directory <lib dir>
   LIBS        libraries to pass to the linker, e.g. -l<library>
-  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
+  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
               you have headers in a nonstandard directory <include dir>
   CPP         C preprocessor
   YACC        The `Yet Another C Compiler' implementation to use. Defaults to
@@ -2105,9 +2110,9 @@ test -n "$ac_init_help" && exit $ac_stat
 if $ac_init_version; then
   cat <<\_ACEOF
 GNU coreutils configure 7.6
-generated by GNU Autoconf 2.64.27-5b5d
+generated by GNU Autoconf 2.67
 
-Copyright (C) 2009 Free Software Foundation, Inc.
+Copyright (C) 2010 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -2152,7 +2157,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 	ac_retval=1
 fi
   eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
+  as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_compile
 
@@ -2177,7 +2182,7 @@ $as_echo "$ac_try_echo"; } >&5
     mv -f conftest.er1 conftest.err
   fi
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } >/dev/null && {
+  test $ac_status = 0; } > conftest.i && {
 	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        }; then :
@@ -2189,7 +2194,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
     ac_retval=1
 fi
   eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
+  as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_cpp
 
@@ -2201,10 +2206,10 @@ fi
 ac_fn_c_check_header_mongrel ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  if eval "test \"\${$3+set}\"" = set; then :
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 fi
 eval ac_res=\$$3
@@ -2240,7 +2245,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   ac_header_preproc=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
 $as_echo "$ac_header_preproc" >&6; }
 
@@ -2263,17 +2268,15 @@ $as_echo "$as_me: WARNING: $2: see the A
 $as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
     { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
 $as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-( cat <<\_ASBOX
-## ------------------------------------ ##
+( $as_echo "## ------------------------------------ ##
 ## Report this to bug-coreutils@gnu.org ##
-## ------------------------------------ ##
-_ASBOX
+## ------------------------------------ ##"
      ) | sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   eval "$3=\$ac_header_compiler"
@@ -2324,7 +2327,7 @@ sed 's/^/| /' conftest.$ac_ext >&5
 fi
   rm -rf conftest.dSYM conftest_ipa8_conftest.oo
   eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
+  as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_run
 
@@ -2337,7 +2340,7 @@ ac_fn_c_check_header_compile ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -2401,7 +2404,7 @@ fi
   # left behind by Apple's compiler.  We do this before executing the actions.
   rm -rf conftest.dSYM conftest_ipa8_conftest.oo
   eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
+  as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_link
 
@@ -2413,7 +2416,7 @@ ac_fn_c_check_func ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -2481,7 +2484,7 @@ ac_fn_c_check_type ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
 $as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   eval "$3=no"
@@ -2526,15 +2529,18 @@ $as_echo "$ac_res" >&6; }
 
 } # ac_fn_c_check_type
 
-# ac_fn_c_check_decl LINENO SYMBOL VAR
-# ------------------------------------
-# Tests whether SYMBOL is declared, setting cache variable VAR accordingly.
+# ac_fn_c_check_decl LINENO SYMBOL VAR INCLUDES
+# ---------------------------------------------
+# Tests whether SYMBOL is declared in INCLUDES, setting cache variable VAR
+# accordingly.
 ac_fn_c_check_decl ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $2 is declared" >&5
-$as_echo_n "checking whether $2 is declared... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  as_decl_name=`echo $2|sed 's/ *(.*//'`
+  as_decl_use=`echo $2|sed -e 's/(/((/' -e 's/)/) 0&/' -e 's/,/) 0& (/g'`
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $as_decl_name is declared" >&5
+$as_echo_n "checking whether $as_decl_name is declared... " >&6; }
+if eval "test \"\${$3+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -2543,8 +2549,12 @@ $4
 int
 main ()
 {
-#ifndef $2
-  (void) $2;
+#ifndef $as_decl_name
+#ifdef __cplusplus
+  (void) $as_decl_use;
+#else
+  (void) $as_decl_name;
+#endif
 #endif
 
   ;
@@ -2739,7 +2749,7 @@ rm -f conftest.val
 
   fi
   eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
+  as_fn_set_status $ac_retval
 
 } # ac_fn_c_compute_int
 
@@ -2752,7 +2762,7 @@ ac_fn_c_check_member ()
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2.$3" >&5
 $as_echo_n "checking for $2.$3... " >&6; }
-if { as_var=$4; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$4+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -2804,7 +2814,7 @@ This file contains any messages produced
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by GNU coreutils $as_me 7.6, which was
-generated by GNU Autoconf 2.64.27-5b5d.  Invocation command line was
+generated by GNU Autoconf 2.67.  Invocation command line was
 
   $ $0 $@
 
@@ -2914,11 +2924,9 @@ trap 'exit_status=$?
   {
     echo
 
-    cat <<\_ASBOX
-## ---------------- ##
+    $as_echo "## ---------------- ##
 ## Cache variables. ##
-## ---------------- ##
-_ASBOX
+## ---------------- ##"
     echo
     # The following way of writing the cache mishandles newlines in values,
 (
@@ -2952,11 +2960,9 @@ $as_echo "$as_me: WARNING: cache variabl
 )
     echo
 
-    cat <<\_ASBOX
-## ----------------- ##
+    $as_echo "## ----------------- ##
 ## Output variables. ##
-## ----------------- ##
-_ASBOX
+## ----------------- ##"
     echo
     for ac_var in $ac_subst_vars
     do
@@ -2969,11 +2975,9 @@ _ASBOX
     echo
 
     if test -n "$ac_subst_files"; then
-      cat <<\_ASBOX
-## ------------------- ##
+      $as_echo "## ------------------- ##
 ## File substitutions. ##
-## ------------------- ##
-_ASBOX
+## ------------------- ##"
       echo
       for ac_var in $ac_subst_files
       do
@@ -2987,11 +2991,9 @@ _ASBOX
     fi
 
     if test -s confdefs.h; then
-      cat <<\_ASBOX
-## ----------- ##
+      $as_echo "## ----------- ##
 ## confdefs.h. ##
-## ----------- ##
-_ASBOX
+## ----------- ##"
       echo
       cat confdefs.h
       echo
@@ -3046,7 +3048,12 @@ _ACEOF
 ac_site_file1=NONE
 ac_site_file2=NONE
 if test -n "$CONFIG_SITE"; then
-  ac_site_file1=$CONFIG_SITE
+  # We do not want a PATH search for config.site.
+  case $CONFIG_SITE in #((
+    -*)  ac_site_file1=./$CONFIG_SITE;;
+    */*) ac_site_file1=$CONFIG_SITE;;
+    *)   ac_site_file1=./$CONFIG_SITE;;
+  esac
 elif test "x$prefix" != xNONE; then
   ac_site_file1=$prefix/share/config.site
   ac_site_file2=$prefix/etc/config.site
@@ -3057,18 +3064,22 @@ fi
 for ac_site_file in "$ac_site_file1" "$ac_site_file2"
 do
   test "x$ac_site_file" = xNONE && continue
-  if test -r "$ac_site_file"; then
+  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
 $as_echo "$as_me: loading site script $ac_site_file" >&6;}
     sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file"
+    . "$ac_site_file" \
+      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See \`config.log' for more details" "$LINENO" 5; }
   fi
 done
 
 if test -r "$cache_file"; then
-  # Some versions of bash will fail to source /dev/null (special
-  # files actually), so we avoid doing that.
-  if test -f "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special files
+  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
+  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
 $as_echo "$as_me: loading cache $cache_file" >&6;}
     case $cache_file in
@@ -3268,7 +3279,7 @@ if $ac_cache_corrupted; then
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
 $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
 fi
 ## -------------------- ##
 ## Main body of script. ##
@@ -3286,16 +3297,22 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 ac_aux_dir=
 for ac_dir in build-aux "$srcdir"/build-aux; do
-  for ac_t in install-sh install.sh shtool; do
-    if test -f "$ac_dir/$ac_t"; then
-      ac_aux_dir=$ac_dir
-      ac_install_sh="$ac_aux_dir/$ac_t -c"
-      break 2
-    fi
-  done
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
 done
 if test -z "$ac_aux_dir"; then
-  as_fn_error "cannot find install-sh, install.sh, or shtool in build-aux \"$srcdir\"/build-aux" "$LINENO" 5
+  as_fn_error $? "cannot find install-sh, install.sh, or shtool in build-aux \"$srcdir\"/build-aux" "$LINENO" 5
 fi
 
 # These three variables are undocumented and unsupported,
@@ -3413,11 +3430,11 @@ am_lf='
 '
 case `pwd` in
   *[\\\"\#\$\&\'\`$am_lf]*)
-    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
+    as_fn_error $? "unsafe absolute working directory name" "$LINENO" 5;;
 esac
 case $srcdir in
   *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    as_fn_error "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
+    as_fn_error $? "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
 esac
 
 # Do `set' in a subshell so we don't clobber the current shell's
@@ -3441,7 +3458,7 @@ if (
 	# if, for instance, CONFIG_SHELL is bash and it inherits a
 	# broken ls alias from the environment.  This has actually
 	# happened.  Such a system could not be considered "sane".
-	as_fn_error "ls -t appears to fail.  Make sure there is not a broken
+	as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
   alias in your environment" "$LINENO" 5
      fi
      if test "$2" = conftest.file || test $am_try -eq 2; then
@@ -3456,7 +3473,7 @@ then
    # Ok.
    :
 else
-   as_fn_error "newly created file is older than distributed files!
+   as_fn_error $? "newly created file is older than distributed files!
 Check your system clock" "$LINENO" 5
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
@@ -3628,6 +3645,7 @@ IFS=$as_save_IFS
 
 fi
 
+  test -d ./--version && rmdir ./--version
   if test "${ac_cv_path_mkdir+set}" = set; then
     MKDIR_P="$ac_cv_path_mkdir -p"
   else
@@ -3635,7 +3653,6 @@ fi
     # value for MKDIR_P within a source directory, because that will
     # break other packages using the cache if that directory is
     # removed, or if the value is a relative name.
-    test -d ./--version && rmdir ./--version
     MKDIR_P="$ac_install_sh -d"
   fi
 fi
@@ -3694,7 +3711,7 @@ done
 $as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
 set x ${MAKE-make}
 ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat >conftest.make <<\_ACEOF
@@ -3702,7 +3719,7 @@ SHELL = /bin/sh
 all:
 	@echo '@@@%%%=$(MAKE)=@@@%%%'
 _ACEOF
-# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+# GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
 case `${MAKE-make} -f conftest.make 2>/dev/null` in
   *@@@%%%=?*=@@@%%%*)
     eval ac_cv_prog_make_${ac_make}_set=yes;;
@@ -3736,7 +3753,7 @@ if test "`cd $srcdir && pwd`" != "`pwd`"
   am__isrc=' -I$(srcdir)'
   # test to see if srcdir already configured
   if test -f $srcdir/config.status; then
-    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
+    as_fn_error $? "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
   fi
 fi
 
@@ -4167,8 +4184,8 @@ fi
 
 test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "no acceptable C compiler found in \$PATH
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See \`config.log' for more details" "$LINENO" 5; }
 
 # Provide some information about the compiler.
 $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
@@ -4189,8 +4206,8 @@ $as_echo "$ac_try_echo"; } >&5
 ... rest of stderr output deleted ...
          10q' conftest.err >conftest.er1
     cat conftest.er1 >&5
-    rm -f conftest.er1 conftest.err
   fi
+  rm -f conftest.er1 conftest.err
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
 done
@@ -4282,9 +4299,8 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "C compiler cannot create executables
-See \`config.log' for more details." "$LINENO" 5; }; }
+as_fn_error 77 "C compiler cannot create executables
+See \`config.log' for more details" "$LINENO" 5; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
@@ -4326,10 +4342,10 @@ done
 else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details" "$LINENO" 5; }
 fi
-rm -f conftest$ac_cv_exeext
+rm -f conftest conftest$ac_cv_exeext
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
 $as_echo "$ac_cv_exeext" >&6; }
 
@@ -4384,9 +4400,9 @@ $as_echo "$ac_try_echo"; } >&5
     else
 	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot run C compiled programs.
+as_fn_error $? "cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5; }
     fi
   fi
 fi
@@ -4437,8 +4453,8 @@ sed 's/^/| /' conftest.$ac_ext >&5
 
 { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details" "$LINENO" 5; }
 fi
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
@@ -5087,7 +5103,7 @@ $as_echo_n "checking whether cc understa
 fi
 set dummy $CC; ac_cc=`$as_echo "$2" |
 		      sed 's/[^a-zA-Z0-9_]/_/g;s/^[0-9]/_/'`
-if { as_var=ac_cv_prog_cc_${ac_cc}_c_o; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${ac_cv_prog_cc_${ac_cc}_c_o+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -5246,7 +5262,7 @@ else
   # Broken: fails on valid input.
 continue
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether nonexistent headers
   # can be detected and how.
@@ -5262,11 +5278,11 @@ else
 ac_preproc_ok=:
 break
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
 done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.i conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then :
   break
 fi
@@ -5305,7 +5321,7 @@ else
   # Broken: fails on valid input.
 continue
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether nonexistent headers
   # can be detected and how.
@@ -5321,18 +5337,18 @@ else
 ac_preproc_ok=:
 break
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 
 done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.i conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then :
 
 else
   { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." "$LINENO" 5; }
+as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details" "$LINENO" 5; }
 fi
 
 ac_ext=c
@@ -5394,7 +5410,7 @@ esac
   done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_GREP"; then
-    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
   ac_cv_path_GREP=$GREP
@@ -5460,7 +5476,7 @@ esac
   done
 IFS=$as_save_IFS
   if test -z "$ac_cv_path_EGREP"; then
-    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
   ac_cv_path_EGREP=$EGREP
@@ -5620,7 +5636,7 @@ fi
 
 # Make sure we can run config.sub.
 $SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
 $as_echo_n "checking build system type... " >&6; }
@@ -5631,16 +5647,16 @@ else
 test "x$ac_build_alias" = x &&
   ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
 test "x$ac_build_alias" = x &&
-  as_fn_error "cannot guess build type; you must specify one" "$LINENO" 5
+  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
 ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  as_fn_error "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
 
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
 $as_echo "$ac_cv_build" >&6; }
 case $ac_cv_build in
 *-*-*) ;;
-*) as_fn_error "invalid value of canonical build" "$LINENO" 5;;
+*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
 esac
 build=$ac_cv_build
 ac_save_IFS=$IFS; IFS='-'
@@ -5665,7 +5681,7 @@ else
   ac_cv_host=$ac_cv_build
 else
   ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    as_fn_error "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
 fi
 
 fi
@@ -5673,7 +5689,7 @@ fi
 $as_echo "$ac_cv_host" >&6; }
 case $ac_cv_host in
 *-*-*) ;;
-*) as_fn_error "invalid value of canonical host" "$LINENO" 5;;
+*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
 esac
 host=$ac_cv_host
 ac_save_IFS=$IFS; IFS='-'
@@ -5808,8 +5824,7 @@ do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
 "
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -6212,8 +6227,7 @@ if test $ac_cv_os_cray = yes; then
   for ac_func in _getb67 GETB67 getb67; do
     as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
 
 cat >>confdefs.h <<_ACEOF
 #define CRAY_STACKSEG_END $ac_func
@@ -6290,8 +6304,7 @@ do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
 "
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -6577,8 +6590,7 @@ fi
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -7480,7 +7492,7 @@ $as_echo "#define AC_APPLE_UNIVERSAL_BUI
 
      ;; #(
    *)
-     as_fn_error "unknown endianness
+     as_fn_error $? "unknown endianness
  presetting ac_cv_c_bigendian=no (or yes) will help" "$LINENO" 5 ;;
  esac
 
@@ -8434,8 +8446,8 @@ $as_echo "$gl_cv_var_stdin_large_offset"
 
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether lstat dereferences a symlink specified with a trailing slash" >&5
-$as_echo_n "checking whether lstat dereferences a symlink specified with a trailing slash... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether lstat correctly handles trailing slash" >&5
+$as_echo_n "checking whether lstat correctly handles trailing slash... " >&6; }
 if test "${ac_cv_func_lstat_dereferences_slashed_symlink+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
@@ -8452,7 +8464,7 @@ int
 main ()
 {
 struct stat sbuf;
-     /* Linux will dereference the symlink and fail.
+     /* Linux will dereference the symlink and fail, as required by POSIX.
 	That is better in the sense that it means we will not
 	have to compile and use the lstat wrapper.  */
      return lstat ("conftest.sym/", &sbuf) == 0;
@@ -8487,7 +8499,7 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 
-if test $ac_cv_func_lstat_dereferences_slashed_symlink = no; then
+if test "x$ac_cv_func_lstat_dereferences_slashed_symlink" = xno; then
 
 
 
@@ -10249,7 +10261,7 @@ else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
-test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
+test -z "$LD" && as_fn_error $? "no acceptable ld found in \$PATH" "$LINENO" 5
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
 $as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
 if test "${acl_cv_prog_gnu_ld+set}" = set; then :
@@ -11318,8 +11330,7 @@ $as_echo "$gl_cv_header_working_stdint_h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -11351,7 +11362,7 @@ done
   for gltype in ptrdiff_t size_t ; do
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for bit size of $gltype" >&5
 $as_echo_n "checking for bit size of $gltype... " >&6; }
-if { as_var=gl_cv_bitsizeof_${gltype}; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${gl_cv_bitsizeof_${gltype}+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "sizeof ($gltype) * CHAR_BIT" "result"        "
@@ -11396,7 +11407,7 @@ _ACEOF
   for gltype in sig_atomic_t wchar_t wint_t ; do
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for bit size of $gltype" >&5
 $as_echo_n "checking for bit size of $gltype... " >&6; }
-if { as_var=gl_cv_bitsizeof_${gltype}; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${gl_cv_bitsizeof_${gltype}+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "sizeof ($gltype) * CHAR_BIT" "result"        "
@@ -11440,7 +11451,7 @@ _ACEOF
   for gltype in sig_atomic_t wchar_t wint_t ; do
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $gltype is signed" >&5
 $as_echo_n "checking whether $gltype is signed... " >&6; }
-if { as_var=gl_cv_type_${gltype}_signed; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${gl_cv_type_${gltype}_signed+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -11499,7 +11510,7 @@ _ACEOF
   for gltype in ptrdiff_t size_t ; do
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $gltype integer literal suffix" >&5
 $as_echo_n "checking for $gltype integer literal suffix... " >&6; }
-if { as_var=gl_cv_type_${gltype}_suffix; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${gl_cv_type_${gltype}_suffix+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   eval gl_cv_type_${gltype}_suffix=no
@@ -11571,7 +11582,7 @@ _ACEOF
   for gltype in sig_atomic_t wchar_t wint_t ; do
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $gltype integer literal suffix" >&5
 $as_echo_n "checking for $gltype integer literal suffix... " >&6; }
-if { as_var=gl_cv_type_${gltype}_suffix; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${gl_cv_type_${gltype}_suffix+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   eval gl_cv_type_${gltype}_suffix=no
@@ -12777,6 +12788,110 @@ $as_echo "#define MBRTOWC_NUL_RETVAL_BUG
 
 
 
+    for ac_header in gnutls/gnutls.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "gnutls/gnutls.h" "ac_cv_header_gnutls_gnutls_h" "$ac_includes_default"
+if test "x$ac_cv_header_gnutls_gnutls_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GNUTLS_GNUTLS_H 1
+_ACEOF
+
+fi
+
+done
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gnutls_global_init in -lgnutls" >&5
+$as_echo_n "checking for gnutls_global_init in -lgnutls... " >&6; }
+if test "${ac_cv_lib_gnutls_gnutls_global_init+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgnutls  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gnutls_global_init ();
+int
+main ()
+{
+return gnutls_global_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_gnutls_gnutls_global_init=yes
+else
+  ac_cv_lib_gnutls_gnutls_global_init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gnutls_gnutls_global_init" >&5
+$as_echo "$ac_cv_lib_gnutls_gnutls_global_init" >&6; }
+if test "x$ac_cv_lib_gnutls_gnutls_global_init" = x""yes; then :
+
+        LIBS="$LIBS -Wl,-Bstatic -lgnutls -Wl,-Bdynamic"
+
+$as_echo "#define HAVE_LIBGNUTLS 1" >>confdefs.h
+
+
+fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for zlibVersion in -lz" >&5
+$as_echo_n "checking for zlibVersion in -lz... " >&6; }
+if test "${ac_cv_lib_z_zlibVersion+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lz  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char zlibVersion ();
+int
+main ()
+{
+return zlibVersion ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_z_zlibVersion=yes
+else
+  ac_cv_lib_z_zlibVersion=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_zlibVersion" >&5
+$as_echo "$ac_cv_lib_z_zlibVersion" >&6; }
+if test "x$ac_cv_lib_z_zlibVersion" = x""yes; then :
+
+        LIBS="$LIBS -Wl,-Bstatic -lz -Wl,-Bdynamic"
+
+$as_echo "#define HAVE_LIBZ 1" >>confdefs.h
+
+
+fi
+
+
+
 
 
 
@@ -14444,8 +14559,7 @@ _ACEOF
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -16050,8 +16164,7 @@ if test "$ac_res" != no; then :
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -16337,7 +16450,7 @@ done
       LIBS=$ac_save_LIBS
     fi
     if test "x$enable_acl$use_acl" = "xyes0"; then
-      as_fn_error "ACLs enabled but support not detected" "$LINENO" 5
+      as_fn_error $? "ACLs enabled but support not detected" "$LINENO" 5
     fi
   fi
 
@@ -16956,8 +17069,7 @@ fi
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -18553,7 +18665,7 @@ $as_echo "$gl_cv_next_float_h" >&6; }
   gl_fnmatch_cache_var="gl_cv_func_fnmatch_${gl_fnmatch_required_lowercase}"
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for working $gl_fnmatch_required fnmatch" >&5
 $as_echo_n "checking for working $gl_fnmatch_required fnmatch... " >&6; }
-if { as_var=$gl_fnmatch_cache_var; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$gl_fnmatch_cache_var+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
                            if test $gl_fnmatch_required = GNU; then
@@ -19709,7 +19821,7 @@ $as_echo "#define STAT_READ_FILSYS 1" >>
 
      ac_fsusage_space=yes
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 fi
 
 if test $ac_fsusage_space = yes; then :
@@ -19735,8 +19847,7 @@ fi
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -19898,12 +20009,12 @@ done
         if test x"$SKIP_FTRUNCATE_CHECK" != xyes; then
           { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "Your system lacks the ftruncate function.
+as_fn_error $? "Your system lacks the ftruncate function.
 	      Please report this, along with the output of \"uname -a\", to the
 	      bug-coreutils@gnu.org mailing list.  To continue past this point,
 	      rerun configure with SKIP_FTRUNCATE_CHECK=yes.
 	      E.g., ./configure SKIP_FTRUNCATE_CHECK=yes
-See \`config.log' for more details." "$LINENO" 5; }
+See \`config.log' for more details" "$LINENO" 5; }
         fi
     esac
   fi
@@ -19976,8 +20087,7 @@ See \`config.log' for more details." "$L
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -20961,8 +21071,7 @@ done
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -21391,8 +21500,7 @@ done
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -21434,7 +21542,7 @@ gl_have_func=no # yes means we've found
 
 # Make sure getloadavg.c is where it belongs, at configure-time.
 test -f "$srcdir/lib/getloadavg.c" ||
-  as_fn_error "$srcdir/lib/getloadavg.c is missing" "$LINENO" 5
+  as_fn_error $? "$srcdir/lib/getloadavg.c is missing" "$LINENO" 5
 
 gl_save_LIBS=$LIBS
 
@@ -25322,8 +25430,8 @@ $as_echo "#define LSEEK_PIPE_BROKEN 1" >
 
 
   if test $ac_cv_func_lstat = yes; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether lstat dereferences a symlink specified with a trailing slash" >&5
-$as_echo_n "checking whether lstat dereferences a symlink specified with a trailing slash... " >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether lstat correctly handles trailing slash" >&5
+$as_echo_n "checking whether lstat correctly handles trailing slash... " >&6; }
 if test "${ac_cv_func_lstat_dereferences_slashed_symlink+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
@@ -25340,7 +25448,7 @@ int
 main ()
 {
 struct stat sbuf;
-     /* Linux will dereference the symlink and fail.
+     /* Linux will dereference the symlink and fail, as required by POSIX.
 	That is better in the sense that it means we will not
 	have to compile and use the lstat wrapper.  */
      return lstat ("conftest.sym/", &sbuf) == 0;
@@ -25375,7 +25483,7 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 
-if test $ac_cv_func_lstat_dereferences_slashed_symlink = no; then
+if test "x$ac_cv_func_lstat_dereferences_slashed_symlink" = xno; then
 
 
 
@@ -26630,6 +26738,440 @@ $as_echo "#define mbstate_t int" >>confd
 
   :
 
+# PZK >
+
+    for ac_header in gcrypt.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "gcrypt.h" "ac_cv_header_gcrypt_h" "$ac_includes_default"
+if test "x$ac_cv_header_gcrypt_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GCRYPT_H 1
+_ACEOF
+
+fi
+
+done
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gcry_md_open in -lgcrypt" >&5
+$as_echo_n "checking for gcry_md_open in -lgcrypt... " >&6; }
+if test "${ac_cv_lib_gcrypt_gcry_md_open+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgcrypt  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gcry_md_open ();
+int
+main ()
+{
+return gcry_md_open ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_gcrypt_gcry_md_open=yes
+else
+  ac_cv_lib_gcrypt_gcry_md_open=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gcrypt_gcry_md_open" >&5
+$as_echo "$ac_cv_lib_gcrypt_gcry_md_open" >&6; }
+if test "x$ac_cv_lib_gcrypt_gcry_md_open" = x""yes; then :
+
+        LIBS="$LIBS -Wl,-Bstatic -lgcrypt -Wl,-Bdynamic"
+
+$as_echo "#define HAVE_LIBGCRYPT 1" >>confdefs.h
+
+
+fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gpg_err_init in -lgpg-error" >&5
+$as_echo_n "checking for gpg_err_init in -lgpg-error... " >&6; }
+if test "${ac_cv_lib_gpg_error_gpg_err_init+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgpg-error  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gpg_err_init ();
+int
+main ()
+{
+return gpg_err_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_gpg_error_gpg_err_init=yes
+else
+  ac_cv_lib_gpg_error_gpg_err_init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gpg_error_gpg_err_init" >&5
+$as_echo "$ac_cv_lib_gpg_error_gpg_err_init" >&6; }
+if test "x$ac_cv_lib_gpg_error_gpg_err_init" = x""yes; then :
+
+        LIBS="$LIBS -Wl,-Bstatic -lgpg-error -Wl,-Bdynamic"
+
+$as_echo "#define HAVE_LIBGPG_ERROR 1" >>confdefs.h
+
+
+fi
+
+
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for gnutls_extra_check_version in -lgnutls-extra" >&5
+$as_echo_n "checking for gnutls_extra_check_version in -lgnutls-extra... " >&6; }
+if test "${ac_cv_lib_gnutls_extra_gnutls_extra_check_version+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgnutls-extra  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gnutls_extra_check_version ();
+int
+main ()
+{
+return gnutls_extra_check_version ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_gnutls_extra_gnutls_extra_check_version=yes
+else
+  ac_cv_lib_gnutls_extra_gnutls_extra_check_version=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gnutls_extra_gnutls_extra_check_version" >&5
+$as_echo "$ac_cv_lib_gnutls_extra_gnutls_extra_check_version" >&6; }
+if test "x$ac_cv_lib_gnutls_extra_gnutls_extra_check_version" = x""yes; then :
+
+        LIBS="$LIBS -Wl,-Bstatic -lgnutls-extra -Wl,-Bdynamic"
+
+$as_echo "#define HAVE_LIBGNUTLS_EXTRA 1" >>confdefs.h
+
+
+fi
+
+
+
+
+    LIBS="$LIBS -Wl,--no-as-needed"
+
+  OPENMP_CFLAGS=
+  # Check whether --enable-openmp was given.
+if test "${enable_openmp+set}" = set; then :
+  enableval=$enable_openmp;
+fi
+
+  if test "$enable_openmp" != no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to support OpenMP" >&5
+$as_echo_n "checking for $CC option to support OpenMP... " >&6; }
+if test "${ac_cv_prog_c_openmp+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifndef _OPENMP
+ choke me
+#endif
+#include <omp.h>
+int main () { return omp_get_num_threads (); }
+
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_prog_c_openmp='none needed'
+else
+  ac_cv_prog_c_openmp='unsupported'
+	  	  	  	  	  	  	  	  	  	  	  	  	  for ac_option in -fopenmp -xopenmp -openmp -mp -omp -qsmp=omp; do
+	    ac_save_CFLAGS=$CFLAGS
+	    CFLAGS="$CFLAGS $ac_option"
+	    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#ifndef _OPENMP
+ choke me
+#endif
+#include <omp.h>
+int main () { return omp_get_num_threads (); }
+
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_prog_c_openmp=$ac_option
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+	    CFLAGS=$ac_save_CFLAGS
+	    if test "$ac_cv_prog_c_openmp" != unsupported; then
+	      break
+	    fi
+	  done
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_c_openmp" >&5
+$as_echo "$ac_cv_prog_c_openmp" >&6; }
+    case $ac_cv_prog_c_openmp in #(
+      "none needed" | unsupported)
+	;; #(
+      *)
+	OPENMP_CFLAGS=$ac_cv_prog_c_openmp ;;
+    esac
+  fi
+
+
+
+
+    for ac_header in lustre/liblustreapi.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "lustre/liblustreapi.h" "ac_cv_header_lustre_liblustreapi_h" "$ac_includes_default"
+if test "x$ac_cv_header_lustre_liblustreapi_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LUSTRE_LIBLUSTREAPI_H 1
+_ACEOF
+
+fi
+
+done
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for llapi_file_get_stripe in -llustreapi" >&5
+$as_echo_n "checking for llapi_file_get_stripe in -llustreapi... " >&6; }
+if test "${ac_cv_lib_lustreapi_llapi_file_get_stripe+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-llustreapi  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char llapi_file_get_stripe ();
+int
+main ()
+{
+return llapi_file_get_stripe ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_lustreapi_llapi_file_get_stripe=yes
+else
+  ac_cv_lib_lustreapi_llapi_file_get_stripe=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_lustreapi_llapi_file_get_stripe" >&5
+$as_echo "$ac_cv_lib_lustreapi_llapi_file_get_stripe" >&6; }
+if test "x$ac_cv_lib_lustreapi_llapi_file_get_stripe" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBLUSTREAPI 1
+_ACEOF
+
+  LIBS="-llustreapi $LIBS"
+
+fi
+
+
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pow in -lm" >&5
+$as_echo_n "checking for pow in -lm... " >&6; }
+if test "${ac_cv_lib_m_pow+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lm  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pow ();
+int
+main ()
+{
+return pow ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_m_pow=yes
+else
+  ac_cv_lib_m_pow=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_m_pow" >&5
+$as_echo "$ac_cv_lib_m_pow" >&6; }
+if test "x$ac_cv_lib_m_pow" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBM 1
+_ACEOF
+
+  LIBS="-lm $LIBS"
+
+fi
+
+
+
+    for ac_header in mpi.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "mpi.h" "ac_cv_header_mpi_h" "$ac_includes_default"
+if test "x$ac_cv_header_mpi_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_MPI_H 1
+_ACEOF
+
+fi
+
+done
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for MPI_Init in -lmpi" >&5
+$as_echo_n "checking for MPI_Init in -lmpi... " >&6; }
+if test "${ac_cv_lib_mpi_MPI_Init+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lmpi  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char MPI_Init ();
+int
+main ()
+{
+return MPI_Init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_mpi_MPI_Init=yes
+else
+  ac_cv_lib_mpi_MPI_Init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_mpi_MPI_Init" >&5
+$as_echo "$ac_cv_lib_mpi_MPI_Init" >&6; }
+if test "x$ac_cv_lib_mpi_MPI_Init" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBMPI 1
+_ACEOF
+
+  LIBS="-lmpi $LIBS"
+
+fi
+
+
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for clock_gettime in -lrt" >&5
+$as_echo_n "checking for clock_gettime in -lrt... " >&6; }
+if test "${ac_cv_lib_rt_clock_gettime+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrt  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char clock_gettime ();
+int
+main ()
+{
+return clock_gettime ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_rt_clock_gettime=yes
+else
+  ac_cv_lib_rt_clock_gettime=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_rt_clock_gettime" >&5
+$as_echo "$ac_cv_lib_rt_clock_gettime" >&6; }
+if test "x$ac_cv_lib_rt_clock_gettime" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBRT 1
+_ACEOF
+
+  LIBS="-lrt $LIBS"
+
+fi
+
+
+# < PZK
 
 
 
@@ -27430,8 +27972,7 @@ for ac_func in listmntent getmntinfo
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -27478,8 +28019,7 @@ for ac_header in mntent.h sys/fs_types.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -27654,7 +28194,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   fu_cv_sys_mounted_vmount=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 fi
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $fu_cv_sys_mounted_vmount" >&5
@@ -27838,7 +28378,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   fu_cv_sys_mounted_fread_fstyp=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 fi
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $fu_cv_sys_mounted_fread_fstyp" >&5
@@ -27940,7 +28480,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   fu_cv_sys_mounted_getmnt=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 fi
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $fu_cv_sys_mounted_getmnt" >&5
@@ -27959,8 +28499,7 @@ if test -z "$ac_list_mounted_fs"; then
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -28015,7 +28554,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   fu_cv_sys_mounted_fread=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
 fi
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $fu_cv_sys_mounted_fread" >&5
@@ -28029,7 +28568,7 @@ $as_echo "#define MOUNTED_FREAD 1" >>con
 fi
 
 if test -z "$ac_list_mounted_fs"; then
-  as_fn_error "could not determine how to read list of mounted file systems" "$LINENO" 5
+  as_fn_error $? "could not determine how to read list of mounted file systems" "$LINENO" 5
   # FIXME -- no need to abort building the whole package
   # Can't build mountlist.c or anything that needs its functions
 fi
@@ -28693,8 +29232,7 @@ $as_echo "#define GNULIB_OPEN 1" >>confd
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -28891,8 +29429,7 @@ do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
 "
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -28906,8 +29443,7 @@ done
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -30135,7 +30671,7 @@ $as_echo "$gl_cv_func_re_compile_pattern
     no) ac_use_included_regex=yes;;
     esac
     ;;
-  *) as_fn_error "Invalid value for --with-included-regex: $with_included_regex" "$LINENO" 5
+  *) as_fn_error $? "Invalid value for --with-included-regex: $with_included_regex" "$LINENO" 5
     ;;
   esac
 
@@ -30241,7 +30777,7 @@ else
 
     rm -rf conftest.d1 conftest.d2
     mkdir conftest.d1 ||
-      as_fn_error "cannot create temporary directory" "$LINENO" 5
+      as_fn_error $? "cannot create temporary directory" "$LINENO" 5
     if test "$cross_compiling" = yes; then :
         gl_cv_func_rename_trailing_slash_bug=yes
 else
@@ -30325,7 +30861,7 @@ else
 
     rm -rf conftest.d1 conftest.d2
     mkdir conftest.d1 ||
-      as_fn_error "cannot create temporary directory" "$LINENO" 5
+      as_fn_error $? "cannot create temporary directory" "$LINENO" 5
     if test "$cross_compiling" = yes; then :
         gl_cv_func_rename_trailing_dest_slash_bug=yes
 else
@@ -32292,7 +32828,7 @@ rm -f core conftest.err conftest.$ac_obj
 fi
 
       if test "$gl_cv_socklen_t_equiv" = ""; then
-	as_fn_error "Cannot find a type to use in place of socklen_t" "$LINENO" 5
+	as_fn_error $? "Cannot find a type to use in place of socklen_t" "$LINENO" 5
       fi
       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $gl_cv_socklen_t_equiv" >&5
 $as_echo "$gl_cv_socklen_t_equiv" >&6; }
@@ -33109,8 +33645,7 @@ $as_echo "$gl_cv_header_working_stdint_h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -33142,7 +33677,7 @@ done
   for gltype in ptrdiff_t size_t ; do
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for bit size of $gltype" >&5
 $as_echo_n "checking for bit size of $gltype... " >&6; }
-if { as_var=gl_cv_bitsizeof_${gltype}; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${gl_cv_bitsizeof_${gltype}+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "sizeof ($gltype) * CHAR_BIT" "result"        "
@@ -33187,7 +33722,7 @@ _ACEOF
   for gltype in sig_atomic_t wchar_t wint_t ; do
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for bit size of $gltype" >&5
 $as_echo_n "checking for bit size of $gltype... " >&6; }
-if { as_var=gl_cv_bitsizeof_${gltype}; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${gl_cv_bitsizeof_${gltype}+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if ac_fn_c_compute_int "$LINENO" "sizeof ($gltype) * CHAR_BIT" "result"        "
@@ -33231,7 +33766,7 @@ _ACEOF
   for gltype in sig_atomic_t wchar_t wint_t ; do
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $gltype is signed" >&5
 $as_echo_n "checking whether $gltype is signed... " >&6; }
-if { as_var=gl_cv_type_${gltype}_signed; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${gl_cv_type_${gltype}_signed+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -33290,7 +33825,7 @@ _ACEOF
   for gltype in ptrdiff_t size_t ; do
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $gltype integer literal suffix" >&5
 $as_echo_n "checking for $gltype integer literal suffix... " >&6; }
-if { as_var=gl_cv_type_${gltype}_suffix; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${gl_cv_type_${gltype}_suffix+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   eval gl_cv_type_${gltype}_suffix=no
@@ -33362,7 +33897,7 @@ _ACEOF
   for gltype in sig_atomic_t wchar_t wint_t ; do
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $gltype integer literal suffix" >&5
 $as_echo_n "checking for $gltype integer literal suffix... " >&6; }
-if { as_var=gl_cv_type_${gltype}_suffix; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${gl_cv_type_${gltype}_suffix+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   eval gl_cv_type_${gltype}_suffix=no
@@ -36310,7 +36845,7 @@ fi
   if test "X$with_packager" = "X" && \
      test "X$with_packager_version$with_packager_bug_reports" != "X"
   then
-    as_fn_error "The --with-packager-{bug-reports,version} options require --with-packager" "$LINENO" 5
+    as_fn_error $? "The --with-packager-{bug-reports,version} options require --with-packager" "$LINENO" 5
   fi
 
 
@@ -41642,8 +42177,7 @@ fi
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
@@ -42318,7 +42852,7 @@ fi
 
     if test "X$LIB_CAP" = "X"; then
       if test "X$enable_libcap" = "Xyes"; then
-        as_fn_error "libcap library was not found or not usable" "$LINENO" 5
+        as_fn_error $? "libcap library was not found or not usable" "$LINENO" 5
       else
         { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: libcap library was not found or not usable, support for libcap will not be built" >&5
 $as_echo "$as_me: WARNING: libcap library was not found or not usable, support for libcap will not be built" >&2;}
@@ -42386,7 +42920,7 @@ rm -f core conftest.err conftest.$ac_obj
 if test "${enable_gcc_warnings+set}" = set; then :
   enableval=$enable_gcc_warnings; case $enableval in
      yes|no) ;;
-     *)      as_fn_error "bad value $enableval for gcc-warnings option" "$LINENO" 5 ;;
+     *)      as_fn_error $? "bad value $enableval for gcc-warnings option" "$LINENO" 5 ;;
    esac
    gl_gcc_warnings=$enableval
 else
@@ -42420,7 +42954,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   gl_cv_warn__Werror=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
   CPPFLAGS="$save_CPPFLAGS"
 
 fi
@@ -42554,7 +43088,7 @@ fi
     as_gl_Warn=`$as_echo "gl_cv_warn_$w" | $as_tr_sh`
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether compiler handles $w" >&5
 $as_echo_n "checking whether compiler handles $w... " >&6; }
-if { as_var=$as_gl_Warn; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$as_gl_Warn+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -42576,15 +43110,14 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   eval "$as_gl_Warn=no"
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
   CPPFLAGS="$save_CPPFLAGS"
 
 fi
 eval ac_res=\$$as_gl_Warn
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-eval as_val=\$$as_gl_Warn
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_gl_Warn"\" = x"yes"; then :
   as_fn_append WARN_CFLAGS " $w"
 fi
 
@@ -42613,7 +43146,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   gl_cv_warn__Wno_missing_field_initializers=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
   CPPFLAGS="$save_CPPFLAGS"
 
 fi
@@ -42647,7 +43180,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   gl_cv_warn__Wno_sign_compare=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
   CPPFLAGS="$save_CPPFLAGS"
 
 fi
@@ -42681,7 +43214,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   gl_cv_warn__Wno_pointer_sign=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
   CPPFLAGS="$save_CPPFLAGS"
 
 fi
@@ -42715,7 +43248,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   gl_cv_warn__Wno_unused_parameter=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
   CPPFLAGS="$save_CPPFLAGS"
 
 fi
@@ -42751,7 +43284,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   gl_cv_warn__Wno_jump_misses_init=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
   CPPFLAGS="$save_CPPFLAGS"
 
 fi
@@ -42788,7 +43321,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   gl_cv_warn__Wno_logical_op=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
   CPPFLAGS="$save_CPPFLAGS"
 
 fi
@@ -42823,7 +43356,7 @@ if ac_fn_c_try_cpp "$LINENO"; then :
 else
   gl_cv_warn__fdiagnostics_show_option=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.err conftest.i conftest.$ac_ext
   CPPFLAGS="$save_CPPFLAGS"
 
 fi
@@ -42863,8 +43396,7 @@ for ac_func in fork vfork
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
@@ -43312,7 +43844,7 @@ if test $ac_cv_func_syslog = no; then
     as_ac_Lib=`$as_echo "ac_cv_lib_$lib''_syslog" | $as_tr_sh`
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for syslog in -l$lib" >&5
 $as_echo_n "checking for syslog in -l$lib... " >&6; }
-if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$as_ac_Lib+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
@@ -43347,8 +43879,7 @@ fi
 eval ac_res=\$$as_ac_Lib
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
-eval as_val=\$$as_ac_Lib
-   if test "x$as_val" = x""yes; then :
+if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
 
 $as_echo "#define HAVE_SYSLOG 1" >>confdefs.h
 
@@ -44417,10 +44948,9 @@ t=`sed -n '/'"$re"'/{s/'"$re"'/\1/;s/,/
 }' $c`
 case $t in
   $no_install_progs_default) ;;
-  *) { as_fn_set_status 1
-as_fn_error "internal error: g'l_INCLUDE_EXCLUDE_PROG's 2nd arg, $t,
+  *) as_fn_error 1 "internal error: g'l_INCLUDE_EXCLUDE_PROG's 2nd arg, $t,
                    does not match the list of default-not-installed programs
-                   ($no_install_progs_default) also recorded in $mk" "$LINENO" 5; } ;;
+                   ($no_install_progs_default) also recorded in $mk" "$LINENO" 5 ;;
 esac
 
 # Given the name of a variable containing a space-separated list of
@@ -44465,7 +44995,7 @@ fi
 
     # Fail upon a request to install and not-install the same program.
     case " $gl_do_install_prog " in
-      *" $gl_i "*) as_fn_error "'$gl_i' is both included and excluded" "$LINENO" 5 ;;
+      *" $gl_i "*) as_fn_error $? "'$gl_i' is both included and excluded" "$LINENO" 5 ;;
     esac
 
     gl_msg=
@@ -44983,7 +45513,7 @@ typedef int array [2 * (__GNU_GETTEXT_SU
 
         { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU gettext in libc" >&5
 $as_echo_n "checking for GNU gettext in libc... " >&6; }
-if { as_var=$gt_func_gnugettext_libc; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$gt_func_gnugettext_libc+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
@@ -45680,7 +46210,7 @@ fi
 
           { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU gettext in libintl" >&5
 $as_echo_n "checking for GNU gettext in libintl... " >&6; }
-if { as_var=$gt_func_gnugettext_libintl; eval "test \"\${$as_var+set}\" = set"; }; then :
+if eval "test \"\${$gt_func_gnugettext_libintl+set}\"" = set; then :
   $as_echo_n "(cached) " >&6
 else
   gt_save_CPPFLAGS="$CPPFLAGS"
@@ -46068,21 +46598,21 @@ else
 fi
 
 if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
-  as_fn_error "conditional \"AMDEP\" was never defined.
+  as_fn_error $? "conditional \"AMDEP\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  as_fn_error "conditional \"am__fastdepCC\" was never defined.
+  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${GL_COND_LIBTOOL_TRUE}" && test -z "${GL_COND_LIBTOOL_FALSE}"; then
-  as_fn_error "conditional \"GL_COND_LIBTOOL\" was never defined.
+  as_fn_error $? "conditional \"GL_COND_LIBTOOL\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 test "X$DEFS" = X-DHAVE_CONFIG_H && DEFS=
 
 if test -z "${GNU_MAKE_TRUE}" && test -z "${GNU_MAKE_FALSE}"; then
-  as_fn_error "conditional \"GNU_MAKE\" was never defined.
+  as_fn_error $? "conditional \"GNU_MAKE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 
@@ -46120,7 +46650,7 @@ fi
 
 
 if test -z "${CROSS_COMPILING_TRUE}" && test -z "${CROSS_COMPILING_FALSE}"; then
-  as_fn_error "conditional \"CROSS_COMPILING\" was never defined.
+  as_fn_error $? "conditional \"CROSS_COMPILING\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 
@@ -46270,19 +46800,19 @@ export LANGUAGE
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
+# script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $1" >&2
+  $as_echo "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -46478,7 +47008,7 @@ $as_echo X"$as_dir" |
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
@@ -46532,7 +47062,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_wri
 # values after options handling.
 ac_log="
 This file was extended by GNU coreutils $as_me 7.6, which was
-generated by GNU Autoconf 2.64.27-5b5d.  Invocation command line was
+generated by GNU Autoconf 2.67.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -46573,6 +47103,7 @@ Usage: $0 [OPTION]... [TAG]...
 
   -h, --help       print this help, then exit
   -V, --version    print version number and configuration settings, then exit
+      --config     print configuration, then exit
   -q, --quiet, --silent
                    do not print progress messages
   -d, --debug      don't remove temporary files
@@ -46600,12 +47131,13 @@ General help using GNU software: <http:/
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
 GNU coreutils config.status 7.6
-configured by $0, generated by GNU Autoconf 2.64.27-5b5d,
-  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+configured by $0, generated by GNU Autoconf 2.67,
+  with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2009 Free Software Foundation, Inc.
+Copyright (C) 2010 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -46623,11 +47155,16 @@ ac_need_defaults=:
 while test $# != 0
 do
   case $1 in
-  --*=*)
+  --*=?*)
     ac_option=`expr "X$1" : 'X\([^=]*\)='`
     ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
     ac_shift=:
     ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
   *)
     ac_option=$1
     ac_optarg=$2
@@ -46641,12 +47178,15 @@ do
     ac_cs_recheck=: ;;
   --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
     $as_echo "$ac_cs_version"; exit ;;
+  --config | --confi | --conf | --con | --co | --c )
+    $as_echo "$ac_cs_config"; exit ;;
   --debug | --debu | --deb | --de | --d | -d )
     debug=: ;;
   --file | --fil | --fi | --f )
     $ac_shift
     case $ac_optarg in
     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    '') as_fn_error $? "missing file argument" ;;
     esac
     as_fn_append CONFIG_FILES " '$ac_optarg'"
     ac_need_defaults=false;;
@@ -46659,7 +47199,7 @@ do
     ac_need_defaults=false;;
   --he | --h)
     # Conflict between --help and --header
-    as_fn_error "ambiguous option: \`$1'
+    as_fn_error $? "ambiguous option: \`$1'
 Try \`$0 --help' for more information.";;
   --help | --hel | -h )
     $as_echo "$ac_cs_usage"; exit ;;
@@ -46668,7 +47208,7 @@ Try \`$0 --help' for more information.";
     ac_cs_silent=: ;;
 
   # This is an error.
-  -*) as_fn_error "unrecognized option: \`$1'
+  -*) as_fn_error $? "unrecognized option: \`$1'
 Try \`$0 --help' for more information." ;;
 
   *) as_fn_append ac_config_targets " $1"
@@ -46743,7 +47283,7 @@ do
     "tests/Makefile") CONFIG_FILES="$CONFIG_FILES tests/Makefile" ;;
     "gnulib-tests/Makefile") CONFIG_FILES="$CONFIG_FILES gnulib-tests/Makefile" ;;
 
-  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
 done
 
@@ -46782,7 +47322,7 @@ $debug ||
 {
   tmp=./conf$$-$RANDOM
   (umask 077 && mkdir "$tmp")
-} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
 
 # Set up the scripts for CONFIG_FILES section.
 # No need to generate them if there are no CONFIG_FILES.
@@ -46799,7 +47339,7 @@ if test "x$ac_cr" = x; then
 fi
 ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
 if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\r'
+  ac_cs_awk_cr='\\r'
 else
   ac_cs_awk_cr=$ac_cr
 fi
@@ -46813,18 +47353,18 @@ _ACEOF
   echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
   echo "_ACEOF"
 } >conf$$subs.sh ||
-  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
   . ./conf$$subs.sh ||
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
 
   ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
   if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -46846,7 +47386,7 @@ s/'"$ac_delim"'$//
 t delim
 :nl
 h
-s/\(.\{148\}\).*/\1/
+s/\(.\{148\}\)..*/\1/
 t more1
 s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
 p
@@ -46860,7 +47400,7 @@ s/.\{148\}//
 t nl
 :delim
 h
-s/\(.\{148\}\).*/\1/
+s/\(.\{148\}\)..*/\1/
 t more2
 s/["\\]/\\&/g; s/^/"/; s/$/"/
 p
@@ -46913,20 +47453,28 @@ if sed "s/$ac_cr//" < /dev/null > /dev/n
 else
   cat
 fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
-  || as_fn_error "could not setup config files machinery" "$LINENO" 5
+  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
 _ACEOF
 
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
+# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
 # trailing colons and then remove the whole line if VPATH becomes empty
 # (actually we leave an empty line to preserve line numbers).
 if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/
-s/:*\${srcdir}:*/:/
-s/:*@srcdir@:*/:/
-s/^\([^=]*=[	 ]*\):*/\1/
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
+h
+s///
+s/^/:/
+s/[	 ]*$/:/
+s/:\$(srcdir):/:/g
+s/:\${srcdir}:/:/g
+s/:@srcdir@:/:/g
+s/^:*//
 s/:*$//
+x
+s/\(=[	 ]*\).*/\1/
+G
+s/\n//
 s/^[^=]*=[	 ]*$//
 }'
 fi
@@ -46954,7 +47502,7 @@ for ac_last_try in false false :; do
   if test -z "$ac_t"; then
     break
   elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_HEADERS" "$LINENO" 5
+    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -47039,7 +47587,7 @@ cat >>$CONFIG_STATUS <<_ACEOF || ac_writ
 _ACAWK
 _ACEOF
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-  as_fn_error "could not setup config headers machinery" "$LINENO" 5
+  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
 fi # test -n "$CONFIG_HEADERS"
 
 
@@ -47052,7 +47600,7 @@ do
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
   esac
@@ -47080,7 +47628,7 @@ do
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
-	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
       esac
       case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
       as_fn_append ac_file_inputs " '$ac_f'"
@@ -47107,7 +47655,7 @@ $as_echo "$as_me: creating $ac_file" >&6
 
     case $ac_tag in
     *:-:* | *:-) cat >"$tmp/stdin" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
     esac
     ;;
   esac
@@ -47244,22 +47792,22 @@ s&@MKDIR_P@&$ac_MKDIR_P&;t t
 $ac_datarootdir_hack
 "
 eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
   { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
   { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&5
+which seems to be undefined.  Please make sure it is defined" >&5
 $as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&2;}
+which seems to be undefined.  Please make sure it is defined" >&2;}
 
   rm -f "$tmp/stdin"
   case $ac_file in
   -) cat "$tmp/out" && rm -f "$tmp/out";;
   *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
   esac \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
  ;;
   :H)
   #
@@ -47270,19 +47818,19 @@ which seems to be undefined.  Please mak
       $as_echo "/* $configure_input  */" \
       && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
     } >"$tmp/config.h" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
     if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
       { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
 $as_echo "$as_me: $ac_file is unchanged" >&6;}
     else
       rm -f "$ac_file"
       mv "$tmp/config.h" "$ac_file" \
-	|| as_fn_error "could not create $ac_file" "$LINENO" 5
+	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
     fi
   else
     $as_echo "/* $configure_input  */" \
       && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
-      || as_fn_error "could not create -" "$LINENO" 5
+      || as_fn_error $? "could not create -" "$LINENO" 5
   fi
 # Compute "$ac_file"'s index in $config_headers.
 _am_arg="$ac_file"
@@ -47336,19 +47884,19 @@ $as_echo X"$_am_arg" |
 $as_echo "$as_me: linking $ac_source to $ac_file" >&6;}
 
     if test ! -r "$ac_source"; then
-      as_fn_error "$ac_source: file not found" "$LINENO" 5
+      as_fn_error $? "$ac_source: file not found" "$LINENO" 5
     fi
     rm -f "$ac_file"
 
     # Try a relative symlink, then a hard link, then a copy.
-    case $srcdir in
+    case $ac_source in
     [\\/$]* | ?:[\\/]* ) ac_rel_source=$ac_source ;;
 	*) ac_rel_source=$ac_top_build_prefix$ac_source ;;
     esac
     ln -s "$ac_rel_source" "$ac_file" 2>/dev/null ||
       ln "$ac_source" "$ac_file" 2>/dev/null ||
       cp -p "$ac_source" "$ac_file" ||
-      as_fn_error "cannot link or copy $ac_source to $ac_file" "$LINENO" 5
+      as_fn_error $? "cannot link or copy $ac_source to $ac_file" "$LINENO" 5
   fi
  ;;
   :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
@@ -47576,7 +48124,7 @@ _ACEOF
 ac_clean_files=$ac_clean_files_save
 
 test $ac_write_fail = 0 ||
-  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
 
 
 # configure is writing to config.log, and then calls config.status.
@@ -47597,7 +48145,7 @@ if test "$no_create" != yes; then
   exec 5>>config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
-  $ac_cs_success || as_fn_exit $?
+  $ac_cs_success || as_fn_exit 1
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
diff -rupN orig/doc/Makefile.in new/doc/Makefile.in
--- orig/doc/Makefile.in	2009-09-10 22:56:44.000000000 -0700
+++ new/doc/Makefile.in	2012-10-08 13:50:50.252675307 -0700
@@ -140,27 +140,27 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/0
 	$(top_srcdir)/m4/mbiter.m4 $(top_srcdir)/m4/mbrlen.m4 \
 	$(top_srcdir)/m4/mbrtowc.m4 $(top_srcdir)/m4/mbsinit.m4 \
 	$(top_srcdir)/m4/mbsrtowcs.m4 $(top_srcdir)/m4/mbstate_t.m4 \
-	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/md5.m4 \
-	$(top_srcdir)/m4/memcasecmp.m4 $(top_srcdir)/m4/memchr.m4 \
-	$(top_srcdir)/m4/memcmp.m4 $(top_srcdir)/m4/memcoll.m4 \
-	$(top_srcdir)/m4/memcpy.m4 $(top_srcdir)/m4/memmove.m4 \
-	$(top_srcdir)/m4/mempcpy.m4 $(top_srcdir)/m4/memrchr.m4 \
-	$(top_srcdir)/m4/memset.m4 $(top_srcdir)/m4/memxfrm.m4 \
-	$(top_srcdir)/m4/mgetgroups.m4 $(top_srcdir)/m4/mkancesdirs.m4 \
-	$(top_srcdir)/m4/mkdir-p.m4 $(top_srcdir)/m4/mkdir-slash.m4 \
-	$(top_srcdir)/m4/mkstemp.m4 $(top_srcdir)/m4/mktime.m4 \
-	$(top_srcdir)/m4/mmap-anon.m4 $(top_srcdir)/m4/mode_t.m4 \
-	$(top_srcdir)/m4/modechange.m4 $(top_srcdir)/m4/mountlist.m4 \
-	$(top_srcdir)/m4/mpsort.m4 $(top_srcdir)/m4/multiarch.m4 \
-	$(top_srcdir)/m4/nanosleep.m4 $(top_srcdir)/m4/netdb_h.m4 \
-	$(top_srcdir)/m4/netinet_in_h.m4 $(top_srcdir)/m4/nls.m4 \
-	$(top_srcdir)/m4/nocrash.m4 $(top_srcdir)/m4/open.m4 \
-	$(top_srcdir)/m4/openat.m4 $(top_srcdir)/m4/pathmax.m4 \
-	$(top_srcdir)/m4/perl.m4 $(top_srcdir)/m4/perror.m4 \
-	$(top_srcdir)/m4/physmem.m4 $(top_srcdir)/m4/po.m4 \
-	$(top_srcdir)/m4/posix-shell.m4 $(top_srcdir)/m4/posixtm.m4 \
-	$(top_srcdir)/m4/posixver.m4 $(top_srcdir)/m4/prereq.m4 \
-	$(top_srcdir)/m4/printf-frexp.m4 \
+	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/mcore.m4 \
+	$(top_srcdir)/m4/md5.m4 $(top_srcdir)/m4/memcasecmp.m4 \
+	$(top_srcdir)/m4/memchr.m4 $(top_srcdir)/m4/memcmp.m4 \
+	$(top_srcdir)/m4/memcoll.m4 $(top_srcdir)/m4/memcpy.m4 \
+	$(top_srcdir)/m4/memmove.m4 $(top_srcdir)/m4/mempcpy.m4 \
+	$(top_srcdir)/m4/memrchr.m4 $(top_srcdir)/m4/memset.m4 \
+	$(top_srcdir)/m4/memxfrm.m4 $(top_srcdir)/m4/mgetgroups.m4 \
+	$(top_srcdir)/m4/mkancesdirs.m4 $(top_srcdir)/m4/mkdir-p.m4 \
+	$(top_srcdir)/m4/mkdir-slash.m4 $(top_srcdir)/m4/mkstemp.m4 \
+	$(top_srcdir)/m4/mktime.m4 $(top_srcdir)/m4/mmap-anon.m4 \
+	$(top_srcdir)/m4/mode_t.m4 $(top_srcdir)/m4/modechange.m4 \
+	$(top_srcdir)/m4/mountlist.m4 $(top_srcdir)/m4/mpsort.m4 \
+	$(top_srcdir)/m4/multiarch.m4 $(top_srcdir)/m4/nanosleep.m4 \
+	$(top_srcdir)/m4/netdb_h.m4 $(top_srcdir)/m4/netinet_in_h.m4 \
+	$(top_srcdir)/m4/nls.m4 $(top_srcdir)/m4/nocrash.m4 \
+	$(top_srcdir)/m4/open.m4 $(top_srcdir)/m4/openat.m4 \
+	$(top_srcdir)/m4/pathmax.m4 $(top_srcdir)/m4/perl.m4 \
+	$(top_srcdir)/m4/perror.m4 $(top_srcdir)/m4/physmem.m4 \
+	$(top_srcdir)/m4/po.m4 $(top_srcdir)/m4/posix-shell.m4 \
+	$(top_srcdir)/m4/posixtm.m4 $(top_srcdir)/m4/posixver.m4 \
+	$(top_srcdir)/m4/prereq.m4 $(top_srcdir)/m4/printf-frexp.m4 \
 	$(top_srcdir)/m4/printf-frexpl.m4 $(top_srcdir)/m4/printf.m4 \
 	$(top_srcdir)/m4/priv-set.m4 $(top_srcdir)/m4/progtest.m4 \
 	$(top_srcdir)/m4/putenv.m4 $(top_srcdir)/m4/quote.m4 \
@@ -788,6 +788,7 @@ NEXT_WCHAR_H = @NEXT_WCHAR_H@
 NEXT_WCTYPE_H = @NEXT_WCTYPE_H@
 NO_INSTALL_PROGS_DEFAULT = @NO_INSTALL_PROGS_DEFAULT@
 OBJEXT = @OBJEXT@
+OPENMP_CFLAGS = @OPENMP_CFLAGS@
 OPTIONAL_BIN_PROGS = @OPTIONAL_BIN_PROGS@
 OPTIONAL_PKGLIB_PROGS = @OPTIONAL_PKGLIB_PROGS@
 PACKAGE = @PACKAGE@
diff -rupN orig/gnulib-tests/Makefile.in new/gnulib-tests/Makefile.in
--- orig/gnulib-tests/Makefile.in	2009-09-10 23:06:05.000000000 -0700
+++ new/gnulib-tests/Makefile.in	2012-10-08 13:50:50.088661638 -0700
@@ -265,27 +265,27 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/0
 	$(top_srcdir)/m4/mbiter.m4 $(top_srcdir)/m4/mbrlen.m4 \
 	$(top_srcdir)/m4/mbrtowc.m4 $(top_srcdir)/m4/mbsinit.m4 \
 	$(top_srcdir)/m4/mbsrtowcs.m4 $(top_srcdir)/m4/mbstate_t.m4 \
-	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/md5.m4 \
-	$(top_srcdir)/m4/memcasecmp.m4 $(top_srcdir)/m4/memchr.m4 \
-	$(top_srcdir)/m4/memcmp.m4 $(top_srcdir)/m4/memcoll.m4 \
-	$(top_srcdir)/m4/memcpy.m4 $(top_srcdir)/m4/memmove.m4 \
-	$(top_srcdir)/m4/mempcpy.m4 $(top_srcdir)/m4/memrchr.m4 \
-	$(top_srcdir)/m4/memset.m4 $(top_srcdir)/m4/memxfrm.m4 \
-	$(top_srcdir)/m4/mgetgroups.m4 $(top_srcdir)/m4/mkancesdirs.m4 \
-	$(top_srcdir)/m4/mkdir-p.m4 $(top_srcdir)/m4/mkdir-slash.m4 \
-	$(top_srcdir)/m4/mkstemp.m4 $(top_srcdir)/m4/mktime.m4 \
-	$(top_srcdir)/m4/mmap-anon.m4 $(top_srcdir)/m4/mode_t.m4 \
-	$(top_srcdir)/m4/modechange.m4 $(top_srcdir)/m4/mountlist.m4 \
-	$(top_srcdir)/m4/mpsort.m4 $(top_srcdir)/m4/multiarch.m4 \
-	$(top_srcdir)/m4/nanosleep.m4 $(top_srcdir)/m4/netdb_h.m4 \
-	$(top_srcdir)/m4/netinet_in_h.m4 $(top_srcdir)/m4/nls.m4 \
-	$(top_srcdir)/m4/nocrash.m4 $(top_srcdir)/m4/open.m4 \
-	$(top_srcdir)/m4/openat.m4 $(top_srcdir)/m4/pathmax.m4 \
-	$(top_srcdir)/m4/perl.m4 $(top_srcdir)/m4/perror.m4 \
-	$(top_srcdir)/m4/physmem.m4 $(top_srcdir)/m4/po.m4 \
-	$(top_srcdir)/m4/posix-shell.m4 $(top_srcdir)/m4/posixtm.m4 \
-	$(top_srcdir)/m4/posixver.m4 $(top_srcdir)/m4/prereq.m4 \
-	$(top_srcdir)/m4/printf-frexp.m4 \
+	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/mcore.m4 \
+	$(top_srcdir)/m4/md5.m4 $(top_srcdir)/m4/memcasecmp.m4 \
+	$(top_srcdir)/m4/memchr.m4 $(top_srcdir)/m4/memcmp.m4 \
+	$(top_srcdir)/m4/memcoll.m4 $(top_srcdir)/m4/memcpy.m4 \
+	$(top_srcdir)/m4/memmove.m4 $(top_srcdir)/m4/mempcpy.m4 \
+	$(top_srcdir)/m4/memrchr.m4 $(top_srcdir)/m4/memset.m4 \
+	$(top_srcdir)/m4/memxfrm.m4 $(top_srcdir)/m4/mgetgroups.m4 \
+	$(top_srcdir)/m4/mkancesdirs.m4 $(top_srcdir)/m4/mkdir-p.m4 \
+	$(top_srcdir)/m4/mkdir-slash.m4 $(top_srcdir)/m4/mkstemp.m4 \
+	$(top_srcdir)/m4/mktime.m4 $(top_srcdir)/m4/mmap-anon.m4 \
+	$(top_srcdir)/m4/mode_t.m4 $(top_srcdir)/m4/modechange.m4 \
+	$(top_srcdir)/m4/mountlist.m4 $(top_srcdir)/m4/mpsort.m4 \
+	$(top_srcdir)/m4/multiarch.m4 $(top_srcdir)/m4/nanosleep.m4 \
+	$(top_srcdir)/m4/netdb_h.m4 $(top_srcdir)/m4/netinet_in_h.m4 \
+	$(top_srcdir)/m4/nls.m4 $(top_srcdir)/m4/nocrash.m4 \
+	$(top_srcdir)/m4/open.m4 $(top_srcdir)/m4/openat.m4 \
+	$(top_srcdir)/m4/pathmax.m4 $(top_srcdir)/m4/perl.m4 \
+	$(top_srcdir)/m4/perror.m4 $(top_srcdir)/m4/physmem.m4 \
+	$(top_srcdir)/m4/po.m4 $(top_srcdir)/m4/posix-shell.m4 \
+	$(top_srcdir)/m4/posixtm.m4 $(top_srcdir)/m4/posixver.m4 \
+	$(top_srcdir)/m4/prereq.m4 $(top_srcdir)/m4/printf-frexp.m4 \
 	$(top_srcdir)/m4/printf-frexpl.m4 $(top_srcdir)/m4/printf.m4 \
 	$(top_srcdir)/m4/priv-set.m4 $(top_srcdir)/m4/progtest.m4 \
 	$(top_srcdir)/m4/putenv.m4 $(top_srcdir)/m4/quote.m4 \
@@ -1751,6 +1751,7 @@ NEXT_WCHAR_H = @NEXT_WCHAR_H@
 NEXT_WCTYPE_H = @NEXT_WCTYPE_H@
 NO_INSTALL_PROGS_DEFAULT = @NO_INSTALL_PROGS_DEFAULT@
 OBJEXT = @OBJEXT@
+OPENMP_CFLAGS = @OPENMP_CFLAGS@
 OPTIONAL_BIN_PROGS = @OPTIONAL_BIN_PROGS@
 OPTIONAL_PKGLIB_PROGS = @OPTIONAL_PKGLIB_PROGS@
 PACKAGE = @PACKAGE@
@@ -2815,7 +2816,7 @@ test-uc_width2.obj: uniwidth/test-uc_wid
 #     (which will cause the Makefiles to be regenerated when you run `make');
 # (2) otherwise, pass the desired values on the `make' command line.
 $(RECURSIVE_TARGETS):
-	@failcom='exit 1'; \
+	@fail= failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
 	    *=* | --[!k]*);; \
@@ -2840,7 +2841,7 @@ $(RECURSIVE_TARGETS):
 	fi; test -z "$$fail"
 
 $(RECURSIVE_CLEAN_TARGETS):
-	@failcom='exit 1'; \
+	@fail= failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
 	    *=* | --[!k]*);; \
diff -rupN orig/lib/Makefile.in new/lib/Makefile.in
--- orig/lib/Makefile.in	2009-09-10 22:56:44.000000000 -0700
+++ new/lib/Makefile.in	2012-10-08 13:50:49.828687344 -0700
@@ -142,27 +142,27 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/0
 	$(top_srcdir)/m4/mbiter.m4 $(top_srcdir)/m4/mbrlen.m4 \
 	$(top_srcdir)/m4/mbrtowc.m4 $(top_srcdir)/m4/mbsinit.m4 \
 	$(top_srcdir)/m4/mbsrtowcs.m4 $(top_srcdir)/m4/mbstate_t.m4 \
-	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/md5.m4 \
-	$(top_srcdir)/m4/memcasecmp.m4 $(top_srcdir)/m4/memchr.m4 \
-	$(top_srcdir)/m4/memcmp.m4 $(top_srcdir)/m4/memcoll.m4 \
-	$(top_srcdir)/m4/memcpy.m4 $(top_srcdir)/m4/memmove.m4 \
-	$(top_srcdir)/m4/mempcpy.m4 $(top_srcdir)/m4/memrchr.m4 \
-	$(top_srcdir)/m4/memset.m4 $(top_srcdir)/m4/memxfrm.m4 \
-	$(top_srcdir)/m4/mgetgroups.m4 $(top_srcdir)/m4/mkancesdirs.m4 \
-	$(top_srcdir)/m4/mkdir-p.m4 $(top_srcdir)/m4/mkdir-slash.m4 \
-	$(top_srcdir)/m4/mkstemp.m4 $(top_srcdir)/m4/mktime.m4 \
-	$(top_srcdir)/m4/mmap-anon.m4 $(top_srcdir)/m4/mode_t.m4 \
-	$(top_srcdir)/m4/modechange.m4 $(top_srcdir)/m4/mountlist.m4 \
-	$(top_srcdir)/m4/mpsort.m4 $(top_srcdir)/m4/multiarch.m4 \
-	$(top_srcdir)/m4/nanosleep.m4 $(top_srcdir)/m4/netdb_h.m4 \
-	$(top_srcdir)/m4/netinet_in_h.m4 $(top_srcdir)/m4/nls.m4 \
-	$(top_srcdir)/m4/nocrash.m4 $(top_srcdir)/m4/open.m4 \
-	$(top_srcdir)/m4/openat.m4 $(top_srcdir)/m4/pathmax.m4 \
-	$(top_srcdir)/m4/perl.m4 $(top_srcdir)/m4/perror.m4 \
-	$(top_srcdir)/m4/physmem.m4 $(top_srcdir)/m4/po.m4 \
-	$(top_srcdir)/m4/posix-shell.m4 $(top_srcdir)/m4/posixtm.m4 \
-	$(top_srcdir)/m4/posixver.m4 $(top_srcdir)/m4/prereq.m4 \
-	$(top_srcdir)/m4/printf-frexp.m4 \
+	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/mcore.m4 \
+	$(top_srcdir)/m4/md5.m4 $(top_srcdir)/m4/memcasecmp.m4 \
+	$(top_srcdir)/m4/memchr.m4 $(top_srcdir)/m4/memcmp.m4 \
+	$(top_srcdir)/m4/memcoll.m4 $(top_srcdir)/m4/memcpy.m4 \
+	$(top_srcdir)/m4/memmove.m4 $(top_srcdir)/m4/mempcpy.m4 \
+	$(top_srcdir)/m4/memrchr.m4 $(top_srcdir)/m4/memset.m4 \
+	$(top_srcdir)/m4/memxfrm.m4 $(top_srcdir)/m4/mgetgroups.m4 \
+	$(top_srcdir)/m4/mkancesdirs.m4 $(top_srcdir)/m4/mkdir-p.m4 \
+	$(top_srcdir)/m4/mkdir-slash.m4 $(top_srcdir)/m4/mkstemp.m4 \
+	$(top_srcdir)/m4/mktime.m4 $(top_srcdir)/m4/mmap-anon.m4 \
+	$(top_srcdir)/m4/mode_t.m4 $(top_srcdir)/m4/modechange.m4 \
+	$(top_srcdir)/m4/mountlist.m4 $(top_srcdir)/m4/mpsort.m4 \
+	$(top_srcdir)/m4/multiarch.m4 $(top_srcdir)/m4/nanosleep.m4 \
+	$(top_srcdir)/m4/netdb_h.m4 $(top_srcdir)/m4/netinet_in_h.m4 \
+	$(top_srcdir)/m4/nls.m4 $(top_srcdir)/m4/nocrash.m4 \
+	$(top_srcdir)/m4/open.m4 $(top_srcdir)/m4/openat.m4 \
+	$(top_srcdir)/m4/pathmax.m4 $(top_srcdir)/m4/perl.m4 \
+	$(top_srcdir)/m4/perror.m4 $(top_srcdir)/m4/physmem.m4 \
+	$(top_srcdir)/m4/po.m4 $(top_srcdir)/m4/posix-shell.m4 \
+	$(top_srcdir)/m4/posixtm.m4 $(top_srcdir)/m4/posixver.m4 \
+	$(top_srcdir)/m4/prereq.m4 $(top_srcdir)/m4/printf-frexp.m4 \
 	$(top_srcdir)/m4/printf-frexpl.m4 $(top_srcdir)/m4/printf.m4 \
 	$(top_srcdir)/m4/priv-set.m4 $(top_srcdir)/m4/progtest.m4 \
 	$(top_srcdir)/m4/putenv.m4 $(top_srcdir)/m4/quote.m4 \
@@ -853,6 +853,7 @@ NEXT_WCHAR_H = @NEXT_WCHAR_H@
 NEXT_WCTYPE_H = @NEXT_WCTYPE_H@
 NO_INSTALL_PROGS_DEFAULT = @NO_INSTALL_PROGS_DEFAULT@
 OBJEXT = @OBJEXT@
+OPENMP_CFLAGS = @OPENMP_CFLAGS@
 OPTIONAL_BIN_PROGS = @OPTIONAL_BIN_PROGS@
 OPTIONAL_PKGLIB_PROGS = @OPTIONAL_PKGLIB_PROGS@
 PACKAGE = @PACKAGE@
@@ -1724,7 +1725,7 @@ distclean-compile:
 #     (which will cause the Makefiles to be regenerated when you run `make');
 # (2) otherwise, pass the desired values on the `make' command line.
 $(RECURSIVE_TARGETS):
-	@failcom='exit 1'; \
+	@fail= failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
 	    *=* | --[!k]*);; \
@@ -1749,7 +1750,7 @@ $(RECURSIVE_TARGETS):
 	fi; test -z "$$fail"
 
 $(RECURSIVE_CLEAN_TARGETS):
-	@failcom='exit 1'; \
+	@fail= failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
 	    *=* | --[!k]*);; \
diff -rupN orig/lib/config.hin new/lib/config.hin
--- orig/lib/config.hin	2009-09-10 22:56:43.000000000 -0700
+++ new/lib/config.hin	2012-10-08 13:50:50.048684997 -0700
@@ -777,6 +777,9 @@
 /* Define to 1 if you have the `futimesat' function. */
 #undef HAVE_FUTIMESAT
 
+/* Define to 1 if you have the <gcrypt.h> header file. */
+#undef HAVE_GCRYPT_H
+
 /* Define to 1 if you have the `getacl' function. */
 #undef HAVE_GETACL
 
@@ -840,6 +843,9 @@
 /* Define if you have GNU libgmp (or replacement) */
 #undef HAVE_GMP
 
+/* Define to 1 if you have the <gnutls/gnutls.h> header file. */
+#undef HAVE_GNUTLS_GNUTLS_H
+
 /* Define to 1 if you have the <grp.h> header file. */
 #undef HAVE_GRP_H
 
@@ -939,9 +945,21 @@
 /* Define to 1 if you have the `dgc' library (-ldgc). */
 #undef HAVE_LIBDGC
 
+/* Define to 1 if you have the 'gcrypt' library ('lgcrypt') */
+#undef HAVE_LIBGCRYPT
+
 /* Define to 1 if you have the <libgen.h> header file. */
 #undef HAVE_LIBGEN_H
 
+/* Define to 1 if you have the 'gnutls' library ('lgnutls') */
+#undef HAVE_LIBGNUTLS
+
+/* Define to 1 if you have the 'gnutls-extra' library ('lgnutls-extra') */
+#undef HAVE_LIBGNUTLS_EXTRA
+
+/* Define to 1 if you have the 'gpg-error' library ('lgpg-error') */
+#undef HAVE_LIBGPG_ERROR
+
 /* Define to 1 if you have the <libintl.h> header file. */
 #undef HAVE_LIBINTL_H
 
@@ -951,15 +969,30 @@
 /* Define to 1 if you have the `ldgc' library (-lldgc). */
 #undef HAVE_LIBLDGC
 
+/* Define to 1 if you have the `lustreapi' library (-llustreapi). */
+#undef HAVE_LIBLUSTREAPI
+
+/* Define to 1 if you have the `m' library (-lm). */
+#undef HAVE_LIBM
+
+/* Define to 1 if you have the `mpi' library (-lmpi). */
+#undef HAVE_LIBMPI
+
 /* Define to 1 if you have the `os' library (-los). */
 #undef HAVE_LIBOS
 
 /* Define to 1 if you have the `perfstat' library (-lperfstat). */
 #undef HAVE_LIBPERFSTAT
 
+/* Define to 1 if you have the `rt' library (-lrt). */
+#undef HAVE_LIBRT
+
 /* Define to 1 if you have the `ypsec' library (-lypsec). */
 #undef HAVE_LIBYPSEC
 
+/* Define to 1 if you have the 'z' library ('lz') */
+#undef HAVE_LIBZ
+
 /* Define to 1 if you have the `link' function. */
 #undef HAVE_LINK
 
@@ -982,6 +1015,9 @@
    zero-length file name argument. */
 #undef HAVE_LSTAT_EMPTY_STRING_BUG
 
+/* Define to 1 if you have the <lustre/liblustreapi.h> header file. */
+#undef HAVE_LUSTRE_LIBLUSTREAPI_H
+
 /* Define to 1 if you have the <machine/hal_sysinfo.h> header file. */
 #undef HAVE_MACHINE_HAL_SYSINFO_H
 
@@ -1053,6 +1089,9 @@
 /* Define to 1 if you have the <mntent.h> header file. */
 #undef HAVE_MNTENT_H
 
+/* Define to 1 if you have the <mpi.h> header file. */
+#undef HAVE_MPI_H
+
 /* Define to 1 if you have the `mprotect' function. */
 #undef HAVE_MPROTECT
 
diff -rupN orig/lib/isnan.c new/lib/isnan.c
--- orig/lib/isnan.c	2009-05-03 22:46:33.000000000 -0700
+++ new/lib/isnan.c	2012-10-08 13:50:49.816715411 -0700
@@ -105,7 +105,9 @@ FUNC (DOUBLE x)
 # else
   /* Be careful to not do any floating-point operation on x, such as x == x,
      because x may be a signaling NaN.  */
-#  if defined __SUNPRO_C || defined __DECC || (defined __sgi && !defined __GNUC__)
+// PZK >
+#  if !defined ICC || __SUNPRO_C || defined __DECC || (defined __sgi && !defined __GNUC__)
+// < PZK
   /* The Sun C 5.0 compilers and the Compaq (ex-DEC) 6.4 compilers don't
      recognize the initializers as constant expressions.  The latter compiler
      also fails when constant-folding 0.0 / 0.0 even when constant-folding is
diff -rupN orig/m4/gnulib-comp.m4 new/m4/gnulib-comp.m4
--- orig/m4/gnulib-comp.m4	2009-09-10 22:56:20.000000000 -0700
+++ new/m4/gnulib-comp.m4	2012-10-08 13:50:49.640661547 -0700
@@ -258,6 +258,15 @@ AC_DEFUN([gl_INIT],
   gl_STRING_MODULE_INDICATOR([mbsstr])
   gl_MBSWIDTH
   gl_MBITER
+# PZK >
+  gl_MCORE_LIBGCRYPT
+  gl_MCORE_LIBGNUTLS_EXTRA
+  gl_MCORE_LIBOMP
+  gl_MCORE_LIBLUSTREAPI
+  gl_MCORE_LIBM
+  gl_MCORE_LIBMPI
+  gl_MCORE_LIBRT
+# < PZK
   gl_MEMCASECMP
   gl_FUNC_MEMCHR
   gl_STRING_MODULE_INDICATOR([memchr])
diff -rupN orig/m4/mcore.m4 new/m4/mcore.m4
--- orig/m4/mcore.m4	1969-12-31 16:00:00.000000000 -0800
+++ new/m4/mcore.m4	2012-10-08 13:50:49.640661547 -0700
@@ -0,0 +1,76 @@
+dnl PZK >
+# mcore.m4 serial 1
+
+dnl Copyright 2010 United States Government National Aeronautics and
+dnl Space Administration (NASA).  No copyright is claimed in the United
+dnl States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+dnl Written by Paul Kolano.
+
+AC_DEFUN([gl_MCORE_LIBM], [
+    AC_CHECK_LIB([m], [pow])
+])
+
+AC_DEFUN([gl_MCORE_LIBRT], [
+    AC_CHECK_LIB([rt], [clock_gettime])
+])
+
+AC_DEFUN([gl_MCORE_LIBGNUTLS_EXTRA], [
+    AC_CHECK_LIB([gnutls-extra], [gnutls_extra_check_version], [
+        LIBS="$LIBS -Wl,-Bstatic -lgnutls-extra -Wl,-Bdynamic"
+        AC_DEFINE([HAVE_LIBGNUTLS_EXTRA], [1], [
+            Define to 1 if you have the 'gnutls-extra' library ('lgnutls-extra')
+        ])
+    ])
+    AC_REQUIRE([gl_MCORE_LIBGNUTLS])
+])
+
+AC_DEFUN([gl_MCORE_LIBGNUTLS], [
+    AC_CHECK_HEADERS([gnutls/gnutls.h])
+    AC_CHECK_LIB([gnutls], [gnutls_global_init], [
+        LIBS="$LIBS -Wl,-Bstatic -lgnutls -Wl,-Bdynamic"
+        AC_DEFINE([HAVE_LIBGNUTLS], [1], [
+            Define to 1 if you have the 'gnutls' library ('lgnutls')
+        ])
+    ])
+    AC_CHECK_LIB([z], [zlibVersion], [
+        LIBS="$LIBS -Wl,-Bstatic -lz -Wl,-Bdynamic"
+        AC_DEFINE([HAVE_LIBZ], [1], [
+            Define to 1 if you have the 'z' library ('lz')
+        ])
+    ])
+])
+
+AC_DEFUN([gl_MCORE_LIBGCRYPT], [
+    AC_CHECK_HEADERS([gcrypt.h])
+    AC_CHECK_LIB([gcrypt], [gcry_md_open], [
+        LIBS="$LIBS -Wl,-Bstatic -lgcrypt -Wl,-Bdynamic"
+        AC_DEFINE([HAVE_LIBGCRYPT], [1], [
+            Define to 1 if you have the 'gcrypt' library ('lgcrypt')
+        ])
+    ])
+    AC_CHECK_LIB([gpg-error], [gpg_err_init], [
+        LIBS="$LIBS -Wl,-Bstatic -lgpg-error -Wl,-Bdynamic"
+        AC_DEFINE([HAVE_LIBGPG_ERROR], [1], [
+            Define to 1 if you have the 'gpg-error' library ('lgpg-error')
+        ])
+    ])
+])
+
+AC_DEFUN([gl_MCORE_LIBLUSTREAPI], [
+    AC_CHECK_HEADERS([lustre/liblustreapi.h])
+    AC_CHECK_LIB([lustreapi], [llapi_file_get_stripe])
+])
+
+AC_DEFUN([gl_MCORE_LIBMPI], [
+    AC_CHECK_HEADERS([mpi.h])
+    AC_CHECK_LIB([mpi], [MPI_Init])
+])
+
+AC_DEFUN([gl_MCORE_LIBOMP], [
+    LIBS="$LIBS -Wl,--no-as-needed"
+    AC_OPENMP
+])
+
+dnl < PZK
+
diff -rupN orig/man/Makefile.in new/man/Makefile.in
--- orig/man/Makefile.in	2009-09-10 22:56:44.000000000 -0700
+++ new/man/Makefile.in	2012-10-08 13:50:49.312707466 -0700
@@ -140,27 +140,27 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/0
 	$(top_srcdir)/m4/mbiter.m4 $(top_srcdir)/m4/mbrlen.m4 \
 	$(top_srcdir)/m4/mbrtowc.m4 $(top_srcdir)/m4/mbsinit.m4 \
 	$(top_srcdir)/m4/mbsrtowcs.m4 $(top_srcdir)/m4/mbstate_t.m4 \
-	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/md5.m4 \
-	$(top_srcdir)/m4/memcasecmp.m4 $(top_srcdir)/m4/memchr.m4 \
-	$(top_srcdir)/m4/memcmp.m4 $(top_srcdir)/m4/memcoll.m4 \
-	$(top_srcdir)/m4/memcpy.m4 $(top_srcdir)/m4/memmove.m4 \
-	$(top_srcdir)/m4/mempcpy.m4 $(top_srcdir)/m4/memrchr.m4 \
-	$(top_srcdir)/m4/memset.m4 $(top_srcdir)/m4/memxfrm.m4 \
-	$(top_srcdir)/m4/mgetgroups.m4 $(top_srcdir)/m4/mkancesdirs.m4 \
-	$(top_srcdir)/m4/mkdir-p.m4 $(top_srcdir)/m4/mkdir-slash.m4 \
-	$(top_srcdir)/m4/mkstemp.m4 $(top_srcdir)/m4/mktime.m4 \
-	$(top_srcdir)/m4/mmap-anon.m4 $(top_srcdir)/m4/mode_t.m4 \
-	$(top_srcdir)/m4/modechange.m4 $(top_srcdir)/m4/mountlist.m4 \
-	$(top_srcdir)/m4/mpsort.m4 $(top_srcdir)/m4/multiarch.m4 \
-	$(top_srcdir)/m4/nanosleep.m4 $(top_srcdir)/m4/netdb_h.m4 \
-	$(top_srcdir)/m4/netinet_in_h.m4 $(top_srcdir)/m4/nls.m4 \
-	$(top_srcdir)/m4/nocrash.m4 $(top_srcdir)/m4/open.m4 \
-	$(top_srcdir)/m4/openat.m4 $(top_srcdir)/m4/pathmax.m4 \
-	$(top_srcdir)/m4/perl.m4 $(top_srcdir)/m4/perror.m4 \
-	$(top_srcdir)/m4/physmem.m4 $(top_srcdir)/m4/po.m4 \
-	$(top_srcdir)/m4/posix-shell.m4 $(top_srcdir)/m4/posixtm.m4 \
-	$(top_srcdir)/m4/posixver.m4 $(top_srcdir)/m4/prereq.m4 \
-	$(top_srcdir)/m4/printf-frexp.m4 \
+	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/mcore.m4 \
+	$(top_srcdir)/m4/md5.m4 $(top_srcdir)/m4/memcasecmp.m4 \
+	$(top_srcdir)/m4/memchr.m4 $(top_srcdir)/m4/memcmp.m4 \
+	$(top_srcdir)/m4/memcoll.m4 $(top_srcdir)/m4/memcpy.m4 \
+	$(top_srcdir)/m4/memmove.m4 $(top_srcdir)/m4/mempcpy.m4 \
+	$(top_srcdir)/m4/memrchr.m4 $(top_srcdir)/m4/memset.m4 \
+	$(top_srcdir)/m4/memxfrm.m4 $(top_srcdir)/m4/mgetgroups.m4 \
+	$(top_srcdir)/m4/mkancesdirs.m4 $(top_srcdir)/m4/mkdir-p.m4 \
+	$(top_srcdir)/m4/mkdir-slash.m4 $(top_srcdir)/m4/mkstemp.m4 \
+	$(top_srcdir)/m4/mktime.m4 $(top_srcdir)/m4/mmap-anon.m4 \
+	$(top_srcdir)/m4/mode_t.m4 $(top_srcdir)/m4/modechange.m4 \
+	$(top_srcdir)/m4/mountlist.m4 $(top_srcdir)/m4/mpsort.m4 \
+	$(top_srcdir)/m4/multiarch.m4 $(top_srcdir)/m4/nanosleep.m4 \
+	$(top_srcdir)/m4/netdb_h.m4 $(top_srcdir)/m4/netinet_in_h.m4 \
+	$(top_srcdir)/m4/nls.m4 $(top_srcdir)/m4/nocrash.m4 \
+	$(top_srcdir)/m4/open.m4 $(top_srcdir)/m4/openat.m4 \
+	$(top_srcdir)/m4/pathmax.m4 $(top_srcdir)/m4/perl.m4 \
+	$(top_srcdir)/m4/perror.m4 $(top_srcdir)/m4/physmem.m4 \
+	$(top_srcdir)/m4/po.m4 $(top_srcdir)/m4/posix-shell.m4 \
+	$(top_srcdir)/m4/posixtm.m4 $(top_srcdir)/m4/posixver.m4 \
+	$(top_srcdir)/m4/prereq.m4 $(top_srcdir)/m4/printf-frexp.m4 \
 	$(top_srcdir)/m4/printf-frexpl.m4 $(top_srcdir)/m4/printf.m4 \
 	$(top_srcdir)/m4/priv-set.m4 $(top_srcdir)/m4/progtest.m4 \
 	$(top_srcdir)/m4/putenv.m4 $(top_srcdir)/m4/quote.m4 \
@@ -778,6 +778,7 @@ NEXT_WCHAR_H = @NEXT_WCHAR_H@
 NEXT_WCTYPE_H = @NEXT_WCTYPE_H@
 NO_INSTALL_PROGS_DEFAULT = @NO_INSTALL_PROGS_DEFAULT@
 OBJEXT = @OBJEXT@
+OPENMP_CFLAGS = @OPENMP_CFLAGS@
 OPTIONAL_BIN_PROGS = @OPTIONAL_BIN_PROGS@
 OPTIONAL_PKGLIB_PROGS = @OPTIONAL_PKGLIB_PROGS@
 PACKAGE = @PACKAGE@
diff -rupN orig/man/cp.1 new/man/cp.1
--- orig/man/cp.1	2009-09-10 11:33:33.000000000 -0700
+++ new/man/cp.1	2012-10-08 13:50:49.400708311 -0700
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.35.
-.TH CP "1" "September 2009" "GNU coreutils 7.5.88-dd7f8" "User Commands"
+.TH CP "1" "August 2011" "GNU coreutils 7.6" "User Commands"
 .SH NAME
 cp \- copy files and directories
 .SH SYNOPSIS
@@ -15,8 +15,95 @@ cp \- copy files and directories
 .\" Add any additional description here
 .PP
 Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.
+.SS "Mcp-specific options (defaults in brackets):"
+.TP
+\fB\-\-buffer\-size\fR=\fIMBYTES\fR
+read/write buffer size [4]
+.TP
+\fB\-\-check\-tree\fR
+print hash subtrees to pinpoint corruption
+.TP
+\fB\-\-fadvise\-read\fR
+enable use of posix_fadvise during reads
+.TP
+\fB\-\-fadvise\-write\fR
+enable use of posix_fadvise during writes
+.TP
+\fB\-\-hash\-leaf\-size\fR=\fIKBYTES\fR
+granularity of hash tree [1048576]
+.TP
+\fB\-\-hash\-type\fR=\fITYPE\fR
+hash type [MD5], with TYPE one of:
+md5 sha1 sha256 sha384 sha512 sha224 crc32
+crc32rfc1510 crc24rfc2440
+.TP
+\fB\-\-length\fR=\fILEN\fR
+copy LEN bytes beginning at \fB\-\-offset\fR
+(or 0 if \fB\-\-offset\fR not specified)
+.TP
+\fB\-\-listen\-port\fR=\fIPORT\fR
+listen on port PORT for requests from
+cooperating hosts
+.TP
+\fB\-\-manager\-host\fR=\fIHOST\fR
+host name or IP address of management thread
+for multi\-node/multi\-host copies
+.TP
+\fB\-\-manager\-port\fR=\fIPORT\fR
+port on which to contact management thread
+.TP
+\fB\-\-mpi\fR
+enable use of MPI for multi\-node copies
+.TP
+\fB\-\-no\-direct\-read\fR
+disable use of direct I/O for reads
+.TP
+\fB\-\-no\-direct\-write\fR
+disable use of direct I/O for writes
+.TP
+\fB\-\-no\-double\-buffer\fR
+disable use of double buffering during file I/O
+.TP
+\fB\-\-offset\fR=\fIPOS\fR
+copy \fB\-\-length\fR bytes beginning at POS
+(or to end if \fB\-\-length\fR not specified)
+.TP
+\fB\-\-password\-file\fR=\fIFILE\fR
+file to use for passwords (will be created
+if does not exist)
+.TP
+\fB\-\-print\-hash\fR
+print hash of each file to stdout similar to
+md5sum, with sum of the src file computed,
+but dst file name printed so that md5sum \fB\-c\fR
+can be used on the output to check that the
+data written to disk was what was read
+.TP
+\fB\-\-print\-stats\fR
+print performance per file to stderr
+.TP
+\fB\-\-print\-stripe\fR
+print striping changes to stderr
+.TP
+\fB\-\-read\-stdin\fR
+perform a batch of operations read over stdin
+in the form 'SRC DST RANGES' where SRC and DST
+must be URI\-escaped (RFC 3986) file names and
+RANGES is zero or more comma\-separated ranges of
+the form 'START\-END' for 0 <= START < END
+.TP
+\fB\-\-skip\-chmod\fR
+retain temporary permissions used during copy
+.TP
+\fB\-\-split\-size\fR=\fIMBYTES\fR
+size to split files for parallelization [1024]
+.TP
+\fB\-\-threads\fR=\fINUMBER\fR
+number of OpenMP worker threads to use [4]
 .PP
-Mandatory arguments to long options are mandatory for short options too.
+Standard options (mandatory arguments to long options are mandatory
+.IP
+for short options too):
 .TP
 \fB\-a\fR, \fB\-\-archive\fR
 same as \fB\-dR\fR \fB\-\-preserve\fR=\fIall\fR
@@ -149,7 +236,8 @@ As a special case, cp makes a backup of
 options are given and SOURCE and DEST are the same name for an existing,
 regular file.
 .SH AUTHOR
-Written by Torbjorn Granlund, David MacKenzie, and Jim Meyering.
+Written by Torbjorn Granlund, David MacKenzie, Jim Meyering,
+and Paul Kolano.
 .SH "REPORTING BUGS"
 Report cp bugs to bug\-coreutils@gnu.org
 .br
diff -rupN orig/man/md5sum.1 new/man/md5sum.1
--- orig/man/md5sum.1	2009-09-10 11:33:34.000000000 -0700
+++ new/man/md5sum.1	2012-10-08 13:50:49.400708311 -0700
@@ -1,5 +1,5 @@
 .\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.35.
-.TH MD5SUM "1" "September 2009" "GNU coreutils 7.5.88-dd7f8" "User Commands"
+.TH MD5SUM "1" "August 2011" "GNU coreutils 7.6" "User Commands"
 .SH NAME
 md5sum \- compute and check MD5 message digest
 .SH SYNOPSIS
@@ -8,14 +8,78 @@ md5sum \- compute and check MD5 message
 .SH DESCRIPTION
 .\" Add any additional description here
 .PP
-Print or check MD5 (128\-bit) checksums.
+Print or check checksums.
 With no FILE, or when FILE is \-, read standard input.
+.SS "Msum-specific options (defaults in brackets):"
+.TP
+\fB\-\-buffer\-size\fR=\fIMBYTES\fR
+read/write buffer size [4]
+.TP
+\fB\-\-check\-tree\fR
+print/check hash subtrees to pinpoint corruption
+.TP
+\fB\-\-fadvise\-read\fR
+enable use of posix_fadvise during reads
+.TP
+\fB\-\-hash\-leaf\-size\fR=\fIKBYTES\fR
+granularity of hash tree [1048576]
+.TP
+\fB\-\-hash\-type\fR=\fITYPE\fR
+hash type [MD5], with TYPE one of:
+md5 sha1 sha256 sha384 sha512 sha224 crc32
+crc32rfc1510 crc24rfc2440
+.TP
+\fB\-\-length\fR=\fILEN\fR
+hash LEN bytes beginning at \fB\-\-offset\fR
+(or 0 if \fB\-\-offset\fR not specified)
+.TP
+\fB\-\-listen\-port\fR=\fIPORT\fR
+listen on port PORT for requests from
+cooperating hosts
+.TP
+\fB\-\-manager\-host\fR=\fIHOST\fR
+host name or IP address of management thread
+for multi\-node/multi\-host copies
+.TP
+\fB\-\-manager\-port\fR=\fIPORT\fR
+port on which to contact management thread
+.TP
+\fB\-\-mpi\fR
+enable use of MPI for multi\-node checksums
+.TP
+\fB\-\-no\-direct\-read\fR
+disable use of direct I/O for reads
+.TP
+\fB\-\-no\-double\-buffer\fR
+disable use of double buffering during file I/O
+.TP
+\fB\-\-offset\fR=\fIPOS\fR
+hash \fB\-\-length\fR bytes beginning at POS
+(or to end if \fB\-\-length\fR not specified)
+.TP
+\fB\-\-password\-file\fR=\fIFILE\fR
+file to use for passwords (will be created
+if does not exist)
+.TP
+\fB\-\-read\-stdin\fR
+perform a batch of operations read over stdin
+in the form 'FILE RANGES' where FILE must be
+a URI\-escaped (RFC 3986) file name and RANGES
+is zero or more comma\-separated ranges of the
+form 'START\-END' for 0 <= START < END
+.TP
+\fB\-\-split\-size\fR=\fIMBYTES\fR
+size to split files for parallelization [1024]
+.TP
+\fB\-\-threads\fR=\fINUMBER\fR
+number of OpenMP worker threads to use [4]
+.SS "Standard options:"
 .TP
 \fB\-b\fR, \fB\-\-binary\fR
 read in binary mode
 .TP
 \fB\-c\fR, \fB\-\-check\fR
-read MD5 sums from the FILEs and check them
+read sums from the FILEs and check them
 .TP
 \fB\-t\fR, \fB\-\-text\fR
 read in text mode (default)
@@ -36,12 +100,12 @@ display this help and exit
 \fB\-\-version\fR
 output version information and exit
 .PP
-The sums are computed as described in RFC 1321.  When checking, the input
-should be a former output of this program.  The default mode is to print
-a line with checksum, a character indicating type (`*' for binary, ` ' for
-text), and name for each FILE.
+When checking, the input should be a former output of this program.
+The default mode is to print a line with checksum, a character indicating
+type (`*' for binary, ` ' for text), and name for each FILE.
 .SH AUTHOR
-Written by Ulrich Drepper, Scott Miller, and David Madore.
+Written by Ulrich Drepper, Scott Miller, David Madore,
+and Paul Kolano.
 .SH "REPORTING BUGS"
 Report md5sum bugs to bug\-coreutils@gnu.org
 .br
diff -rupN orig/src/Makefile.am new/src/Makefile.am
--- orig/src/Makefile.am	2009-09-10 22:52:11.000000000 -0700
+++ new/src/Makefile.am	2012-10-08 13:50:49.052715248 -0700
@@ -26,23 +26,15 @@ no_install__progs = \
 build_if_possible__progs = \
   chroot df hostid nice pinky stdbuf libstdbuf.so stty su uname uptime users who
 
-AM_CFLAGS = $(WARN_CFLAGS) $(WERROR_CFLAGS)
+AM_CFLAGS = $(WARN_CFLAGS) $(WERROR_CFLAGS) $(OPENMP_CFLAGS)
 
+# PZK >
 EXTRA_PROGRAMS = \
   $(no_install__progs) \
   $(build_if_possible__progs) \
-  [ chcon chgrp chown chmod cp dd dircolors du \
-  ginstall link ln dir vdir ls mkdir \
-  mkfifo mknod mktemp \
-  mv nohup readlink rm rmdir shred stat sync touch unlink \
-  cat cksum comm csplit cut expand fmt fold head join groups md5sum \
-  nl od paste pr ptx sha1sum sha224sum sha256sum sha384sum sha512sum \
-  shuf sort split sum tac tail tr tsort unexpand uniq wc \
-  basename date dirname echo env expr factor false \
-  id kill logname pathchk printenv printf pwd \
-  runcon seq sleep tee \
-  test timeout true truncate tty whoami yes \
-  base64
+  cp \
+  md5sum
+# < PZK
 
 bin_PROGRAMS = $(OPTIONAL_BIN_PROGS)
 
@@ -50,6 +42,7 @@ noinst_PROGRAMS = setuidgid getlimits
 
 pkglib_PROGRAMS = $(OPTIONAL_PKGLIB_PROGS)
 
+# PZK >
 noinst_HEADERS = \
   chown-core.h \
   copy.h \
@@ -58,6 +51,7 @@ noinst_HEADERS = \
   fs.h \
   group-list.h \
   ls.h \
+  mcore.h \
   operand2sig.h \
   prog-fprintf.h \
   remove.h \
@@ -65,6 +59,7 @@ noinst_HEADERS = \
   wheel-size.h \
   wheel.h \
   uname.h
+# < PZK
 
 EXTRA_DIST = dcgen dircolors.hin tac-pipe.c \
   wheel-gen.pl extract-magic c99-to-c89.diff
@@ -242,7 +237,9 @@ uninstall-local:
 	  fi; \
 	fi
 
-copy_sources = copy.c cp-hash.c
+# PZK >
+copy_sources = copy.c cp-hash.c mcore.c
+# < PZK
 
 # Use `ginstall' in the definition of PROGRAMS and in dependencies to avoid
 # confusion with the `install' target.  The install rule transforms `ginstall'
@@ -275,7 +272,9 @@ rmdir_SOURCES = rmdir.c prog-fprintf.c
 uname_SOURCES = uname.c uname-uname.c
 arch_SOURCES = uname.c uname-arch.c
 
-md5sum_SOURCES = md5sum.c
+# PZK >
+md5sum_SOURCES = md5sum.c mcore.c
+# < PZK
 md5sum_CPPFLAGS = -DHASH_ALGO_MD5=1 $(AM_CPPFLAGS)
 sha1sum_SOURCES = md5sum.c
 sha1sum_CPPFLAGS = -DHASH_ALGO_SHA1=1 $(AM_CPPFLAGS)
diff -rupN orig/src/Makefile.in new/src/Makefile.in
--- orig/src/Makefile.in	2009-09-10 23:15:39.000000000 -0700
+++ new/src/Makefile.in	2012-10-08 13:50:49.052715248 -0700
@@ -35,30 +35,8 @@ PRE_UNINSTALL = :
 POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
-EXTRA_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) [$(EXEEXT) \
-	chcon$(EXEEXT) chgrp$(EXEEXT) chown$(EXEEXT) chmod$(EXEEXT) \
-	cp$(EXEEXT) dd$(EXEEXT) dircolors$(EXEEXT) du$(EXEEXT) \
-	ginstall$(EXEEXT) link$(EXEEXT) ln$(EXEEXT) dir$(EXEEXT) \
-	vdir$(EXEEXT) ls$(EXEEXT) mkdir$(EXEEXT) mkfifo$(EXEEXT) \
-	mknod$(EXEEXT) mktemp$(EXEEXT) mv$(EXEEXT) nohup$(EXEEXT) \
-	readlink$(EXEEXT) rm$(EXEEXT) rmdir$(EXEEXT) shred$(EXEEXT) \
-	stat$(EXEEXT) sync$(EXEEXT) touch$(EXEEXT) unlink$(EXEEXT) \
-	cat$(EXEEXT) cksum$(EXEEXT) comm$(EXEEXT) csplit$(EXEEXT) \
-	cut$(EXEEXT) expand$(EXEEXT) fmt$(EXEEXT) fold$(EXEEXT) \
-	head$(EXEEXT) join$(EXEEXT) groups$(EXEEXT) md5sum$(EXEEXT) \
-	nl$(EXEEXT) od$(EXEEXT) paste$(EXEEXT) pr$(EXEEXT) \
-	ptx$(EXEEXT) sha1sum$(EXEEXT) sha224sum$(EXEEXT) \
-	sha256sum$(EXEEXT) sha384sum$(EXEEXT) sha512sum$(EXEEXT) \
-	shuf$(EXEEXT) sort$(EXEEXT) split$(EXEEXT) sum$(EXEEXT) \
-	tac$(EXEEXT) tail$(EXEEXT) tr$(EXEEXT) tsort$(EXEEXT) \
-	unexpand$(EXEEXT) uniq$(EXEEXT) wc$(EXEEXT) basename$(EXEEXT) \
-	date$(EXEEXT) dirname$(EXEEXT) echo$(EXEEXT) env$(EXEEXT) \
-	expr$(EXEEXT) factor$(EXEEXT) false$(EXEEXT) id$(EXEEXT) \
-	kill$(EXEEXT) logname$(EXEEXT) pathchk$(EXEEXT) \
-	printenv$(EXEEXT) printf$(EXEEXT) pwd$(EXEEXT) runcon$(EXEEXT) \
-	seq$(EXEEXT) sleep$(EXEEXT) tee$(EXEEXT) test$(EXEEXT) \
-	timeout$(EXEEXT) true$(EXEEXT) truncate$(EXEEXT) tty$(EXEEXT) \
-	whoami$(EXEEXT) yes$(EXEEXT) base64$(EXEEXT)
+EXTRA_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) cp$(EXEEXT) \
+	md5sum$(EXEEXT)
 noinst_PROGRAMS = setuidgid$(EXEEXT) getlimits$(EXEEXT)
 subdir = src
 DIST_COMMON = $(noinst_HEADERS) $(srcdir)/Makefile.am \
@@ -150,27 +128,27 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/0
 	$(top_srcdir)/m4/mbiter.m4 $(top_srcdir)/m4/mbrlen.m4 \
 	$(top_srcdir)/m4/mbrtowc.m4 $(top_srcdir)/m4/mbsinit.m4 \
 	$(top_srcdir)/m4/mbsrtowcs.m4 $(top_srcdir)/m4/mbstate_t.m4 \
-	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/md5.m4 \
-	$(top_srcdir)/m4/memcasecmp.m4 $(top_srcdir)/m4/memchr.m4 \
-	$(top_srcdir)/m4/memcmp.m4 $(top_srcdir)/m4/memcoll.m4 \
-	$(top_srcdir)/m4/memcpy.m4 $(top_srcdir)/m4/memmove.m4 \
-	$(top_srcdir)/m4/mempcpy.m4 $(top_srcdir)/m4/memrchr.m4 \
-	$(top_srcdir)/m4/memset.m4 $(top_srcdir)/m4/memxfrm.m4 \
-	$(top_srcdir)/m4/mgetgroups.m4 $(top_srcdir)/m4/mkancesdirs.m4 \
-	$(top_srcdir)/m4/mkdir-p.m4 $(top_srcdir)/m4/mkdir-slash.m4 \
-	$(top_srcdir)/m4/mkstemp.m4 $(top_srcdir)/m4/mktime.m4 \
-	$(top_srcdir)/m4/mmap-anon.m4 $(top_srcdir)/m4/mode_t.m4 \
-	$(top_srcdir)/m4/modechange.m4 $(top_srcdir)/m4/mountlist.m4 \
-	$(top_srcdir)/m4/mpsort.m4 $(top_srcdir)/m4/multiarch.m4 \
-	$(top_srcdir)/m4/nanosleep.m4 $(top_srcdir)/m4/netdb_h.m4 \
-	$(top_srcdir)/m4/netinet_in_h.m4 $(top_srcdir)/m4/nls.m4 \
-	$(top_srcdir)/m4/nocrash.m4 $(top_srcdir)/m4/open.m4 \
-	$(top_srcdir)/m4/openat.m4 $(top_srcdir)/m4/pathmax.m4 \
-	$(top_srcdir)/m4/perl.m4 $(top_srcdir)/m4/perror.m4 \
-	$(top_srcdir)/m4/physmem.m4 $(top_srcdir)/m4/po.m4 \
-	$(top_srcdir)/m4/posix-shell.m4 $(top_srcdir)/m4/posixtm.m4 \
-	$(top_srcdir)/m4/posixver.m4 $(top_srcdir)/m4/prereq.m4 \
-	$(top_srcdir)/m4/printf-frexp.m4 \
+	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/mcore.m4 \
+	$(top_srcdir)/m4/md5.m4 $(top_srcdir)/m4/memcasecmp.m4 \
+	$(top_srcdir)/m4/memchr.m4 $(top_srcdir)/m4/memcmp.m4 \
+	$(top_srcdir)/m4/memcoll.m4 $(top_srcdir)/m4/memcpy.m4 \
+	$(top_srcdir)/m4/memmove.m4 $(top_srcdir)/m4/mempcpy.m4 \
+	$(top_srcdir)/m4/memrchr.m4 $(top_srcdir)/m4/memset.m4 \
+	$(top_srcdir)/m4/memxfrm.m4 $(top_srcdir)/m4/mgetgroups.m4 \
+	$(top_srcdir)/m4/mkancesdirs.m4 $(top_srcdir)/m4/mkdir-p.m4 \
+	$(top_srcdir)/m4/mkdir-slash.m4 $(top_srcdir)/m4/mkstemp.m4 \
+	$(top_srcdir)/m4/mktime.m4 $(top_srcdir)/m4/mmap-anon.m4 \
+	$(top_srcdir)/m4/mode_t.m4 $(top_srcdir)/m4/modechange.m4 \
+	$(top_srcdir)/m4/mountlist.m4 $(top_srcdir)/m4/mpsort.m4 \
+	$(top_srcdir)/m4/multiarch.m4 $(top_srcdir)/m4/nanosleep.m4 \
+	$(top_srcdir)/m4/netdb_h.m4 $(top_srcdir)/m4/netinet_in_h.m4 \
+	$(top_srcdir)/m4/nls.m4 $(top_srcdir)/m4/nocrash.m4 \
+	$(top_srcdir)/m4/open.m4 $(top_srcdir)/m4/openat.m4 \
+	$(top_srcdir)/m4/pathmax.m4 $(top_srcdir)/m4/perl.m4 \
+	$(top_srcdir)/m4/perror.m4 $(top_srcdir)/m4/physmem.m4 \
+	$(top_srcdir)/m4/po.m4 $(top_srcdir)/m4/posix-shell.m4 \
+	$(top_srcdir)/m4/posixtm.m4 $(top_srcdir)/m4/posixver.m4 \
+	$(top_srcdir)/m4/prereq.m4 $(top_srcdir)/m4/printf-frexp.m4 \
 	$(top_srcdir)/m4/printf-frexpl.m4 $(top_srcdir)/m4/printf.m4 \
 	$(top_srcdir)/m4/priv-set.m4 $(top_srcdir)/m4/progtest.m4 \
 	$(top_srcdir)/m4/putenv.m4 $(top_srcdir)/m4/quote.m4 \
@@ -267,163 +245,31 @@ am__EXEEXT_2 = chroot$(EXEEXT) df$(EXEEX
 	uptime$(EXEEXT) users$(EXEEXT) who$(EXEEXT)
 am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(pkglibdir)"
 PROGRAMS = $(bin_PROGRAMS) $(noinst_PROGRAMS) $(pkglib_PROGRAMS)
-am___OBJECTS = lbracket.$(OBJEXT)
-__OBJECTS = $(am___OBJECTS)
-am__DEPENDENCIES_1 =
-am__DEPENDENCIES_2 = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-__DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
 am_arch_OBJECTS = uname.$(OBJEXT) uname-arch.$(OBJEXT)
 arch_OBJECTS = $(am_arch_OBJECTS)
 arch_LDADD = $(LDADD)
+am__DEPENDENCIES_1 =
 arch_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
 	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-base64_SOURCES = base64.c
-base64_OBJECTS = base64.$(OBJEXT)
-base64_LDADD = $(LDADD)
-base64_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-basename_SOURCES = basename.c
-basename_OBJECTS = basename.$(OBJEXT)
-basename_LDADD = $(LDADD)
-basename_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-cat_SOURCES = cat.c
-cat_OBJECTS = cat.$(OBJEXT)
-cat_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-chcon_SOURCES = chcon.c
-chcon_OBJECTS = chcon.$(OBJEXT)
-chcon_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-am_chgrp_OBJECTS = chgrp.$(OBJEXT) chown-core.$(OBJEXT)
-chgrp_OBJECTS = $(am_chgrp_OBJECTS)
-chgrp_LDADD = $(LDADD)
-chgrp_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-chmod_SOURCES = chmod.c
-chmod_OBJECTS = chmod.$(OBJEXT)
-chmod_LDADD = $(LDADD)
-chmod_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_chown_OBJECTS = chown.$(OBJEXT) chown-core.$(OBJEXT)
-chown_OBJECTS = $(am_chown_OBJECTS)
-chown_LDADD = $(LDADD)
-chown_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
 chroot_SOURCES = chroot.c
 chroot_OBJECTS = chroot.$(OBJEXT)
 chroot_LDADD = $(LDADD)
 chroot_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
 	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-cksum_SOURCES = cksum.c
-cksum_OBJECTS = cksum.$(OBJEXT)
-cksum_LDADD = $(LDADD)
-cksum_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-comm_SOURCES = comm.c
-comm_OBJECTS = comm.$(OBJEXT)
-comm_LDADD = $(LDADD)
-comm_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am__objects_1 = copy.$(OBJEXT) cp-hash.$(OBJEXT)
+am__objects_1 = copy.$(OBJEXT) cp-hash.$(OBJEXT) mcore.$(OBJEXT)
 am_cp_OBJECTS = cp.$(OBJEXT) $(am__objects_1)
 cp_OBJECTS = $(am_cp_OBJECTS)
+am__DEPENDENCIES_2 = libver.a ../lib/libcoreutils.a \
+	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
 cp_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
-csplit_SOURCES = csplit.c
-csplit_OBJECTS = csplit.$(OBJEXT)
-csplit_LDADD = $(LDADD)
-csplit_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-cut_SOURCES = cut.c
-cut_OBJECTS = cut.$(OBJEXT)
-cut_LDADD = $(LDADD)
-cut_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-date_SOURCES = date.c
-date_OBJECTS = date.$(OBJEXT)
-date_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-dd_SOURCES = dd.c
-dd_OBJECTS = dd.$(OBJEXT)
-dd_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
 df_SOURCES = df.c
 df_OBJECTS = df.$(OBJEXT)
 df_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-am_dir_OBJECTS = ls.$(OBJEXT) ls-dir.$(OBJEXT)
-dir_OBJECTS = $(am_dir_OBJECTS)
-dir_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
-dircolors_SOURCES = dircolors.c
-dircolors_OBJECTS = dircolors.$(OBJEXT)
-dircolors_LDADD = $(LDADD)
-dircolors_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-dirname_SOURCES = dirname.c
-dirname_OBJECTS = dirname.$(OBJEXT)
-dirname_LDADD = $(LDADD)
-dirname_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-du_SOURCES = du.c
-du_OBJECTS = du.$(OBJEXT)
-du_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-echo_SOURCES = echo.c
-echo_OBJECTS = echo.$(OBJEXT)
-echo_LDADD = $(LDADD)
-echo_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-env_SOURCES = env.c
-env_OBJECTS = env.$(OBJEXT)
-env_LDADD = $(LDADD)
-env_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-expand_SOURCES = expand.c
-expand_OBJECTS = expand.$(OBJEXT)
-expand_LDADD = $(LDADD)
-expand_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-expr_SOURCES = expr.c
-expr_OBJECTS = expr.$(OBJEXT)
-expr_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-factor_SOURCES = factor.c
-factor_OBJECTS = factor.$(OBJEXT)
-factor_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-false_SOURCES = false.c
-false_OBJECTS = false.$(OBJEXT)
-false_LDADD = $(LDADD)
-false_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-fmt_SOURCES = fmt.c
-fmt_OBJECTS = fmt.$(OBJEXT)
-fmt_LDADD = $(LDADD)
-fmt_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-fold_SOURCES = fold.c
-fold_OBJECTS = fold.$(OBJEXT)
-fold_LDADD = $(LDADD)
-fold_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
 getlimits_SOURCES = getlimits.c
 getlimits_OBJECTS = getlimits.$(OBJEXT)
 getlimits_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-am__objects_2 = ginstall-copy.$(OBJEXT) ginstall-cp-hash.$(OBJEXT)
-am_ginstall_OBJECTS = ginstall-install.$(OBJEXT) \
-	ginstall-prog-fprintf.$(OBJEXT) $(am__objects_2)
-ginstall_OBJECTS = $(am_ginstall_OBJECTS)
-ginstall_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
-am_groups_OBJECTS = groups.$(OBJEXT) group-list.$(OBJEXT)
-groups_OBJECTS = $(am_groups_OBJECTS)
-groups_LDADD = $(LDADD)
-groups_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-head_SOURCES = head.c
-head_OBJECTS = head.$(OBJEXT)
-head_LDADD = $(LDADD)
-head_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
 hostid_SOURCES = hostid.c
 hostid_OBJECTS = hostid.$(OBJEXT)
 hostid_LDADD = $(LDADD)
@@ -434,188 +280,29 @@ hostname_OBJECTS = hostname.$(OBJEXT)
 hostname_LDADD = $(LDADD)
 hostname_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
 	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_id_OBJECTS = id.$(OBJEXT) group-list.$(OBJEXT)
-id_OBJECTS = $(am_id_OBJECTS)
-id_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-join_SOURCES = join.c
-join_OBJECTS = join.$(OBJEXT)
-join_LDADD = $(LDADD)
-join_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_kill_OBJECTS = kill.$(OBJEXT) operand2sig.$(OBJEXT)
-kill_OBJECTS = $(am_kill_OBJECTS)
-kill_LDADD = $(LDADD)
-kill_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
 libstdbuf_so_SOURCES = libstdbuf.c
 libstdbuf_so_OBJECTS = libstdbuf_so-libstdbuf.$(OBJEXT)
 libstdbuf_so_DEPENDENCIES =
 libstdbuf_so_LINK = $(CCLD) $(libstdbuf_so_CFLAGS) $(CFLAGS) \
 	$(libstdbuf_so_LDFLAGS) $(LDFLAGS) -o $@
-link_SOURCES = link.c
-link_OBJECTS = link.$(OBJEXT)
-link_LDADD = $(LDADD)
-link_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_ln_OBJECTS = ln.$(OBJEXT)
-ln_OBJECTS = $(am_ln_OBJECTS)
-ln_LDADD = $(LDADD)
-ln_DEPENDENCIES = libver.a ../lib/libcoreutils.a $(am__DEPENDENCIES_1) \
-	../lib/libcoreutils.a
-logname_SOURCES = logname.c
-logname_OBJECTS = logname.$(OBJEXT)
-logname_LDADD = $(LDADD)
-logname_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_ls_OBJECTS = ls.$(OBJEXT) ls-ls.$(OBJEXT)
-ls_OBJECTS = $(am_ls_OBJECTS)
-ls_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
-am_md5sum_OBJECTS = md5sum-md5sum.$(OBJEXT)
+am_md5sum_OBJECTS = md5sum-md5sum.$(OBJEXT) md5sum-mcore.$(OBJEXT)
 md5sum_OBJECTS = $(am_md5sum_OBJECTS)
 md5sum_LDADD = $(LDADD)
 md5sum_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
 	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_mkdir_OBJECTS = mkdir.$(OBJEXT) prog-fprintf.$(OBJEXT)
-mkdir_OBJECTS = $(am_mkdir_OBJECTS)
-mkdir_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-mkfifo_SOURCES = mkfifo.c
-mkfifo_OBJECTS = mkfifo.$(OBJEXT)
-mkfifo_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-mknod_SOURCES = mknod.c
-mknod_OBJECTS = mknod.$(OBJEXT)
-mknod_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-mktemp_SOURCES = mktemp.c
-mktemp_OBJECTS = mktemp.$(OBJEXT)
-mktemp_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-am_mv_OBJECTS = mv.$(OBJEXT) remove.$(OBJEXT) $(am__objects_1)
-mv_OBJECTS = $(am_mv_OBJECTS)
-mv_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
 nice_SOURCES = nice.c
 nice_OBJECTS = nice.$(OBJEXT)
 nice_LDADD = $(LDADD)
 nice_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
 	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-nl_SOURCES = nl.c
-nl_OBJECTS = nl.$(OBJEXT)
-nl_LDADD = $(LDADD)
-nl_DEPENDENCIES = libver.a ../lib/libcoreutils.a $(am__DEPENDENCIES_1) \
-	../lib/libcoreutils.a
-nohup_SOURCES = nohup.c
-nohup_OBJECTS = nohup.$(OBJEXT)
-nohup_LDADD = $(LDADD)
-nohup_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-od_SOURCES = od.c
-od_OBJECTS = od.$(OBJEXT)
-od_LDADD = $(LDADD)
-od_DEPENDENCIES = libver.a ../lib/libcoreutils.a $(am__DEPENDENCIES_1) \
-	../lib/libcoreutils.a
-paste_SOURCES = paste.c
-paste_OBJECTS = paste.$(OBJEXT)
-paste_LDADD = $(LDADD)
-paste_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-pathchk_SOURCES = pathchk.c
-pathchk_OBJECTS = pathchk.$(OBJEXT)
-pathchk_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
 pinky_SOURCES = pinky.c
 pinky_OBJECTS = pinky.$(OBJEXT)
 pinky_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-pr_SOURCES = pr.c
-pr_OBJECTS = pr.$(OBJEXT)
-pr_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-printenv_SOURCES = printenv.c
-printenv_OBJECTS = printenv.$(OBJEXT)
-printenv_LDADD = $(LDADD)
-printenv_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-printf_SOURCES = printf.c
-printf_OBJECTS = printf.$(OBJEXT)
-printf_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
-ptx_SOURCES = ptx.c
-ptx_OBJECTS = ptx.$(OBJEXT)
-ptx_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-pwd_SOURCES = pwd.c
-pwd_OBJECTS = pwd.$(OBJEXT)
-pwd_LDADD = $(LDADD)
-pwd_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-readlink_SOURCES = readlink.c
-readlink_OBJECTS = readlink.$(OBJEXT)
-readlink_LDADD = $(LDADD)
-readlink_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_rm_OBJECTS = rm.$(OBJEXT) remove.$(OBJEXT)
-rm_OBJECTS = $(am_rm_OBJECTS)
-rm_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-am_rmdir_OBJECTS = rmdir.$(OBJEXT) prog-fprintf.$(OBJEXT)
-rmdir_OBJECTS = $(am_rmdir_OBJECTS)
-rmdir_LDADD = $(LDADD)
-rmdir_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-runcon_SOURCES = runcon.c
-runcon_OBJECTS = runcon.$(OBJEXT)
-runcon_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-seq_SOURCES = seq.c
-seq_OBJECTS = seq.$(OBJEXT)
-seq_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
 setuidgid_SOURCES = setuidgid.c
 setuidgid_OBJECTS = setuidgid.$(OBJEXT)
 setuidgid_LDADD = $(LDADD)
 setuidgid_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
 	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_sha1sum_OBJECTS = sha1sum-md5sum.$(OBJEXT)
-sha1sum_OBJECTS = $(am_sha1sum_OBJECTS)
-sha1sum_LDADD = $(LDADD)
-sha1sum_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_sha224sum_OBJECTS = sha224sum-md5sum.$(OBJEXT)
-sha224sum_OBJECTS = $(am_sha224sum_OBJECTS)
-sha224sum_LDADD = $(LDADD)
-sha224sum_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_sha256sum_OBJECTS = sha256sum-md5sum.$(OBJEXT)
-sha256sum_OBJECTS = $(am_sha256sum_OBJECTS)
-sha256sum_LDADD = $(LDADD)
-sha256sum_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_sha384sum_OBJECTS = sha384sum-md5sum.$(OBJEXT)
-sha384sum_OBJECTS = $(am_sha384sum_OBJECTS)
-sha384sum_LDADD = $(LDADD)
-sha384sum_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_sha512sum_OBJECTS = sha512sum-md5sum.$(OBJEXT)
-sha512sum_OBJECTS = $(am_sha512sum_OBJECTS)
-sha512sum_LDADD = $(LDADD)
-sha512sum_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-shred_SOURCES = shred.c
-shred_OBJECTS = shred.$(OBJEXT)
-shred_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
-shuf_SOURCES = shuf.c
-shuf_OBJECTS = shuf.$(OBJEXT)
-shuf_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-sleep_SOURCES = sleep.c
-sleep_OBJECTS = sleep.$(OBJEXT)
-am__DEPENDENCIES_3 = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
-sleep_DEPENDENCIES = $(am__DEPENDENCIES_3)
-sort_SOURCES = sort.c
-sort_OBJECTS = sort.$(OBJEXT)
-sort_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
-split_SOURCES = split.c
-split_OBJECTS = split.$(OBJEXT)
-split_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-stat_SOURCES = stat.c
-stat_OBJECTS = stat.$(OBJEXT)
-stat_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
 stdbuf_SOURCES = stdbuf.c
 stdbuf_OBJECTS = stdbuf.$(OBJEXT)
 stdbuf_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
@@ -627,79 +314,11 @@ stty_DEPENDENCIES = libver.a ../lib/libc
 su_SOURCES = su.c
 su_OBJECTS = su.$(OBJEXT)
 su_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-sum_SOURCES = sum.c
-sum_OBJECTS = sum.$(OBJEXT)
-sum_LDADD = $(LDADD)
-sum_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-sync_SOURCES = sync.c
-sync_OBJECTS = sync.$(OBJEXT)
-sync_LDADD = $(LDADD)
-sync_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-tac_SOURCES = tac.c
-tac_OBJECTS = tac.$(OBJEXT)
-tac_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-tail_SOURCES = tail.c
-tail_OBJECTS = tail.$(OBJEXT)
-tail_DEPENDENCIES = $(am__DEPENDENCIES_3)
-tee_SOURCES = tee.c
-tee_OBJECTS = tee.$(OBJEXT)
-tee_LDADD = $(LDADD)
-tee_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-test_SOURCES = test.c
-test_OBJECTS = test.$(OBJEXT)
-test_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-am_timeout_OBJECTS = timeout.$(OBJEXT) operand2sig.$(OBJEXT)
-timeout_OBJECTS = $(am_timeout_OBJECTS)
-timeout_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-touch_SOURCES = touch.c
-touch_OBJECTS = touch.$(OBJEXT)
-touch_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-tr_SOURCES = tr.c
-tr_OBJECTS = tr.$(OBJEXT)
-tr_LDADD = $(LDADD)
-tr_DEPENDENCIES = libver.a ../lib/libcoreutils.a $(am__DEPENDENCIES_1) \
-	../lib/libcoreutils.a
-true_SOURCES = true.c
-true_OBJECTS = true.$(OBJEXT)
-true_LDADD = $(LDADD)
-true_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-truncate_SOURCES = truncate.c
-truncate_OBJECTS = truncate.$(OBJEXT)
-truncate_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-tsort_SOURCES = tsort.c
-tsort_OBJECTS = tsort.$(OBJEXT)
-tsort_LDADD = $(LDADD)
-tsort_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-tty_SOURCES = tty.c
-tty_OBJECTS = tty.$(OBJEXT)
-tty_LDADD = $(LDADD)
-tty_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
 am_uname_OBJECTS = uname.$(OBJEXT) uname-uname.$(OBJEXT)
 uname_OBJECTS = $(am_uname_OBJECTS)
 uname_LDADD = $(LDADD)
 uname_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
 	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-unexpand_SOURCES = unexpand.c
-unexpand_OBJECTS = unexpand.$(OBJEXT)
-unexpand_LDADD = $(LDADD)
-unexpand_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-uniq_SOURCES = uniq.c
-uniq_OBJECTS = uniq.$(OBJEXT)
-uniq_LDADD = $(LDADD)
-uniq_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-unlink_SOURCES = unlink.c
-unlink_OBJECTS = unlink.$(OBJEXT)
-unlink_LDADD = $(LDADD)
-unlink_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
 uptime_SOURCES = uptime.c
 uptime_OBJECTS = uptime.$(OBJEXT)
 uptime_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
@@ -709,29 +328,9 @@ users_OBJECTS = users.$(OBJEXT)
 users_LDADD = $(LDADD)
 users_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
 	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-am_vdir_OBJECTS = ls.$(OBJEXT) ls-vdir.$(OBJEXT)
-vdir_OBJECTS = $(am_vdir_OBJECTS)
-vdir_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1)
-wc_SOURCES = wc.c
-wc_OBJECTS = wc.$(OBJEXT)
-wc_LDADD = $(LDADD)
-wc_DEPENDENCIES = libver.a ../lib/libcoreutils.a $(am__DEPENDENCIES_1) \
-	../lib/libcoreutils.a
 who_SOURCES = who.c
 who_OBJECTS = who.$(OBJEXT)
 who_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1)
-whoami_SOURCES = whoami.c
-whoami_OBJECTS = whoami.$(OBJEXT)
-whoami_LDADD = $(LDADD)
-whoami_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
-yes_SOURCES = yes.c
-yes_OBJECTS = yes.$(OBJEXT)
-yes_LDADD = $(LDADD)
-yes_DEPENDENCIES = libver.a ../lib/libcoreutils.a \
-	$(am__DEPENDENCIES_1) ../lib/libcoreutils.a
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)/lib
 depcomp = $(SHELL) $(top_srcdir)/build-aux/depcomp
 am__depfiles_maybe = depfiles
@@ -752,47 +351,19 @@ am__v_CCLD_0 = @echo "  CCLD  " $@;
 AM_V_GEN = $(am__v_GEN_$(V))
 am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
 am__v_GEN_0 = @echo "  GEN   " $@;
-SOURCES = $(nodist_libver_a_SOURCES) $(__SOURCES) $(arch_SOURCES) \
-	base64.c basename.c cat.c chcon.c $(chgrp_SOURCES) chmod.c \
-	$(chown_SOURCES) chroot.c cksum.c comm.c $(cp_SOURCES) \
-	csplit.c cut.c date.c dd.c df.c $(dir_SOURCES) dircolors.c \
-	dirname.c du.c echo.c env.c expand.c expr.c factor.c false.c \
-	fmt.c fold.c getlimits.c $(ginstall_SOURCES) $(groups_SOURCES) \
-	head.c hostid.c hostname.c $(id_SOURCES) join.c \
-	$(kill_SOURCES) libstdbuf.c link.c $(ln_SOURCES) logname.c \
-	$(ls_SOURCES) $(md5sum_SOURCES) $(mkdir_SOURCES) mkfifo.c \
-	mknod.c mktemp.c $(mv_SOURCES) nice.c nl.c nohup.c od.c \
-	paste.c pathchk.c pinky.c pr.c printenv.c printf.c ptx.c pwd.c \
-	readlink.c $(rm_SOURCES) $(rmdir_SOURCES) runcon.c seq.c \
-	setuidgid.c $(sha1sum_SOURCES) $(sha224sum_SOURCES) \
-	$(sha256sum_SOURCES) $(sha384sum_SOURCES) $(sha512sum_SOURCES) \
-	shred.c shuf.c sleep.c sort.c split.c stat.c stdbuf.c stty.c \
-	su.c sum.c sync.c tac.c tail.c tee.c test.c $(timeout_SOURCES) \
-	touch.c tr.c true.c truncate.c tsort.c tty.c $(uname_SOURCES) \
-	unexpand.c uniq.c unlink.c uptime.c users.c $(vdir_SOURCES) \
-	wc.c who.c whoami.c yes.c
-DIST_SOURCES = $(__SOURCES) $(arch_SOURCES) base64.c basename.c cat.c \
-	chcon.c $(chgrp_SOURCES) chmod.c $(chown_SOURCES) chroot.c \
-	cksum.c comm.c $(cp_SOURCES) csplit.c cut.c date.c dd.c df.c \
-	$(dir_SOURCES) dircolors.c dirname.c du.c echo.c env.c \
-	expand.c expr.c factor.c false.c fmt.c fold.c getlimits.c \
-	$(ginstall_SOURCES) $(groups_SOURCES) head.c hostid.c \
-	hostname.c $(id_SOURCES) join.c $(kill_SOURCES) libstdbuf.c \
-	link.c $(ln_SOURCES) logname.c $(ls_SOURCES) $(md5sum_SOURCES) \
-	$(mkdir_SOURCES) mkfifo.c mknod.c mktemp.c $(mv_SOURCES) \
-	nice.c nl.c nohup.c od.c paste.c pathchk.c pinky.c pr.c \
-	printenv.c printf.c ptx.c pwd.c readlink.c $(rm_SOURCES) \
-	$(rmdir_SOURCES) runcon.c seq.c setuidgid.c $(sha1sum_SOURCES) \
-	$(sha224sum_SOURCES) $(sha256sum_SOURCES) $(sha384sum_SOURCES) \
-	$(sha512sum_SOURCES) shred.c shuf.c sleep.c sort.c split.c \
-	stat.c stdbuf.c stty.c su.c sum.c sync.c tac.c tail.c tee.c \
-	test.c $(timeout_SOURCES) touch.c tr.c true.c truncate.c \
-	tsort.c tty.c $(uname_SOURCES) unexpand.c uniq.c unlink.c \
-	uptime.c users.c $(vdir_SOURCES) wc.c who.c whoami.c yes.c
+SOURCES = $(nodist_libver_a_SOURCES) $(arch_SOURCES) chroot.c \
+	$(cp_SOURCES) df.c getlimits.c hostid.c hostname.c libstdbuf.c \
+	$(md5sum_SOURCES) nice.c pinky.c setuidgid.c stdbuf.c stty.c \
+	su.c $(uname_SOURCES) uptime.c users.c who.c
+DIST_SOURCES = $(arch_SOURCES) chroot.c $(cp_SOURCES) df.c getlimits.c \
+	hostid.c hostname.c libstdbuf.c $(md5sum_SOURCES) nice.c \
+	pinky.c setuidgid.c stdbuf.c stty.c su.c $(uname_SOURCES) \
+	uptime.c users.c who.c
 HEADERS = $(noinst_HEADERS)
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+# < PZK
 
 # Use `ginstall' in the definition of PROGRAMS and in dependencies to avoid
 # confusion with the `install' target.  The install rule transforms `ginstall'
@@ -1305,6 +876,7 @@ NEXT_WCHAR_H = @NEXT_WCHAR_H@
 NEXT_WCTYPE_H = @NEXT_WCTYPE_H@
 NO_INSTALL_PROGS_DEFAULT = @NO_INSTALL_PROGS_DEFAULT@
 OBJEXT = @OBJEXT@
+OPENMP_CFLAGS = @OPENMP_CFLAGS@
 OPTIONAL_BIN_PROGS = @OPTIONAL_BIN_PROGS@
 OPTIONAL_PKGLIB_PROGS = @OPTIONAL_PKGLIB_PROGS@
 PACKAGE = @PACKAGE@
@@ -1529,9 +1101,12 @@ no_install__progs = \
 build_if_possible__progs = \
   chroot df hostid nice pinky stdbuf libstdbuf.so stty su uname uptime users who
 
-AM_CFLAGS = $(WARN_CFLAGS) $(WERROR_CFLAGS)
+AM_CFLAGS = $(WARN_CFLAGS) $(WERROR_CFLAGS) $(OPENMP_CFLAGS)
+# < PZK
 bin_PROGRAMS = $(OPTIONAL_BIN_PROGS)
 pkglib_PROGRAMS = $(OPTIONAL_PKGLIB_PROGS)
+
+# PZK >
 noinst_HEADERS = \
   chown-core.h \
   copy.h \
@@ -1540,6 +1115,7 @@ noinst_HEADERS = \
   fs.h \
   group-list.h \
   ls.h \
+  mcore.h \
   operand2sig.h \
   prog-fprintf.h \
   remove.h \
@@ -1548,6 +1124,7 @@ noinst_HEADERS = \
   wheel.h \
   uname.h
 
+# < PZK
 EXTRA_DIST = dcgen dircolors.hin tac-pipe.c \
   wheel-gen.pl extract-magic c99-to-c89.diff
 
@@ -1665,7 +1242,9 @@ install_su = \
     :;							\
   fi
 
-copy_sources = copy.c cp-hash.c
+
+# PZK >
+copy_sources = copy.c cp-hash.c mcore.c
 ginstall_SOURCES = install.c prog-fprintf.c $(copy_sources)
 
 # This is for the '[' program.  Automake transliterates '[' to '_'.
@@ -1687,7 +1266,10 @@ mkdir_SOURCES = mkdir.c prog-fprintf.c
 rmdir_SOURCES = rmdir.c prog-fprintf.c
 uname_SOURCES = uname.c uname-uname.c
 arch_SOURCES = uname.c uname-arch.c
-md5sum_SOURCES = md5sum.c
+
+# PZK >
+md5sum_SOURCES = md5sum.c mcore.c
+# < PZK
 md5sum_CPPFLAGS = -DHASH_ALGO_MD5=1 $(AM_CPPFLAGS)
 sha1sum_SOURCES = md5sum.c
 sha1sum_CPPFLAGS = -DHASH_ALGO_SHA1=1 $(AM_CPPFLAGS)
@@ -1819,7 +1401,7 @@ uninstall-binPROGRAMS:
 	cd "$(DESTDIR)$(bindir)" && rm -f $$files
 
 clean-binPROGRAMS:
-	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS) > /dev/null 2>&1 || /bin/rm -f $(bin_PROGRAMS)
+	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
 
 clean-noinstPROGRAMS:
 	-test -z "$(noinst_PROGRAMS)" || rm -f $(noinst_PROGRAMS)
@@ -1860,243 +1442,42 @@ uninstall-pkglibPROGRAMS:
 
 clean-pkglibPROGRAMS:
 	-test -z "$(pkglib_PROGRAMS)" || rm -f $(pkglib_PROGRAMS)
-[$(EXEEXT): $(__OBJECTS) $(__DEPENDENCIES) 
-	@rm -f [$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(__OBJECTS) $(__LDADD) $(LIBS)
 arch$(EXEEXT): $(arch_OBJECTS) $(arch_DEPENDENCIES) 
 	@rm -f arch$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(arch_OBJECTS) $(arch_LDADD) $(LIBS)
-base64$(EXEEXT): $(base64_OBJECTS) $(base64_DEPENDENCIES) 
-	@rm -f base64$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(base64_OBJECTS) $(base64_LDADD) $(LIBS)
-basename$(EXEEXT): $(basename_OBJECTS) $(basename_DEPENDENCIES) 
-	@rm -f basename$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(basename_OBJECTS) $(basename_LDADD) $(LIBS)
-cat$(EXEEXT): $(cat_OBJECTS) $(cat_DEPENDENCIES) 
-	@rm -f cat$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(cat_OBJECTS) $(cat_LDADD) $(LIBS)
-chcon$(EXEEXT): $(chcon_OBJECTS) $(chcon_DEPENDENCIES) 
-	@rm -f chcon$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(chcon_OBJECTS) $(chcon_LDADD) $(LIBS)
-chgrp$(EXEEXT): $(chgrp_OBJECTS) $(chgrp_DEPENDENCIES) 
-	@rm -f chgrp$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(chgrp_OBJECTS) $(chgrp_LDADD) $(LIBS)
-chmod$(EXEEXT): $(chmod_OBJECTS) $(chmod_DEPENDENCIES) 
-	@rm -f chmod$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(chmod_OBJECTS) $(chmod_LDADD) $(LIBS)
-chown$(EXEEXT): $(chown_OBJECTS) $(chown_DEPENDENCIES) 
-	@rm -f chown$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(chown_OBJECTS) $(chown_LDADD) $(LIBS)
 chroot$(EXEEXT): $(chroot_OBJECTS) $(chroot_DEPENDENCIES) 
 	@rm -f chroot$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(chroot_OBJECTS) $(chroot_LDADD) $(LIBS)
-cksum$(EXEEXT): $(cksum_OBJECTS) $(cksum_DEPENDENCIES) 
-	@rm -f cksum$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(cksum_OBJECTS) $(cksum_LDADD) $(LIBS)
-comm$(EXEEXT): $(comm_OBJECTS) $(comm_DEPENDENCIES) 
-	@rm -f comm$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(comm_OBJECTS) $(comm_LDADD) $(LIBS)
 cp$(EXEEXT): $(cp_OBJECTS) $(cp_DEPENDENCIES) 
 	@rm -f cp$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(cp_OBJECTS) $(cp_LDADD) $(LIBS)
-csplit$(EXEEXT): $(csplit_OBJECTS) $(csplit_DEPENDENCIES) 
-	@rm -f csplit$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(csplit_OBJECTS) $(csplit_LDADD) $(LIBS)
-cut$(EXEEXT): $(cut_OBJECTS) $(cut_DEPENDENCIES) 
-	@rm -f cut$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(cut_OBJECTS) $(cut_LDADD) $(LIBS)
-date$(EXEEXT): $(date_OBJECTS) $(date_DEPENDENCIES) 
-	@rm -f date$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(date_OBJECTS) $(date_LDADD) $(LIBS)
-dd$(EXEEXT): $(dd_OBJECTS) $(dd_DEPENDENCIES) 
-	@rm -f dd$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(dd_OBJECTS) $(dd_LDADD) $(LIBS)
 df$(EXEEXT): $(df_OBJECTS) $(df_DEPENDENCIES) 
 	@rm -f df$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(df_OBJECTS) $(df_LDADD) $(LIBS)
-dir$(EXEEXT): $(dir_OBJECTS) $(dir_DEPENDENCIES) 
-	@rm -f dir$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(dir_OBJECTS) $(dir_LDADD) $(LIBS)
-dircolors$(EXEEXT): $(dircolors_OBJECTS) $(dircolors_DEPENDENCIES) 
-	@rm -f dircolors$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(dircolors_OBJECTS) $(dircolors_LDADD) $(LIBS)
-dirname$(EXEEXT): $(dirname_OBJECTS) $(dirname_DEPENDENCIES) 
-	@rm -f dirname$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(dirname_OBJECTS) $(dirname_LDADD) $(LIBS)
-du$(EXEEXT): $(du_OBJECTS) $(du_DEPENDENCIES) 
-	@rm -f du$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(du_OBJECTS) $(du_LDADD) $(LIBS)
-echo$(EXEEXT): $(echo_OBJECTS) $(echo_DEPENDENCIES) 
-	@rm -f echo$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(echo_OBJECTS) $(echo_LDADD) $(LIBS)
-env$(EXEEXT): $(env_OBJECTS) $(env_DEPENDENCIES) 
-	@rm -f env$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(env_OBJECTS) $(env_LDADD) $(LIBS)
-expand$(EXEEXT): $(expand_OBJECTS) $(expand_DEPENDENCIES) 
-	@rm -f expand$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(expand_OBJECTS) $(expand_LDADD) $(LIBS)
-expr$(EXEEXT): $(expr_OBJECTS) $(expr_DEPENDENCIES) 
-	@rm -f expr$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(expr_OBJECTS) $(expr_LDADD) $(LIBS)
-factor$(EXEEXT): $(factor_OBJECTS) $(factor_DEPENDENCIES) 
-	@rm -f factor$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(factor_OBJECTS) $(factor_LDADD) $(LIBS)
-false$(EXEEXT): $(false_OBJECTS) $(false_DEPENDENCIES) 
-	@rm -f false$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(false_OBJECTS) $(false_LDADD) $(LIBS)
-fmt$(EXEEXT): $(fmt_OBJECTS) $(fmt_DEPENDENCIES) 
-	@rm -f fmt$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(fmt_OBJECTS) $(fmt_LDADD) $(LIBS)
-fold$(EXEEXT): $(fold_OBJECTS) $(fold_DEPENDENCIES) 
-	@rm -f fold$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(fold_OBJECTS) $(fold_LDADD) $(LIBS)
 getlimits$(EXEEXT): $(getlimits_OBJECTS) $(getlimits_DEPENDENCIES) 
 	@rm -f getlimits$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(getlimits_OBJECTS) $(getlimits_LDADD) $(LIBS)
-ginstall$(EXEEXT): $(ginstall_OBJECTS) $(ginstall_DEPENDENCIES) 
-	@rm -f ginstall$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(ginstall_OBJECTS) $(ginstall_LDADD) $(LIBS)
-groups$(EXEEXT): $(groups_OBJECTS) $(groups_DEPENDENCIES) 
-	@rm -f groups$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(groups_OBJECTS) $(groups_LDADD) $(LIBS)
-head$(EXEEXT): $(head_OBJECTS) $(head_DEPENDENCIES) 
-	@rm -f head$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(head_OBJECTS) $(head_LDADD) $(LIBS)
 hostid$(EXEEXT): $(hostid_OBJECTS) $(hostid_DEPENDENCIES) 
 	@rm -f hostid$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(hostid_OBJECTS) $(hostid_LDADD) $(LIBS)
 hostname$(EXEEXT): $(hostname_OBJECTS) $(hostname_DEPENDENCIES) 
 	@rm -f hostname$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(hostname_OBJECTS) $(hostname_LDADD) $(LIBS)
-id$(EXEEXT): $(id_OBJECTS) $(id_DEPENDENCIES) 
-	@rm -f id$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(id_OBJECTS) $(id_LDADD) $(LIBS)
-join$(EXEEXT): $(join_OBJECTS) $(join_DEPENDENCIES) 
-	@rm -f join$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(join_OBJECTS) $(join_LDADD) $(LIBS)
-kill$(EXEEXT): $(kill_OBJECTS) $(kill_DEPENDENCIES) 
-	@rm -f kill$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(kill_OBJECTS) $(kill_LDADD) $(LIBS)
 libstdbuf.so$(EXEEXT): $(libstdbuf_so_OBJECTS) $(libstdbuf_so_DEPENDENCIES) 
 	@rm -f libstdbuf.so$(EXEEXT)
 	$(AM_V_CCLD)$(libstdbuf_so_LINK) $(libstdbuf_so_OBJECTS) $(libstdbuf_so_LDADD) $(LIBS)
-link$(EXEEXT): $(link_OBJECTS) $(link_DEPENDENCIES) 
-	@rm -f link$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(link_OBJECTS) $(link_LDADD) $(LIBS)
-ln$(EXEEXT): $(ln_OBJECTS) $(ln_DEPENDENCIES) 
-	@rm -f ln$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(ln_OBJECTS) $(ln_LDADD) $(LIBS)
-logname$(EXEEXT): $(logname_OBJECTS) $(logname_DEPENDENCIES) 
-	@rm -f logname$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(logname_OBJECTS) $(logname_LDADD) $(LIBS)
-ls$(EXEEXT): $(ls_OBJECTS) $(ls_DEPENDENCIES) 
-	@rm -f ls$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(ls_OBJECTS) $(ls_LDADD) $(LIBS)
 md5sum$(EXEEXT): $(md5sum_OBJECTS) $(md5sum_DEPENDENCIES) 
 	@rm -f md5sum$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(md5sum_OBJECTS) $(md5sum_LDADD) $(LIBS)
-mkdir$(EXEEXT): $(mkdir_OBJECTS) $(mkdir_DEPENDENCIES) 
-	@rm -f mkdir$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(mkdir_OBJECTS) $(mkdir_LDADD) $(LIBS)
-mkfifo$(EXEEXT): $(mkfifo_OBJECTS) $(mkfifo_DEPENDENCIES) 
-	@rm -f mkfifo$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(mkfifo_OBJECTS) $(mkfifo_LDADD) $(LIBS)
-mknod$(EXEEXT): $(mknod_OBJECTS) $(mknod_DEPENDENCIES) 
-	@rm -f mknod$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(mknod_OBJECTS) $(mknod_LDADD) $(LIBS)
-mktemp$(EXEEXT): $(mktemp_OBJECTS) $(mktemp_DEPENDENCIES) 
-	@rm -f mktemp$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(mktemp_OBJECTS) $(mktemp_LDADD) $(LIBS)
-mv$(EXEEXT): $(mv_OBJECTS) $(mv_DEPENDENCIES) 
-	@rm -f mv$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(mv_OBJECTS) $(mv_LDADD) $(LIBS)
 nice$(EXEEXT): $(nice_OBJECTS) $(nice_DEPENDENCIES) 
 	@rm -f nice$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(nice_OBJECTS) $(nice_LDADD) $(LIBS)
-nl$(EXEEXT): $(nl_OBJECTS) $(nl_DEPENDENCIES) 
-	@rm -f nl$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(nl_OBJECTS) $(nl_LDADD) $(LIBS)
-nohup$(EXEEXT): $(nohup_OBJECTS) $(nohup_DEPENDENCIES) 
-	@rm -f nohup$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(nohup_OBJECTS) $(nohup_LDADD) $(LIBS)
-od$(EXEEXT): $(od_OBJECTS) $(od_DEPENDENCIES) 
-	@rm -f od$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(od_OBJECTS) $(od_LDADD) $(LIBS)
-paste$(EXEEXT): $(paste_OBJECTS) $(paste_DEPENDENCIES) 
-	@rm -f paste$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(paste_OBJECTS) $(paste_LDADD) $(LIBS)
-pathchk$(EXEEXT): $(pathchk_OBJECTS) $(pathchk_DEPENDENCIES) 
-	@rm -f pathchk$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(pathchk_OBJECTS) $(pathchk_LDADD) $(LIBS)
 pinky$(EXEEXT): $(pinky_OBJECTS) $(pinky_DEPENDENCIES) 
 	@rm -f pinky$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(pinky_OBJECTS) $(pinky_LDADD) $(LIBS)
-pr$(EXEEXT): $(pr_OBJECTS) $(pr_DEPENDENCIES) 
-	@rm -f pr$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(pr_OBJECTS) $(pr_LDADD) $(LIBS)
-printenv$(EXEEXT): $(printenv_OBJECTS) $(printenv_DEPENDENCIES) 
-	@rm -f printenv$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(printenv_OBJECTS) $(printenv_LDADD) $(LIBS)
-printf$(EXEEXT): $(printf_OBJECTS) $(printf_DEPENDENCIES) 
-	@rm -f printf$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(printf_OBJECTS) $(printf_LDADD) $(LIBS)
-ptx$(EXEEXT): $(ptx_OBJECTS) $(ptx_DEPENDENCIES) 
-	@rm -f ptx$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(ptx_OBJECTS) $(ptx_LDADD) $(LIBS)
-pwd$(EXEEXT): $(pwd_OBJECTS) $(pwd_DEPENDENCIES) 
-	@rm -f pwd$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(pwd_OBJECTS) $(pwd_LDADD) $(LIBS)
-readlink$(EXEEXT): $(readlink_OBJECTS) $(readlink_DEPENDENCIES) 
-	@rm -f readlink$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(readlink_OBJECTS) $(readlink_LDADD) $(LIBS)
-rm$(EXEEXT): $(rm_OBJECTS) $(rm_DEPENDENCIES) 
-	@rm -f rm > /dev/null 2>&1 || /bin/rm -f rm$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(rm_OBJECTS) $(rm_LDADD) $(LIBS)
-rmdir$(EXEEXT): $(rmdir_OBJECTS) $(rmdir_DEPENDENCIES) 
-	@rm -f rmdir$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(rmdir_OBJECTS) $(rmdir_LDADD) $(LIBS)
-runcon$(EXEEXT): $(runcon_OBJECTS) $(runcon_DEPENDENCIES) 
-	@rm -f runcon$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(runcon_OBJECTS) $(runcon_LDADD) $(LIBS)
-seq$(EXEEXT): $(seq_OBJECTS) $(seq_DEPENDENCIES) 
-	@rm -f seq$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(seq_OBJECTS) $(seq_LDADD) $(LIBS)
 setuidgid$(EXEEXT): $(setuidgid_OBJECTS) $(setuidgid_DEPENDENCIES) 
 	@rm -f setuidgid$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(setuidgid_OBJECTS) $(setuidgid_LDADD) $(LIBS)
-sha1sum$(EXEEXT): $(sha1sum_OBJECTS) $(sha1sum_DEPENDENCIES) 
-	@rm -f sha1sum$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(sha1sum_OBJECTS) $(sha1sum_LDADD) $(LIBS)
-sha224sum$(EXEEXT): $(sha224sum_OBJECTS) $(sha224sum_DEPENDENCIES) 
-	@rm -f sha224sum$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(sha224sum_OBJECTS) $(sha224sum_LDADD) $(LIBS)
-sha256sum$(EXEEXT): $(sha256sum_OBJECTS) $(sha256sum_DEPENDENCIES) 
-	@rm -f sha256sum$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(sha256sum_OBJECTS) $(sha256sum_LDADD) $(LIBS)
-sha384sum$(EXEEXT): $(sha384sum_OBJECTS) $(sha384sum_DEPENDENCIES) 
-	@rm -f sha384sum$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(sha384sum_OBJECTS) $(sha384sum_LDADD) $(LIBS)
-sha512sum$(EXEEXT): $(sha512sum_OBJECTS) $(sha512sum_DEPENDENCIES) 
-	@rm -f sha512sum$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(sha512sum_OBJECTS) $(sha512sum_LDADD) $(LIBS)
-shred$(EXEEXT): $(shred_OBJECTS) $(shred_DEPENDENCIES) 
-	@rm -f shred$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(shred_OBJECTS) $(shred_LDADD) $(LIBS)
-shuf$(EXEEXT): $(shuf_OBJECTS) $(shuf_DEPENDENCIES) 
-	@rm -f shuf$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(shuf_OBJECTS) $(shuf_LDADD) $(LIBS)
-sleep$(EXEEXT): $(sleep_OBJECTS) $(sleep_DEPENDENCIES) 
-	@rm -f sleep$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(sleep_OBJECTS) $(sleep_LDADD) $(LIBS)
-sort$(EXEEXT): $(sort_OBJECTS) $(sort_DEPENDENCIES) 
-	@rm -f sort$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(sort_OBJECTS) $(sort_LDADD) $(LIBS)
-split$(EXEEXT): $(split_OBJECTS) $(split_DEPENDENCIES) 
-	@rm -f split$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(split_OBJECTS) $(split_LDADD) $(LIBS)
-stat$(EXEEXT): $(stat_OBJECTS) $(stat_DEPENDENCIES) 
-	@rm -f stat$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(stat_OBJECTS) $(stat_LDADD) $(LIBS)
 stdbuf$(EXEEXT): $(stdbuf_OBJECTS) $(stdbuf_DEPENDENCIES) 
 	@rm -f stdbuf$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(stdbuf_OBJECTS) $(stdbuf_LDADD) $(LIBS)
@@ -2106,78 +1487,18 @@ stty$(EXEEXT): $(stty_OBJECTS) $(stty_DE
 su$(EXEEXT): $(su_OBJECTS) $(su_DEPENDENCIES) 
 	@rm -f su$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(su_OBJECTS) $(su_LDADD) $(LIBS)
-sum$(EXEEXT): $(sum_OBJECTS) $(sum_DEPENDENCIES) 
-	@rm -f sum$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(sum_OBJECTS) $(sum_LDADD) $(LIBS)
-sync$(EXEEXT): $(sync_OBJECTS) $(sync_DEPENDENCIES) 
-	@rm -f sync$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(sync_OBJECTS) $(sync_LDADD) $(LIBS)
-tac$(EXEEXT): $(tac_OBJECTS) $(tac_DEPENDENCIES) 
-	@rm -f tac$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(tac_OBJECTS) $(tac_LDADD) $(LIBS)
-tail$(EXEEXT): $(tail_OBJECTS) $(tail_DEPENDENCIES) 
-	@rm -f tail$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(tail_OBJECTS) $(tail_LDADD) $(LIBS)
-tee$(EXEEXT): $(tee_OBJECTS) $(tee_DEPENDENCIES) 
-	@rm -f tee$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(tee_OBJECTS) $(tee_LDADD) $(LIBS)
-test$(EXEEXT): $(test_OBJECTS) $(test_DEPENDENCIES) 
-	@rm -f test$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(test_OBJECTS) $(test_LDADD) $(LIBS)
-timeout$(EXEEXT): $(timeout_OBJECTS) $(timeout_DEPENDENCIES) 
-	@rm -f timeout$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(timeout_OBJECTS) $(timeout_LDADD) $(LIBS)
-touch$(EXEEXT): $(touch_OBJECTS) $(touch_DEPENDENCIES) 
-	@rm -f touch$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(touch_OBJECTS) $(touch_LDADD) $(LIBS)
-tr$(EXEEXT): $(tr_OBJECTS) $(tr_DEPENDENCIES) 
-	@rm -f tr$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(tr_OBJECTS) $(tr_LDADD) $(LIBS)
-true$(EXEEXT): $(true_OBJECTS) $(true_DEPENDENCIES) 
-	@rm -f true$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(true_OBJECTS) $(true_LDADD) $(LIBS)
-truncate$(EXEEXT): $(truncate_OBJECTS) $(truncate_DEPENDENCIES) 
-	@rm -f truncate$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(truncate_OBJECTS) $(truncate_LDADD) $(LIBS)
-tsort$(EXEEXT): $(tsort_OBJECTS) $(tsort_DEPENDENCIES) 
-	@rm -f tsort$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(tsort_OBJECTS) $(tsort_LDADD) $(LIBS)
-tty$(EXEEXT): $(tty_OBJECTS) $(tty_DEPENDENCIES) 
-	@rm -f tty$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(tty_OBJECTS) $(tty_LDADD) $(LIBS)
 uname$(EXEEXT): $(uname_OBJECTS) $(uname_DEPENDENCIES) 
 	@rm -f uname$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(uname_OBJECTS) $(uname_LDADD) $(LIBS)
-unexpand$(EXEEXT): $(unexpand_OBJECTS) $(unexpand_DEPENDENCIES) 
-	@rm -f unexpand$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(unexpand_OBJECTS) $(unexpand_LDADD) $(LIBS)
-uniq$(EXEEXT): $(uniq_OBJECTS) $(uniq_DEPENDENCIES) 
-	@rm -f uniq$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(uniq_OBJECTS) $(uniq_LDADD) $(LIBS)
-unlink$(EXEEXT): $(unlink_OBJECTS) $(unlink_DEPENDENCIES) 
-	@rm -f unlink$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(unlink_OBJECTS) $(unlink_LDADD) $(LIBS)
 uptime$(EXEEXT): $(uptime_OBJECTS) $(uptime_DEPENDENCIES) 
 	@rm -f uptime$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(uptime_OBJECTS) $(uptime_LDADD) $(LIBS)
 users$(EXEEXT): $(users_OBJECTS) $(users_DEPENDENCIES) 
 	@rm -f users$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(users_OBJECTS) $(users_LDADD) $(LIBS)
-vdir$(EXEEXT): $(vdir_OBJECTS) $(vdir_DEPENDENCIES) 
-	@rm -f vdir$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(vdir_OBJECTS) $(vdir_LDADD) $(LIBS)
-wc$(EXEEXT): $(wc_OBJECTS) $(wc_DEPENDENCIES) 
-	@rm -f wc$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(wc_OBJECTS) $(wc_LDADD) $(LIBS)
 who$(EXEEXT): $(who_OBJECTS) $(who_DEPENDENCIES) 
 	@rm -f who$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(who_OBJECTS) $(who_LDADD) $(LIBS)
-whoami$(EXEEXT): $(whoami_OBJECTS) $(whoami_DEPENDENCIES) 
-	@rm -f whoami$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(whoami_OBJECTS) $(whoami_LDADD) $(LIBS)
-yes$(EXEEXT): $(yes_OBJECTS) $(yes_DEPENDENCIES) 
-	@rm -f yes$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(yes_OBJECTS) $(yes_LDADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -2185,125 +1506,31 @@ mostlyclean-compile:
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/base64.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/basename.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cat.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chcon.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chgrp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chmod.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chown-core.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chown.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/chroot.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cksum.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/comm.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/copy.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cp-hash.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/csplit.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cut.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/date.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dd.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/df.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dircolors.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dirname.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/du.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/echo.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/env.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/expand.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/expr.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/factor.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/false.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fmt.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fold.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getlimits.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ginstall-copy.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ginstall-cp-hash.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ginstall-install.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ginstall-prog-fprintf.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/group-list.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/groups.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/head.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hostid.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hostname.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/id.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/join.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/kill.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lbracket.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libstdbuf_so-libstdbuf.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/link.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ln.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/logname.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ls-dir.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ls-ls.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ls-vdir.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ls.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcore.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/md5sum-mcore.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/md5sum-md5sum.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mkdir.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mkfifo.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mknod.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mktemp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mv.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nice.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nl.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nohup.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/od.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/operand2sig.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/paste.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pathchk.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pinky.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pr.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/printenv.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/printf.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/prog-fprintf.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ptx.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pwd.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/readlink.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/remove.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rm.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rmdir.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/runcon.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/seq.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/setuidgid.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sha1sum-md5sum.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sha224sum-md5sum.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sha256sum-md5sum.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sha384sum-md5sum.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sha512sum-md5sum.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/shred.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/shuf.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sleep.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sort.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/split.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stat.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stdbuf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stty.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/su.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sum.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sync.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tac.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tail.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tee.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/timeout.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/touch.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tr.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/true.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/truncate.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsort.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tty.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uname-arch.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uname-uname.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uname.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unexpand.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uniq.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unlink.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uptime.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/users.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/version.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/wc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/who.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/whoami.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/yes.Po@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
@@ -2321,70 +1548,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 
-ginstall-install.o: install.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ginstall-install.o -MD -MP -MF $(DEPDIR)/ginstall-install.Tpo -c -o ginstall-install.o `test -f 'install.c' || echo '$(srcdir)/'`install.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ginstall-install.Tpo $(DEPDIR)/ginstall-install.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='install.c' object='ginstall-install.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ginstall-install.o `test -f 'install.c' || echo '$(srcdir)/'`install.c
-
-ginstall-install.obj: install.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ginstall-install.obj -MD -MP -MF $(DEPDIR)/ginstall-install.Tpo -c -o ginstall-install.obj `if test -f 'install.c'; then $(CYGPATH_W) 'install.c'; else $(CYGPATH_W) '$(srcdir)/install.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ginstall-install.Tpo $(DEPDIR)/ginstall-install.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='install.c' object='ginstall-install.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ginstall-install.obj `if test -f 'install.c'; then $(CYGPATH_W) 'install.c'; else $(CYGPATH_W) '$(srcdir)/install.c'; fi`
-
-ginstall-prog-fprintf.o: prog-fprintf.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ginstall-prog-fprintf.o -MD -MP -MF $(DEPDIR)/ginstall-prog-fprintf.Tpo -c -o ginstall-prog-fprintf.o `test -f 'prog-fprintf.c' || echo '$(srcdir)/'`prog-fprintf.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ginstall-prog-fprintf.Tpo $(DEPDIR)/ginstall-prog-fprintf.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='prog-fprintf.c' object='ginstall-prog-fprintf.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ginstall-prog-fprintf.o `test -f 'prog-fprintf.c' || echo '$(srcdir)/'`prog-fprintf.c
-
-ginstall-prog-fprintf.obj: prog-fprintf.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ginstall-prog-fprintf.obj -MD -MP -MF $(DEPDIR)/ginstall-prog-fprintf.Tpo -c -o ginstall-prog-fprintf.obj `if test -f 'prog-fprintf.c'; then $(CYGPATH_W) 'prog-fprintf.c'; else $(CYGPATH_W) '$(srcdir)/prog-fprintf.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ginstall-prog-fprintf.Tpo $(DEPDIR)/ginstall-prog-fprintf.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='prog-fprintf.c' object='ginstall-prog-fprintf.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ginstall-prog-fprintf.obj `if test -f 'prog-fprintf.c'; then $(CYGPATH_W) 'prog-fprintf.c'; else $(CYGPATH_W) '$(srcdir)/prog-fprintf.c'; fi`
-
-ginstall-copy.o: copy.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ginstall-copy.o -MD -MP -MF $(DEPDIR)/ginstall-copy.Tpo -c -o ginstall-copy.o `test -f 'copy.c' || echo '$(srcdir)/'`copy.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ginstall-copy.Tpo $(DEPDIR)/ginstall-copy.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='copy.c' object='ginstall-copy.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ginstall-copy.o `test -f 'copy.c' || echo '$(srcdir)/'`copy.c
-
-ginstall-copy.obj: copy.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ginstall-copy.obj -MD -MP -MF $(DEPDIR)/ginstall-copy.Tpo -c -o ginstall-copy.obj `if test -f 'copy.c'; then $(CYGPATH_W) 'copy.c'; else $(CYGPATH_W) '$(srcdir)/copy.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ginstall-copy.Tpo $(DEPDIR)/ginstall-copy.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='copy.c' object='ginstall-copy.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ginstall-copy.obj `if test -f 'copy.c'; then $(CYGPATH_W) 'copy.c'; else $(CYGPATH_W) '$(srcdir)/copy.c'; fi`
-
-ginstall-cp-hash.o: cp-hash.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ginstall-cp-hash.o -MD -MP -MF $(DEPDIR)/ginstall-cp-hash.Tpo -c -o ginstall-cp-hash.o `test -f 'cp-hash.c' || echo '$(srcdir)/'`cp-hash.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ginstall-cp-hash.Tpo $(DEPDIR)/ginstall-cp-hash.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cp-hash.c' object='ginstall-cp-hash.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ginstall-cp-hash.o `test -f 'cp-hash.c' || echo '$(srcdir)/'`cp-hash.c
-
-ginstall-cp-hash.obj: cp-hash.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT ginstall-cp-hash.obj -MD -MP -MF $(DEPDIR)/ginstall-cp-hash.Tpo -c -o ginstall-cp-hash.obj `if test -f 'cp-hash.c'; then $(CYGPATH_W) 'cp-hash.c'; else $(CYGPATH_W) '$(srcdir)/cp-hash.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/ginstall-cp-hash.Tpo $(DEPDIR)/ginstall-cp-hash.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cp-hash.c' object='ginstall-cp-hash.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(ginstall_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ginstall-cp-hash.obj `if test -f 'cp-hash.c'; then $(CYGPATH_W) 'cp-hash.c'; else $(CYGPATH_W) '$(srcdir)/cp-hash.c'; fi`
-
 libstdbuf_so-libstdbuf.o: libstdbuf.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libstdbuf_so_CFLAGS) $(CFLAGS) -MT libstdbuf_so-libstdbuf.o -MD -MP -MF $(DEPDIR)/libstdbuf_so-libstdbuf.Tpo -c -o libstdbuf_so-libstdbuf.o `test -f 'libstdbuf.c' || echo '$(srcdir)/'`libstdbuf.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libstdbuf_so-libstdbuf.Tpo $(DEPDIR)/libstdbuf_so-libstdbuf.Po
@@ -2417,85 +1580,21 @@ md5sum-md5sum.obj: md5sum.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(md5sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o md5sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
 
-sha1sum-md5sum.o: md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha1sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sha1sum-md5sum.o -MD -MP -MF $(DEPDIR)/sha1sum-md5sum.Tpo -c -o sha1sum-md5sum.o `test -f 'md5sum.c' || echo '$(srcdir)/'`md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sha1sum-md5sum.Tpo $(DEPDIR)/sha1sum-md5sum.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='md5sum.c' object='sha1sum-md5sum.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha1sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sha1sum-md5sum.o `test -f 'md5sum.c' || echo '$(srcdir)/'`md5sum.c
-
-sha1sum-md5sum.obj: md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha1sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sha1sum-md5sum.obj -MD -MP -MF $(DEPDIR)/sha1sum-md5sum.Tpo -c -o sha1sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sha1sum-md5sum.Tpo $(DEPDIR)/sha1sum-md5sum.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='md5sum.c' object='sha1sum-md5sum.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha1sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sha1sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
-
-sha224sum-md5sum.o: md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha224sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sha224sum-md5sum.o -MD -MP -MF $(DEPDIR)/sha224sum-md5sum.Tpo -c -o sha224sum-md5sum.o `test -f 'md5sum.c' || echo '$(srcdir)/'`md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sha224sum-md5sum.Tpo $(DEPDIR)/sha224sum-md5sum.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='md5sum.c' object='sha224sum-md5sum.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha224sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sha224sum-md5sum.o `test -f 'md5sum.c' || echo '$(srcdir)/'`md5sum.c
-
-sha224sum-md5sum.obj: md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha224sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sha224sum-md5sum.obj -MD -MP -MF $(DEPDIR)/sha224sum-md5sum.Tpo -c -o sha224sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sha224sum-md5sum.Tpo $(DEPDIR)/sha224sum-md5sum.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='md5sum.c' object='sha224sum-md5sum.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha224sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sha224sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
-
-sha256sum-md5sum.o: md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha256sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sha256sum-md5sum.o -MD -MP -MF $(DEPDIR)/sha256sum-md5sum.Tpo -c -o sha256sum-md5sum.o `test -f 'md5sum.c' || echo '$(srcdir)/'`md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sha256sum-md5sum.Tpo $(DEPDIR)/sha256sum-md5sum.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='md5sum.c' object='sha256sum-md5sum.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha256sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sha256sum-md5sum.o `test -f 'md5sum.c' || echo '$(srcdir)/'`md5sum.c
-
-sha256sum-md5sum.obj: md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha256sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sha256sum-md5sum.obj -MD -MP -MF $(DEPDIR)/sha256sum-md5sum.Tpo -c -o sha256sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sha256sum-md5sum.Tpo $(DEPDIR)/sha256sum-md5sum.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='md5sum.c' object='sha256sum-md5sum.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha256sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sha256sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
-
-sha384sum-md5sum.o: md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha384sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sha384sum-md5sum.o -MD -MP -MF $(DEPDIR)/sha384sum-md5sum.Tpo -c -o sha384sum-md5sum.o `test -f 'md5sum.c' || echo '$(srcdir)/'`md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sha384sum-md5sum.Tpo $(DEPDIR)/sha384sum-md5sum.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='md5sum.c' object='sha384sum-md5sum.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha384sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sha384sum-md5sum.o `test -f 'md5sum.c' || echo '$(srcdir)/'`md5sum.c
-
-sha384sum-md5sum.obj: md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha384sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sha384sum-md5sum.obj -MD -MP -MF $(DEPDIR)/sha384sum-md5sum.Tpo -c -o sha384sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sha384sum-md5sum.Tpo $(DEPDIR)/sha384sum-md5sum.Po
-@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='md5sum.c' object='sha384sum-md5sum.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha384sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sha384sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
-
-sha512sum-md5sum.o: md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha512sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sha512sum-md5sum.o -MD -MP -MF $(DEPDIR)/sha512sum-md5sum.Tpo -c -o sha512sum-md5sum.o `test -f 'md5sum.c' || echo '$(srcdir)/'`md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sha512sum-md5sum.Tpo $(DEPDIR)/sha512sum-md5sum.Po
+md5sum-mcore.o: mcore.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(md5sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT md5sum-mcore.o -MD -MP -MF $(DEPDIR)/md5sum-mcore.Tpo -c -o md5sum-mcore.o `test -f 'mcore.c' || echo '$(srcdir)/'`mcore.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/md5sum-mcore.Tpo $(DEPDIR)/md5sum-mcore.Po
 @am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='md5sum.c' object='sha512sum-md5sum.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='mcore.c' object='md5sum-mcore.o' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha512sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sha512sum-md5sum.o `test -f 'md5sum.c' || echo '$(srcdir)/'`md5sum.c
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(md5sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o md5sum-mcore.o `test -f 'mcore.c' || echo '$(srcdir)/'`mcore.c
 
-sha512sum-md5sum.obj: md5sum.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha512sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT sha512sum-md5sum.obj -MD -MP -MF $(DEPDIR)/sha512sum-md5sum.Tpo -c -o sha512sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/sha512sum-md5sum.Tpo $(DEPDIR)/sha512sum-md5sum.Po
+md5sum-mcore.obj: mcore.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(md5sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT md5sum-mcore.obj -MD -MP -MF $(DEPDIR)/md5sum-mcore.Tpo -c -o md5sum-mcore.obj `if test -f 'mcore.c'; then $(CYGPATH_W) 'mcore.c'; else $(CYGPATH_W) '$(srcdir)/mcore.c'; fi`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/md5sum-mcore.Tpo $(DEPDIR)/md5sum-mcore.Po
 @am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='md5sum.c' object='sha512sum-md5sum.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='mcore.c' object='md5sum-mcore.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(sha512sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o sha512sum-md5sum.obj `if test -f 'md5sum.c'; then $(CYGPATH_W) 'md5sum.c'; else $(CYGPATH_W) '$(srcdir)/md5sum.c'; fi`
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(md5sum_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o md5sum-mcore.obj `if test -f 'mcore.c'; then $(CYGPATH_W) 'mcore.c'; else $(CYGPATH_W) '$(srcdir)/mcore.c'; fi`
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
diff -rupN orig/src/copy.c new/src/copy.c
--- orig/src/copy.c	2009-09-10 10:33:26.000000000 -0700
+++ new/src/copy.c	2012-10-08 16:05:26.492692109 -0700
@@ -1,10 +1,14 @@
 /* copy.c -- core functions for copying files and directories
+
+   Copyright 2010 United States Government National Aeronautics and
+   Space Administration (NASA).  No copyright is claimed in the United
+   States under Title 17, U.S. Code.  All Other Rights Reserved.
+
    Copyright (C) 89, 90, 91, 1995-2009 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
+   it under the terms of the GNU General Public License Version 3 with
+   Additional Terms below (per Section 7 of GPL V3).
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -14,7 +18,67 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-/* Extracted from cp.c and librarified by Jim Meyering.  */
+/* Extracted from cp.c and librarified by Jim Meyering.  
+   High performance multi-threaded modifications by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
 
 #include <config.h>
 #include <stdio.h>
@@ -44,6 +108,49 @@
 #include "hash.h"
 #include "hash-triple.h"
 #include "ignore-value.h"
+// PZK >
+#ifndef SYNC_FILE_RANGE_WRITE
+# define SYNC_FILE_RANGE_WAIT_BEFORE     1
+# define SYNC_FILE_RANGE_WRITE           2
+# define SYNC_FILE_RANGE_WAIT_AFTER      4
+
+# ifdef __i386__
+#  define NR_sync_file_range 314
+# endif
+
+# ifdef __x86_64__
+#  define NR_sync_file_range 277
+# endif
+
+# ifdef __ia64__
+#  define NR_sync_file_range 1300
+# endif
+
+static inline int sync_file_range(
+        int fd, loff_t offset, loff_t nbytes, int flags) {
+    return syscall(NR_sync_file_range, fd, offset, nbytes, flags);
+}
+#endif
+
+#if HAVE_LIBLUSTREAPI
+# include <libgen.h>
+# include <lustre/liblustreapi.h>
+# include <lustre/lustre_user.h>
+# include <sys/statfs.h>
+# define MAX_OSTS 1024
+# define LOV_EA_SIZE(lum, num) (sizeof(*lum) + num * sizeof(*lum->lmm_objects))
+# define LOV_EA_MAX(lum) LOV_EA_SIZE(lum, MAX_OSTS)
+//TODO: lustre_idl.h includes nonexistent files so define this here
+# define LOV_MAX_STRIPE_COUNT 160
+#endif
+
+#include "mcore.h"
+#include <aio.h>
+
+#if HAVE_LIBGCRYPT
+# include <gcrypt.h>
+#endif
+// < PZK
 #include "quote.h"
 #include "same.h"
 #include "savedir.h"
@@ -462,6 +569,439 @@ fchmod_or_lchmod (int desc, char const *
   return lchmod (name, mode);
 }
 
+// PZK >
+extern bool
+copy_reg_task (copy_reg_t *crt, struct cp_options *co)
+{
+  char *buf[2];
+  char *buf_alloc[2];
+  buf_alloc[0] = NULL;
+  buf_alloc[1] = NULL;
+  struct stat src_open_sb;
+  bool return_val = true;
+
+#if HAVE_LIBGCRYPT
+  hash_tree_t htt;
+#endif
+
+  if (fstat (crt->source_desc, &src_open_sb) != 0)
+    {
+      error (0, errno, _("cannot fstat %s"), quote (crt->src_name));
+      return_val = false;
+      goto task_close_src_and_dst_desc;
+    }
+
+      typedef uintptr_t word;
+      off_t n_read_total = 0;
+
+      /* Choose a suitable buffer size; it may be adjusted later.  */
+      size_t buf_alignment = lcm (getpagesize (), sizeof (word));
+      size_t buf_alignment_slop = sizeof (word) + buf_alignment - 1;
+      size_t buf_size = crt->dst_blksize;
+
+      /* Deal with sparse files.  */
+      bool last_write_made_hole = false;
+      bool make_holes = false;
+
+      if (S_ISREG (crt->dst_mode))
+        {
+          /* Even with --sparse=always, try to create holes only
+             if the destination is a regular file.  */
+          if (co->sparse_mode == SPARSE_ALWAYS)
+            make_holes = true;
+
+#if HAVE_STRUCT_STAT_ST_BLOCKS
+          /* Use a heuristic to determine whether SRC_NAME contains any sparse
+             blocks.  If the file has fewer blocks than would normally be
+             needed for a file of its size, then at least one of the blocks in
+             the file is a hole.  */
+          if (co->sparse_mode == SPARSE_AUTO && S_ISREG (src_open_sb.st_mode)
+              && ST_NBLOCKS (src_open_sb) < src_open_sb.st_size / ST_NBLOCKSIZE)
+            make_holes = true;
+#endif
+        }
+
+      /* If not making a sparse file, try to use a more-efficient
+         buffer size.  */
+      if (! make_holes)
+        {
+          /* Compute the least common multiple of the input and output
+             buffer sizes, adjusting for outlandish values.  */
+          size_t blcm_max = MIN (SIZE_MAX, SSIZE_MAX) - buf_alignment_slop;
+          size_t blcm = buffer_lcm (io_blksize (src_open_sb), buf_size,
+                                    blcm_max);
+// PZK >
+          blcm = co->buffer_size;
+          if (co->read_mode || co->write_mode)
+            blcm = buffer_lcm (blcm, 4096, blcm_max);
+// < PZK
+
+          /* Do not bother with a buffer larger than the input file, plus one
+             byte to make sure the file has not grown while reading it.  */
+          if (S_ISREG (src_open_sb.st_mode) && src_open_sb.st_size < buf_size)
+            buf_size = src_open_sb.st_size + 1;
+
+          /* However, stick with a block size that is a positive multiple of
+             blcm, overriding the above adjustments.  Watch out for
+             overflow.  */
+          buf_size += blcm - 1;
+          buf_size -= buf_size % blcm;
+          if (buf_size == 0 || blcm_max < buf_size)
+            buf_size = blcm;
+        }
+
+      /* Make a buffer with space for a sentinel at the end.  */
+      buf_alloc[0] = xmalloc (buf_size + buf_alignment_slop);
+      buf[0] = ptr_align (buf_alloc[0], buf_alignment);
+      if (co->double_buffer) {
+        buf_alloc[1] = xmalloc (buf_size + buf_alignment_slop);
+        buf[1] = ptr_align (buf_alloc[1], buf_alignment);
+      }
+
+#if HAVE_LIBGCRYPT
+      gcry_md_hd_t ctx;
+      if (co->print_hash || co->store_hash) {
+        gcry_md_open(&ctx, co->hash_type, 0);
+        if (crt->nsplits > 1) {
+            htt.n_hash_total = 0;
+            htt.hash_ctx = &ctx;
+            htt.hash_ctx_len = 0;
+//TODO:            if (co->store_hash) htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
+            htt.xattr_len = 0;
+            htt.fd = crt->dest_desc;
+            htt.stack_len = 0;
+
+            // compute approximate height of split sub-tree
+            off_t leafs = (crt->stop_offset - crt->start_offset) /
+                co->hash_leaf_size + 1;
+            ssize_t n = 1;
+            while (leafs >>= 1) n++;
+            // stack needs space for at most height of tree hashes
+            htt.stack = xmalloc(n * co->hash_size);
+        }
+      }
+#endif
+
+      struct timespec rts[2], wts[2];
+      struct aiocb raio, waio;
+      struct aiocb *raiol[1], *waiol[1];
+      raiol[0] = NULL;
+      waiol[0] = NULL;
+      int aio_buf = 0;
+
+      for (;;)
+        {
+          if (n_read_total >= crt->stop_offset - crt->start_offset) break;
+
+          ssize_t n_read;
+          if (raiol[0] != NULL) {
+              // this will be skipped during the first double buffer iteration
+              aio_suspend((const struct aiocb * const *) raiol, 1, NULL);
+              if (co->print_stats) clock_gettime(CLOCK_REALTIME, &rts[1]);
+              if (waiol[0] != NULL) {
+                  aio_suspend((const struct aiocb * const *) waiol, 1, NULL);
+                  if (co->print_stats) {
+                    clock_gettime(CLOCK_REALTIME, &wts[1]);
+                    crt->write_time += (double) (
+                        (double) wts[1].tv_sec +
+                            (double) wts[1].tv_nsec / (double) 1.0e9 -
+                        (double) wts[0].tv_sec -
+                            (double) wts[0].tv_nsec / (double) 1.0e9);
+                  }
+              }
+              n_read = aio_return(raiol[0]);
+          } else {
+              off_t to_read = MIN(buf_size,
+                crt->stop_offset - crt->start_offset - n_read_total);
+              // align offset for direct i/o and better performance when buffered
+              off_t align_read = (crt->start_offset + n_read_total) % 4096;
+              if (align_read != 0 && to_read > 4096) to_read = 4096 - align_read;
+              if (co->read_mode && to_read < buf_size) {
+                // turn off direct i/o if going to read unaligned block
+                int old_flags = fcntl(crt->source_desc, F_GETFL);
+                if (fcntl(crt->source_desc, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                    error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                        quote(crt->src_name));
+              }
+
+              if (co->print_stats) clock_gettime(CLOCK_REALTIME, &rts[0]);
+              n_read = read (crt->source_desc, buf[aio_buf], to_read);
+              if (co->print_stats) clock_gettime(CLOCK_REALTIME, &rts[1]);
+
+              if (co->read_mode && align_read != 0) {
+                // turn direct i/o back on in case it was turned off
+                int old_flags = fcntl(crt->source_desc, F_GETFL);
+                if (!(old_flags & O_DIRECT) &&
+                    fcntl(crt->source_desc, F_SETFL, old_flags | O_DIRECT) != 0)
+                        error(0, errno, _("failed to turn on O_DIRECT: %s"),
+                            quote(crt->src_name));
+              }
+          }
+
+          if (co->print_stats) {
+            crt->read_time += (double) (
+                (double) rts[1].tv_sec +
+                    (double) rts[1].tv_nsec / (double) 1.0e9 -
+                (double) rts[0].tv_sec -
+                    (double) rts[0].tv_nsec / (double) 1.0e9);
+          }
+
+          if (n_read < 0)
+            {
+#ifdef EINTR
+              if (errno == EINTR)
+                continue;
+#endif
+              error (0, errno, _("reading %s"), quote (crt->src_name));
+              return_val = false;
+              goto task_close_src_and_dst_desc;
+            }
+          if (n_read == 0)
+            break;
+
+#ifdef POSIX_FADV_DONTNEED
+          if (co->fadvise_read) {
+              // indicate done with read data
+              posix_fadvise(crt->source_desc, crt->start_offset + n_read_total,
+                  n_read, POSIX_FADV_DONTNEED);
+          }
+          if (co->fadvise_write && n_read_total >= buf_size) {
+              sync_file_range(crt->dest_desc,
+                  crt->start_offset + n_read_total - buf_size,
+                  buf_size, SYNC_FILE_RANGE_WRITE|SYNC_FILE_RANGE_WAIT_AFTER);
+              posix_fadvise(crt->dest_desc,
+                  crt->start_offset + n_read_total - buf_size,
+                  buf_size, POSIX_FADV_DONTNEED);
+          }
+#endif
+
+          n_read_total += n_read;
+
+          off_t to_read = MIN(buf_size,
+            crt->stop_offset - crt->start_offset - n_read_total);
+          if (co->double_buffer && to_read > 0) {
+            if (co->read_mode && to_read < buf_size) {
+                // turn off direct i/o if going to read unaligned block
+                int old_flags = fcntl(crt->source_desc, F_GETFL);
+                if (fcntl(crt->source_desc, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                    error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                        quote(crt->src_name));
+            }
+
+            if (co->print_stats) clock_gettime(CLOCK_REALTIME, &rts[0]);
+            memset(&raio, 0, sizeof(struct aiocb));
+            raio.aio_fildes = crt->source_desc;
+            raio.aio_offset = crt->start_offset + n_read_total;
+            raio.aio_buf = buf[!aio_buf];
+            raio.aio_nbytes = to_read;
+            raiol[0] = &raio;
+            //TODO: error handling for bad aio_read
+            int rc = aio_read(&raio);
+          }
+
+          word *wp = NULL;
+          if (make_holes)
+            {
+              char *cp;
+
+              /* Sentinel to stop loop.  */
+              buf[aio_buf][n_read] = '\1';
+#ifdef lint
+              /* Usually, buf[n_read] is not the byte just before a "word"
+                 (aka uintptr_t) boundary.  In that case, the word-oriented
+                 test below (*wp++ == 0) would read some uninitialized bytes
+                 after the sentinel.  To avoid false-positive reports about
+                 this condition (e.g., from a tool like valgrind), set the
+                 remaining bytes -- to any value.  */
+              memset (buf[aio_buf] + n_read + 1, 0, sizeof (word) - 1);
+#endif
+
+              /* Find first nonzero *word*, or the word with the sentinel.  */
+
+              wp = (word *) buf[aio_buf];
+              while (*wp++ == 0)
+                continue;
+
+              /* Find the first nonzero *byte*, or the sentinel.  */
+
+              cp = (char *) (wp - 1);
+              while (*cp++ == 0)
+                continue;
+
+              if (cp <= buf[aio_buf] + n_read)
+                /* Clear to indicate that a normal write is needed. */
+                wp = NULL;
+              else
+                {
+                  /* We found the sentinel, so the whole input block was zero.
+                     Make a hole.  */
+                  if (lseek (crt->dest_desc, n_read, SEEK_CUR) < 0)
+                    {
+                      error (0, errno, _("cannot lseek %s"), quote (crt->dst_name));
+                      return_val = false;
+                      goto task_close_src_and_dst_desc;
+                    }
+                  last_write_made_hole = true;
+                }
+            }
+
+          if (!wp)
+            {
+              size_t n = n_read;
+// PZK >
+              if (n < buf_size && co->write_mode) {
+                int old_flags = fcntl (crt->dest_desc, F_GETFL);
+                if (fcntl (crt->dest_desc, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                    error (0, errno, _("failed to turn off O_DIRECT: %s"),
+                        quote (crt->dst_name));
+              }
+              if (co->print_stats) clock_gettime(CLOCK_REALTIME, &wts[0]);
+              ssize_t n_write;
+              if (co->double_buffer) {
+                memset(&waio, 0, sizeof(struct aiocb));
+                waio.aio_fildes = crt->dest_desc;
+                waio.aio_offset = crt->start_offset + n_read_total - n;
+                waio.aio_buf = buf[aio_buf];
+                waio.aio_nbytes = n;
+                waiol[0] = &waio;
+                n_write = aio_write(&waio);
+              } else {
+                n_write = full_write (crt->dest_desc, buf[aio_buf], n);
+                if (co->print_stats) {
+                    clock_gettime(CLOCK_REALTIME, &wts[1]);
+                    crt->write_time += (double) (
+                        (double) wts[1].tv_sec +
+                            (double) wts[1].tv_nsec / (double) 1.0e9 -
+                        (double) wts[0].tv_sec -
+                            (double) wts[0].tv_nsec / (double) 1.0e9);
+                }
+              }
+
+              //TODO: check wrote n bytes in double buffer case?
+              if (!co->double_buffer && n_write != n)
+// < PZK
+                {
+                  error (0, errno, _("writing %s"), quote (crt->dst_name));
+                  return_val = false;
+                  goto task_close_src_and_dst_desc;
+                }
+              last_write_made_hole = false;
+
+              /* It is tempting to return early here upon a short read from a
+                 regular file.  That would save the final read syscall for each
+                 file.  Unfortunately that doesn't work for certain files in
+                 /proc with linux kernels from at least 2.6.9 .. 2.6.29.  */
+            }
+#if HAVE_LIBGCRYPT
+          if (co->print_hash && crt->nsplits == 1)
+            gcry_md_write(ctx, buf[aio_buf], n_read);
+          //TODO: this is wrong for store_hash when nsplits is 1
+          //TODO: is st_size right for partial files?
+          if ((co->print_hash || co->store_hash) && crt->nsplits > 1)
+            hash_tree(&htt, crt, co, buf[aio_buf], n_read_total, src_open_sb.st_size);
+#endif
+          if (co->double_buffer) aio_buf = !aio_buf;
+        }
+        if (waiol[0] != NULL)
+            aio_suspend((const struct aiocb * const *) waiol, 1, NULL);
+#ifdef POSIX_FADV_DONTNEED
+        if (co->fadvise_write && n_read_total >= buf_size) {
+            sync_file_range(crt->dest_desc, waiol[0]->aio_offset,
+                waiol[0]->aio_nbytes,
+                SYNC_FILE_RANGE_WRITE|SYNC_FILE_RANGE_WAIT_AFTER);
+            posix_fadvise(crt->dest_desc, waiol[0]->aio_offset,
+                waiol[0]->aio_nbytes, POSIX_FADV_DONTNEED);
+        }
+#endif
+
+      /* If the file ends with a `hole', we need to do something to record
+         the length of the file.  On modern systems, calling ftruncate does
+         the job.  On systems without native ftruncate support, we have to
+         write a byte at the ending position.  Otherwise the kernel would
+         truncate the file at the end of the last write operation.  */
+
+      if (last_write_made_hole && (co->double_buffer &&
+                crt->start_offset + n_read_total == src_open_sb.st_size ||
+            lseek(crt->source_desc, 0, SEEK_CUR) == src_open_sb.st_size))
+        {
+          if (HAVE_FTRUNCATE
+              ? /* ftruncate sets the file size,
+                   so there is no need for a write.  */
+              ftruncate (crt->dest_desc, src_open_sb.st_size) < 0
+              : /* Seek backwards one character and write a null.  */
+              (lseek (crt->dest_desc, (off_t) -1, SEEK_CUR) < 0L
+// PZK >
+               || co->write_mode
+               && fcntl (crt->dest_desc, F_SETFL,
+                    fcntl (crt->dest_desc, F_GETFL) & ~O_DIRECT)
+// < PZK
+               || full_write (crt->dest_desc, "", 1) != 1))
+            {
+              error (0, errno, _("writing %s"), quote (crt->dst_name));
+              return_val = false;
+              goto task_close_src_and_dst_desc;
+            }
+        }
+
+  if (co->preserve_timestamps)
+    {
+      struct timespec timespec[2];
+      timespec[0] = crt->src_atime;
+      timespec[1] = crt->src_mtime;
+
+      if (gl_futimens (crt->dest_desc, crt->dst_name, timespec) != 0)
+        {
+          error (0, errno, _("preserving times for %s"), quote (crt->dst_name));
+          if (co->require_preserve)
+            {
+              return_val = false;
+              goto task_close_src_and_dst_desc;
+            }
+        }
+    }
+
+task_close_src_and_dst_desc:
+  if (close (crt->dest_desc) < 0)
+    {
+      error (0, errno, _("closing %s"), quote (crt->dst_name));
+      return_val = false;
+    }
+  if (close (crt->source_desc) < 0)
+    {
+      error (0, errno, _("closing %s"), quote (crt->src_name));
+      return_val = false;
+    }
+
+  free (buf_alloc[0]);
+  free (buf_alloc[1]);
+  if (!return_val) {
+    error (0, 0, _("%s: FAILED open or read"), quote (crt->src_name));
+#if HAVE_LIBGCRYPT
+  } else if (co->print_hash || co->store_hash) {
+    // copy final hash onto crt hash stack
+    if (crt->nsplits > 1) {
+        memcpy(crt->hash_stack, htt.stack, co->hash_size);
+    } else {
+        memcpy(crt->hash_stack, gcry_md_read(ctx, 0), co->hash_size);
+    }
+#endif
+  }
+
+#if HAVE_LIBGCRYPT
+  if (co->print_hash || co->store_hash) {
+    gcry_md_close(ctx);
+    if (crt->nsplits > 1) {
+        if (co->store_hash) free(htt.xattr);
+        free(htt.stack);
+    }
+  }
+#endif
+
+  return return_val;
+}
+// < PZK
+
+
 /* Copy a regular file from SRC_NAME to DST_NAME.
    If the source file contains holes, copies holes and blocks of zeros
    in the source file as holes in the destination file.
@@ -491,10 +1031,22 @@ copy_reg (char const *src_name, char con
   struct stat src_open_sb;
   bool return_val = true;
   bool data_copy_required = true;
+// PZK >
+  mode_t wdst_mode = dst_mode | S_IWUSR;
+// < PZK
 
   source_desc = open (src_name,
                       (O_RDONLY | O_BINARY
+// PZK >
+                       | x->read_mode
+// < PZK
                        | (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+
+// PZK >
+  if (source_desc < 0 && x->read_mode)
+    source_desc = open (src_name, (O_RDONLY | O_BINARY
+                       | (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+// < PZK
   if (source_desc < 0)
     {
       error (0, errno, _("cannot open %s for reading"), quote (src_name));
@@ -523,7 +1075,13 @@ copy_reg (char const *src_name, char con
      by the specs for both cp and mv.  */
   if (! *new_dst)
     {
-      dest_desc = open (dst_name, O_WRONLY | O_TRUNC | O_BINARY);
+// PZK >
+      if (x->offset || x->length)
+        // do not truncate when doing partial copy
+        dest_desc = open (dst_name, O_WRONLY | O_BINARY | x->write_mode);
+      else
+        dest_desc = open (dst_name, O_WRONLY | O_TRUNC | O_BINARY | x->write_mode);
+// < PZK
       dest_errno = errno;
 
       /* When using cp --preserve=context to copy to an existing destination,
@@ -582,9 +1140,60 @@ copy_reg (char const *src_name, char con
 
   if (*new_dst)
     {
-      int open_flags = O_WRONLY | O_CREAT | O_BINARY;
+// PZK >
+      int open_flags = O_WRONLY | O_CREAT | O_BINARY | x->write_mode;
+#if HAVE_LIBLUSTREAPI
+//TODO: need a way to disable stripe count preservation?
+      // check if dst is lustre
+      struct statfs sfs;
+      char *dir = xstrdup(dst_name);
+      int rc = statfs(dirname(dir), &sfs);
+      free(dir);
+      if (!rc && sfs.f_type == LL_SUPER_MAGIC) {
+        // dst is lustre
+        int scount = 0;
+        int ssize = 0;
+        struct lov_user_md *lum = xmalloc(LOV_EA_MAX(lum));
+        // check if src is lustre
+        if (!fstatfs(source_desc, &sfs) && sfs.f_type == LL_SUPER_MAGIC) {
+            // src is lustre so get current src striping
+            if (!llapi_file_get_stripe(src_name, lum)) {
+                scount = lum->lmm_stripe_count;
+                ssize = lum->lmm_stripe_size;
+                // restripe to # of GBs if stripe count is the default
+                if (scount == 1 || scount == 4) {
+                    int scount0 = scount;
+                    scount = src_sb->st_size / 1000000000 + 1;
+                    if (x->print_stripe)
+                        error(0, 0, _("note: stripe count of %s has been adjusted from %d to %d"),
+                            quote(dst_name), scount0, scount);
+                }
+            }
+        } else {
+            // src is not lustre
+            scount = src_sb->st_size / 1000000000 + 1;
+        }
+        if (scount > LOV_MAX_STRIPE_COUNT) scount = LOV_MAX_STRIPE_COUNT;
+        if (!llapi_file_create(dst_name, ssize, -1, scount, 0)) {
+            dest_desc = open (dst_name, open_flags | O_LOV_DELAY_CREATE,
+                wdst_mode & ~omitted_permissions);
+            if (dest_desc && !llapi_file_get_stripe(dst_name, lum) &&
+                    lum->lmm_stripe_count != scount) {
+                //TODO: this probably shouldn't be printed for every
+                //      file, especially when physical OST counts differ
+                //      between file systems
+                error(0, 0, _("warning: allocated stripe count of %s does not match original stripe count of %s"),
+                    quote_n(0, dst_name), quote_n(1, src_name));
+            }
+        } else {
+          dest_desc = -1;
+        }
+        free(lum);
+      } else
+#endif
       dest_desc = open (dst_name, open_flags | O_EXCL,
-                        dst_mode & ~omitted_permissions);
+                        wdst_mode & ~omitted_permissions);
+// < PZK
       dest_errno = errno;
 
       /* When trying to copy through a dangling destination symlink,
@@ -604,8 +1213,10 @@ copy_reg (char const *src_name, char con
             {
               if (x->open_dangling_dest_symlink)
                 {
+// PZK >
                   dest_desc = open (dst_name, open_flags,
-                                    dst_mode & ~omitted_permissions);
+// < PZK
+                                    wdst_mode & ~omitted_permissions);
                   dest_errno = errno;
                 }
               else
@@ -651,7 +1262,10 @@ copy_reg (char const *src_name, char con
         }
     }
 
-  if (data_copy_required)
+// PZK >
+  // this is currently a noop since threads cannot be less than 1
+  if (data_copy_required && x->threads == 0)
+// < PZK
     {
       typedef uintptr_t word;
       off_t n_read_total = 0;
@@ -815,6 +1429,76 @@ copy_reg (char const *src_name, char con
               goto close_src_and_dst_desc;
             }
         }
+// PZK >
+#ifdef _OPENMP
+    } else if (data_copy_required) {
+        off_t pos = 0;
+        if (x->offset && x->offset > src_sb->st_size) pos = src_sb->st_size;
+        else if (x->offset) pos = x->offset;
+        off_t end = src_sb->st_size;
+        if (x->length && pos + x->length < end) end = pos + x->length;
+        size_t nsplits = 1, split = 0;
+        if (x->split_size > 0 && end - pos > 0)
+            nsplits = (end - pos) / x->split_size +
+                ((end - pos) % x->split_size ? 1 : 0);
+        while (pos == 0 || pos < end) {
+            copy_reg_t *crt = xmalloc(sizeof(copy_reg_t));
+            crt->src_name = xstrdup(src_name);
+            crt->dst_name = xstrdup(dst_name);
+            crt->dst_mode = sb.st_mode;
+            crt->src_atime = get_stat_atime(src_sb);
+            crt->src_mtime = get_stat_mtime(src_sb);
+            crt->dst_blksize = io_blksize(sb);
+            crt->read_time = 0;
+            crt->write_time = 0;
+            crt->copy_time = 0;
+            crt->nsplits = nsplits;
+            crt->split = split++;
+            crt->start_offset = pos;
+            crt->partial = x->offset || end < src_sb->st_size ? true : false;
+            crt->hash_stack = xmalloc(x->hash_size);
+            if (x->print_stats || x->print_hash || x->store_hash && nsplits > 1)
+                *x->hash_stat_tasks += 1;
+            pos += x->split_size;
+            if (nsplits > 1) {
+                // stop after split size bytes
+                crt->stop_offset = MIN(pos, end);
+                if (crt->start_offset == x->offset &&
+                        (x->print_hash || x->store_hash)) {
+                    copy_reg_t *crtcp = xmalloc(sizeof(copy_reg_t));
+                    crtcp->nsplits = nsplits;
+                    crtcp->split = nsplits;
+                    crtcp->start_offset = x->offset;
+                    crtcp->stop_offset = end;
+                    crtcp->partial = crt->partial;
+                    crtcp->src_name = xstrdup(src_name);
+                    crtcp->dst_name = xstrdup(dst_name);
+                    crtcp->hash_stack = xmalloc(nsplits * x->hash_size);
+                    if (x->store_hash) {
+                        //TODO: check that won't overflow file
+                        //      descriptors by keeping one open
+                        // need to keep open descriptor for xattr operations
+                        crtcp->dest_desc =
+                            open(dst_name, O_WRONLY | O_BINARY | x->write_mode);
+                        if (crtcp->dest_desc < 0)
+                            error(0, errno, _("warning: unable to open %s for storing hash"), quote(dst_name));
+                        //TODO: additional error handling?
+                    }
+                    // send crt copy to hash handler
+                    omp_q_push(x->send_q, crtcp);
+                }
+            } else {
+                // stop at end of file
+                crt->stop_offset = end;
+            }
+            omp_q_push(x->task_q, crt);
+            // wait until file has been opened
+            //TODO: to be reliable probably need timeout here
+            omp_q_pop(x->open_q);
+            if (nsplits == 1) break;
+        }
+#endif
+// < PZK
     }
 
   if (x->preserve_timestamps)
@@ -866,10 +1550,15 @@ copy_reg (char const *src_name, char con
       if (set_acl (dst_name, dest_desc, x->mode) != 0)
         return_val = false;
     }
-  else if (omitted_permissions)
+// PZK >
+  else if (omitted_permissions || dst_mode != wdst_mode)
+// < PZK
     {
       omitted_permissions &= ~ cached_umask ();
-      if (omitted_permissions
+// PZK >
+      if ((omitted_permissions || dst_mode != wdst_mode)
+          && !x->skip_chmod
+// < PZK
           && fchmod_or_lchmod (dest_desc, dst_name, dst_mode) != 0)
         {
           error (0, errno, _("preserving permissions for %s"),
@@ -1880,6 +2569,38 @@ copy_internal (char const *src_name, cha
                      quote (dst_name));
               goto un_backup;
             }
+// PZK >
+#if HAVE_LIBLUSTREAPI
+          else {
+//TODO: need a way to disable stripe count preservation?
+            // check if dst is lustre
+            struct statfs sfs;
+            if (!statfs(dst_name, &sfs) && sfs.f_type == LL_SUPER_MAGIC) {
+                // dst is lustre
+                // check if src is lustre
+                if (!statfs(src_name, &sfs) && sfs.f_type == LL_SUPER_MAGIC) {
+                    // src is lustre so get current src striping
+                    struct lov_user_md *lum = xmalloc(LOV_EA_MAX(lum));
+                    if (!llapi_file_get_stripe(src_name, lum)) {
+                        int scount = lum->lmm_stripe_count;
+                        int ssize = lum->lmm_stripe_size;
+                        // restripe to 0 if stripe count is the default
+                        if (scount == 1 || scount == 4) {
+                            if (x->print_stripe)
+                                error(0, 0, _("note: stripe count of %s has been adjusted from %d to 0"),
+                                    quote(dst_name), scount);
+                            scount = 0;
+                        }
+                        if (llapi_file_create(dst_name, ssize, -1, scount, 0))
+                            error(0, 0, _("warning: unable to set stripe count of %s"),
+                                quote(dst_name));
+                    }
+                    free(lum);
+                }
+            }
+          }
+#endif
+// < PZK
 
           /* We need search and write permissions to the new directory
              for writing the directory's contents. Check if these
diff -rupN orig/src/copy.h new/src/copy.h
--- orig/src/copy.h	2009-09-01 04:01:16.000000000 -0700
+++ new/src/copy.h	2012-10-08 13:50:49.056671471 -0700
@@ -1,10 +1,14 @@
 /* core functions for copying files and directories
+
+   Copyright 2010 United States Government National Aeronautics and
+   Space Administration (NASA).  No copyright is claimed in the United
+   States under Title 17, U.S. Code.  All Other Rights Reserved.
+
    Copyright (C) 89, 90, 91, 1995-2009 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
+   it under the terms of the GNU General Public License Version 3 with
+   Additional Terms below (per Section 7 of GPL V3).
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -14,7 +18,67 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-/* Extracted from cp.c and librarified by Jim Meyering.  */
+/* Extracted from cp.c and librarified by Jim Meyering.
+   High performance multi-threaded modifications by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
 
 #ifndef COPY_H
 # define COPY_H
@@ -22,6 +86,16 @@
 # include <stdbool.h>
 # include "hash.h"
 
+// PZK >
+# include <stdlib.h>
+# include <sys/stat.h>
+# include <time.h>
+# include <netinet/in.h>
+
+# include "backupfile.h"
+# include "mcore-omp.h"
+// < PZK
+
 /* Control creation of sparse files (files with holes).  */
 enum Sparse_type
 {
@@ -97,6 +171,41 @@ enum Dereference_symlink
    mv.c, cp.c, and install.c.  */
 struct cp_options
 {
+// PZK >
+  size_t buffer_size;
+  bool check_tree;
+  bool double_buffer;
+  bool fadvise_read;
+  bool fadvise_write;
+  off_t hash_leaf_size;
+  unsigned int hash_size;
+  long long *hash_stat_tasks;
+  int hash_type;
+  off_t length;
+  in_port_t listen_port;
+  struct addrinfo *mgr_ai;
+  char *mg_file;
+  in_port_t mgr_port;
+  bool mpi;
+  off_t offset;
+  omp_q_t *open_q;
+  char *pass;
+  bool print_hash;
+  bool print_stats;
+  bool print_stripe;
+  char *pw_file;
+  int read_mode;
+  bool read_stdin;
+  omp_q_t *send_q;
+  bool skip_chmod;
+  off_t split_size;
+  bool store_hash;
+  omp_q_t *task_q;
+  int threads;
+  char *user;
+  int write_mode;
+// < PZK
+
   enum backup_type backup_type;
 
   /* How to handle symlinks in the source.  */
@@ -280,4 +389,28 @@ void cp_options_default (struct cp_optio
 bool chown_failure_ok (struct cp_options const *);
 mode_t cached_umask (void);
 
+// PZK >
+typedef struct {
+    double copy_time;
+    int dest_desc;
+    size_t dst_blksize;
+    mode_t dst_mode;
+    char *dst_name;
+    unsigned char *hash_stack;
+    bool partial;
+    size_t nsplits;
+    double read_time;
+    int source_desc;
+    size_t split;
+    struct timespec src_atime;
+    struct timespec src_mtime;
+    char *src_name;
+    off_t start_offset;
+    off_t stop_offset;
+    double write_time;
+} copy_reg_t;
+
+bool copy_reg_task(copy_reg_t *crt, struct cp_options *co);
+// < PZK
+
 #endif
diff -rupN orig/src/cp.c new/src/cp.c
--- orig/src/cp.c	2009-09-01 04:01:16.000000000 -0700
+++ new/src/cp.c	2012-10-08 14:55:48.702518511 -0700
@@ -1,10 +1,14 @@
 /* cp.c  -- file copying (main routines)
+
+   Copyright 2010 United States Government National Aeronautics and
+   Space Administration (NASA).  No copyright is claimed in the United
+   States under Title 17, U.S. Code.  All Other Rights Reserved.
+
    Copyright (C) 89, 90, 91, 1995-2009 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
+   it under the terms of the GNU General Public License Version 3 with
+   Additional Terms below (per Section 7 of GPL V3).
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -12,9 +16,69 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Torbjorn Granlund, David MacKenzie, and Jim Meyering.
+   High performance multi-threaded modifications by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
 
-   Written by Torbjorn Granlund, David MacKenzie, and Jim Meyering. */
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
 
 #include <config.h>
 #include <stdio.h>
@@ -30,6 +94,35 @@
 #include "error.h"
 #include "filenamecat.h"
 #include "ignore-value.h"
+// PZK >
+#include "mcore.h"
+#include "mkancesdirs.h"
+#include "savewd.h"
+#include <ctype.h>
+
+#if HAVE_LIBGCRYPT
+# include <gcrypt.h>
+# ifdef _OPENMP
+#  include <pthread.h>
+GCRY_THREAD_OPTION_PTHREAD_IMPL;
+# endif
+#endif
+
+#if HAVE_LIBMPI && defined(_OPENMP)
+# include "mpi.h"
+#endif
+
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+# include <arpa/inet.h>
+# include <gnutls/gnutls.h>
+# include <gnutls/extra.h>
+# include <netdb.h>
+# include <poll.h>
+# include <pthread.h>
+# include <pwd.h>
+# include <sys/socket.h>
+#endif
+// < PZK
 #include "quote.h"
 #include "stat-time.h"
 #include "utimens.h"
@@ -50,12 +143,43 @@
   while (0)
 
 /* The official name of this program (e.g., no `g' prefix).  */
-#define PROGRAM_NAME "cp"
+// PZK >
+#define PROGRAM_NAME "mcp 1.76.6"
 
 #define AUTHORS \
   proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
   proper_name ("David MacKenzie"), \
-  proper_name ("Jim Meyering")
+  proper_name ("Jim Meyering"), \
+  proper_name ("Paul Kolano")
+
+#ifndef DEFAULT_BUFFER_SIZE
+# define DEFAULT_BUFFER_SIZE 4
+#endif
+#ifndef DEFAULT_DIRECT_READ
+# define DEFAULT_DIRECT_READ 0
+#endif
+#ifndef DEFAULT_DIRECT_WRITE
+# define DEFAULT_DIRECT_WRITE 0
+#endif
+#ifndef DEFAULT_DOUBLE_BUFFER
+# define DEFAULT_DOUBLE_BUFFER 0
+#endif
+#ifndef DEFAULT_FADVISE_READ
+# define DEFAULT_FADVISE_READ 0
+#endif
+#ifndef DEFAULT_FADVISE_WRITE
+# define DEFAULT_FADVISE_WRITE 0
+#endif
+#if !defined(DEFAULT_HASH_TYPE) && HAVE_LIBGCRYPT
+# define DEFAULT_HASH_TYPE GCRY_MD_MD5
+#endif
+#ifndef DEFAULT_SPLIT_SIZE
+# define DEFAULT_SPLIT_SIZE 0
+#endif
+#ifndef DEFAULT_THREADS
+# define DEFAULT_THREADS 4
+#endif
+// < PZK
 
 /* Used by do_copy, make_dir_parents_private, and re_protect
    to keep a list of leading directories whose protections
@@ -73,6 +197,49 @@ struct dir_attr
 enum
 {
   COPY_CONTENTS_OPTION = CHAR_MAX + 1,
+// PZK >
+  BUFFER_SIZE_OPTION,
+  DIRECT_READ_OPTION,
+  DIRECT_WRITE_OPTION,
+  DOUBLE_BUFFER_OPTION,
+  LENGTH_OPTION,
+  NO_DIRECT_READ_OPTION,
+  NO_DIRECT_WRITE_OPTION,
+  NO_DOUBLE_BUFFER_OPTION,
+  OFFSET_OPTION,
+  READ_STDIN_OPTION,
+  SKIP_CHMOD_OPTION,
+#ifdef POSIX_FADV_DONTNEED
+  FADVISE_READ_OPTION,
+  FADVISE_WRITE_OPTION,
+  NO_FADVISE_READ_OPTION,
+  NO_FADVISE_WRITE_OPTION,
+#endif
+#ifdef _OPENMP
+  PRINT_STATS_OPTION,
+  SPLIT_SIZE_OPTION,
+  THREADS_OPTION,
+#endif
+#if HAVE_LIBLUSTREAPI
+  PRINT_STRIPE_OPTION,
+#endif
+#if HAVE_LIBGCRYPT
+  CHECK_TREE_OPTION,
+  HASH_LEAF_SIZE_OPTION,
+  HASH_TYPE_OPTION,
+  PRINT_HASH_OPTION,
+  STORE_HASH_OPTION,
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+  MPI_OPTION,
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  LISTEN_PORT_OPTION,
+  MANAGER_HOST_OPTION,
+  MANAGER_PORT_OPTION,
+  PASSWORD_FILE_OPTION,
+#endif
+// < PZK
   NO_PRESERVE_ATTRIBUTES_OPTION,
   PARENTS_OPTION,
   PRESERVE_ATTRIBUTES_OPTION,
@@ -114,6 +281,49 @@ ARGMATCH_VERIFY (reflink_type_string, re
 
 static struct option const long_opts[] =
 {
+// PZK >
+  {"buffer-size", required_argument, NULL, BUFFER_SIZE_OPTION},
+  {"direct-read", no_argument, NULL, DIRECT_READ_OPTION},
+  {"direct-write", no_argument, NULL, DIRECT_WRITE_OPTION},
+  {"double-buffer", no_argument, NULL, DOUBLE_BUFFER_OPTION},
+  {"length", required_argument, NULL, LENGTH_OPTION},
+  {"no-direct-read", no_argument, NULL, NO_DIRECT_READ_OPTION},
+  {"no-direct-write", no_argument, NULL, NO_DIRECT_WRITE_OPTION},
+  {"no-double-buffer", no_argument, NULL, NO_DOUBLE_BUFFER_OPTION},
+  {"offset", required_argument, NULL, OFFSET_OPTION},
+  {"read-stdin", no_argument, NULL, READ_STDIN_OPTION},
+  {"skip-chmod", no_argument, NULL, SKIP_CHMOD_OPTION},
+#ifdef POSIX_FADV_DONTNEED
+  {"fadvise-read", no_argument, NULL, FADVISE_READ_OPTION},
+  {"fadvise-write", no_argument, NULL, FADVISE_WRITE_OPTION},
+  {"no-fadvise-read", no_argument, NULL, NO_FADVISE_READ_OPTION},
+  {"no-fadvise-write", no_argument, NULL, NO_FADVISE_WRITE_OPTION},
+#endif
+#ifdef _OPENMP
+  {"print-stats", no_argument, NULL, PRINT_STATS_OPTION},
+  {"split-size", required_argument, NULL, SPLIT_SIZE_OPTION},
+  {"threads", required_argument, NULL, THREADS_OPTION},
+#endif
+#if HAVE_LIBLUSTREAPI
+  {"print-stripe", no_argument, NULL, PRINT_STRIPE_OPTION},
+#endif
+#if HAVE_LIBGCRYPT
+  {"check-tree", no_argument, NULL, CHECK_TREE_OPTION},
+  {"hash-leaf-size", required_argument, NULL, HASH_LEAF_SIZE_OPTION},
+  {"hash-type", required_argument, NULL, HASH_TYPE_OPTION},
+  {"print-hash", no_argument, NULL, PRINT_HASH_OPTION},
+  {"store-hash", no_argument, NULL, STORE_HASH_OPTION},
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+  {"mpi", no_argument, NULL, MPI_OPTION},
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  {"listen-port", required_argument, NULL, LISTEN_PORT_OPTION},
+  {"manager-host", required_argument, NULL, MANAGER_HOST_OPTION},
+  {"manager-port", required_argument, NULL, MANAGER_PORT_OPTION},
+  {"password-file", required_argument, NULL, PASSWORD_FILE_OPTION},
+#endif
+// < PZK
   {"archive", no_argument, NULL, 'a'},
   {"backup", optional_argument, NULL, 'b'},
   {"copy-contents", no_argument, NULL, COPY_CONTENTS_OPTION},
@@ -162,9 +372,166 @@ Usage: %s [OPTION]... [-T] SOURCE DEST\n
 Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n\
 \n\
 "), stdout);
+// PZK >
+      fputs (_("Mcp-specific options (defaults in brackets):\n"), stdout);
+      fprintf (stdout, _("\
+      --buffer-size=MBYTES     read/write buffer size [%d]\n"),
+        DEFAULT_BUFFER_SIZE);
+#if HAVE_LIBGCRYPT
+      fputs (_("\
+      --check-tree             print hash subtrees to pinpoint corruption\n\
+"), stdout);
+#endif
+#if !DEFAULT_DIRECT_READ
+      fputs (_("\
+      --direct-read            enable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if !DEFAULT_DIRECT_WRITE
+      fputs (_("\
+      --direct-write           enable use of direct I/O for writes\n\
+"), stdout);
+#endif
+#if !DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
+      --double-buffer          enable use of double buffering during file I/O\n\
+"), stdout);
+#endif
+#ifdef POSIX_FADV_DONTNEED
+# if !DEFAULT_FADVISE_READ
+      fputs (_("\
+      --fadvise-read           enable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+# if !DEFAULT_FADVISE_WRITE
       fputs (_("\
-Mandatory arguments to long options are mandatory for short options too.\n\
+      --fadvise-write          enable use of posix_fadvise during writes\n\
 "), stdout);
+# endif
+#endif
+#if HAVE_LIBGCRYPT
+      fprintf (stdout, _("\
+      --hash-leaf-size=KBYTES  granularity of hash tree [%d]\n\
+      --hash-type=TYPE         hash type [%s], with TYPE one of:\n\
+                                 "),
+        DEFAULT_SPLIT_SIZE * 1024, gcry_md_algo_name(DEFAULT_HASH_TYPE));
+      int n = 33;
+      // 400 taken from libgcrypt benchmark code
+      for (int i = 1; i < 400; i++) {
+        if (gcry_md_test_algo(i)) continue;
+        char *name = gcry_md_algo_name(i);
+        if (n + strlen(name) > 78) {
+            fputs (_("\n                                 "), stdout);
+            n = 33;
+        }
+        n += strlen(name);
+        while (*name) fputc(tolower(*name++), stdout);
+        fputc(' ', stdout);
+      }
+      fputs(_("\n"), stdout);
+#endif
+      fputs (_("\
+      --length=LEN             copy LEN bytes beginning at --offset\n\
+                                 (or 0 if --offset not specified)\n\
+"), stdout);
+#if HAVE_LIBGNUTLS
+      fputs (_("\
+      --listen-port=PORT       listen on port PORT for requests from\n\
+                                 cooperating hosts\n\
+      --manager-host=HOST      host name or IP address of management thread\n\
+                                 for multi-node/multi-host copies\n\
+      --manager-port=PORT      port on which to contact management thread\n\
+"), stdout);
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+      fputs (_("\
+      --mpi                    enable use of MPI for multi-node copies\n\
+"), stdout);
+#endif
+#if DEFAULT_DIRECT_READ
+      fputs (_("\
+      --no-direct-read         disable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if DEFAULT_DIRECT_WRITE
+      fputs (_("\
+      --no-direct-write        disable use of direct I/O for writes\n\
+"), stdout);
+#endif
+#if DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
+      --no-double-buffer       disable use of double buffering during file I/O\n\
+"), stdout);
+#endif
+#ifdef POSIX_FADV_DONTNEED
+# if DEFAULT_FADVISE_READ
+      fputs (_("\
+      --no-fadvise-read        disable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+# if DEFAULT_FADVISE_WRITE
+      fputs (_("\
+      --no-fadvise-write       disable use of posix_fadvise during writes\n\
+"), stdout);
+# endif
+#endif
+      fputs (_("\
+      --offset=POS             copy --length bytes beginning at POS\n\
+                                 (or to end if --length not specified)\n\
+"), stdout);
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+      fputs (_("\
+      --password-file=FILE     file to use for passwords (will be created\n\
+                                 if does not exist)\n\
+"), stdout);
+#endif
+#if HAVE_LIBGCRYPT
+      fputs (_("\
+      --print-hash             print hash of each file to stdout similar to\n\
+                                 md5sum, with sum of the src file computed,\n\
+                                 but dst file name printed so that md5sum -c\n\
+                                 can be used on the output to check that the\n\
+                                 data written to disk was what was read\n\
+"), stdout);
+#endif
+#ifdef _OPENMP
+      fputs (_("\
+      --print-stats            print performance per file to stderr\n\
+"), stdout);
+#endif
+#if HAVE_LIBLUSTREAPI
+      fputs (_("\
+      --print-stripe           print striping changes to stderr\n\
+"), stdout);
+#endif
+#ifdef _OPENMP
+      fputs (_("\
+      --read-stdin             perform a batch of operations read over stdin\n\
+                                 in the form 'SRC DST RANGES' where SRC and DST\n\
+                                 must be URI-escaped (RFC 3986) file names and\n\
+                                 RANGES is zero or more comma-separated ranges of\n\
+                                 the form 'START-END' for 0 <= START < END\n\
+      --skip-chmod             retain temporary permissions used during copy\n\
+"), stdout);
+      fprintf (stdout, _("\
+      --split-size=MBYTES      size to split files for parallelization [%d]\n\
+      --threads=NUMBER         number of OpenMP worker threads to use [%d]\n\
+\n\
+"), DEFAULT_SPLIT_SIZE, DEFAULT_THREADS);
+#endif
+/* TODO: these options temporarily disabled
+TODO: fix hash-type to include stores
+#if HAVE_LIBGCRYPT
+      fputs (_("\
+      --store-hash                 store hash in xattrs of each dst file\n\
+"), stdout);
+#endif
+*/
+      fputs (_("\
+Standard options (mandatory arguments to long options are mandatory\n\
+                  for short options too):\n\
+"), stdout);
+// < PZK
       fputs (_("\
   -a, --archive                same as -dR --preserve=all\n\
       --backup[=CONTROL]       make a backup of each existing destination file\n\
@@ -569,6 +936,133 @@ target_directory_operand (char const *fi
   return is_a_dir;
 }
 
+// PZK >
+void print_hash(const struct cp_options *x, copy_reg_t *crt)
+{
+    size_t i;
+
+    // put non-standard output in comments
+    if (crt->nsplits > 1 || crt->partial) {
+        printf("#mutil#");
+        if (crt->partial)
+            printf("%lld-%lld", crt->start_offset, crt->stop_offset);
+        printf("#");
+    }
+
+    /* Output a leading backslash if the file name contains
+       a newline or backslash.  */
+    if (strchr(crt->dst_name, '\n') || strchr(crt->dst_name, '\\'))
+        putchar ('\\');
+
+    size_t bytes = x->hash_size;
+    if (x->check_tree) bytes *= crt->nsplits;
+
+    for (size_t i = 0; i < bytes; ++i)
+        printf ("%02x", crt->hash_stack[i]);
+
+    putchar (' ');
+/*TODO: do something with this binary stuff
+    if (file_is_binary)
+      putchar ('*');
+    else
+*/
+      putchar (' ');
+
+    /* Translate each NEWLINE byte to the string, "\\n",
+       and each backslash to "\\\\".  */
+    for (i = 0; i < strlen(crt->dst_name); ++i) {
+        switch (crt->dst_name[i]) {
+        case '\n':
+            fputs("\\n", stdout);
+            break;
+        case '\\':
+            fputs("\\\\", stdout);
+            break;
+        default:
+            putchar(crt->dst_name[i]);
+            break;
+        }
+    }
+    putchar ('\n');
+}
+
+/* Make ancestor directory DIR, whose last file name component is
+   COMPONENT, with options OPTIONS.  Assume the working directory is
+   COMPONENT's parent.  */
+
+static int
+make_ancestor (char const *dir, char const *component, void *options)
+{
+  return mkdir (component, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
+}
+
+/* unescape() based on curl_easy_escape() to which the following applies
+COPYRIGHT AND PERMISSION NOTICE
+
+Copyright (c) 1996 - 2009, Daniel Stenberg, <daniel@haxx.se>.
+
+All rights reserved.
+
+Permission to use, copy, modify, and distribute this software for any purpose
+with or without fee is hereby granted, provided that the above copyright
+notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN
+NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of a copyright holder shall not
+be used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization of the copyright holder.
+*/
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string.
+ * If length == 0, the length is assumed to be strlen(string).
+ */
+char *unescape(const char *string, int length)
+{
+  int alloc = (length?length:(int)strlen(string))+1;
+  char *ns = xmalloc(alloc);
+  unsigned char in;
+  int strindex=0;
+  long hex;
+
+  if( !ns )
+    return NULL;
+
+  while(--alloc > 0) {
+    in = *string;
+    if(('%' == in) && isxdigit(string[1]) && isxdigit(string[2])) {
+      /* this is two hexadecimal digits following a '%' */
+      char hexstr[3];
+      char *ptr;
+      hexstr[0] = string[1];
+      hexstr[1] = string[2];
+      hexstr[2] = 0;
+
+      hex = strtol(hexstr, &ptr, 16);
+
+      in = (unsigned char)hex; /* this long is never bigger than 255 anyway */
+
+      string+=2;
+      alloc-=2;
+    }
+
+    ns[strindex++] = in;
+    string++;
+  }
+  ns[strindex]=0; /* terminate it */
+
+  return ns;
+}
+// < PZK
+
 /* Scan the arguments, and copy each by calling copy.
    Return true if successful.  */
 
@@ -580,7 +1074,9 @@ do_copy (int n_files, char **file, const
   bool new_dst = false;
   bool ok = true;
 
-  if (n_files <= !target_directory)
+// PZK >
+  if (!x->mgr_port && !x->read_stdin && n_files <= !target_directory)
+// < PZK
     {
       if (n_files <= 0)
         error (0, 0, _("missing file operand"));
@@ -590,7 +1086,9 @@ do_copy (int n_files, char **file, const
       usage (EXIT_FAILURE);
     }
 
-  if (no_target_directory)
+// PZK >
+  if (!x->mgr_port && !x->read_stdin && no_target_directory)
+// < PZK
     {
       if (target_directory)
         error (EXIT_FAILURE, 0,
@@ -602,7 +1100,9 @@ do_copy (int n_files, char **file, const
           usage (EXIT_FAILURE);
         }
     }
-  else if (!target_directory)
+// PZK >
+  else if (!x->mgr_port && !x->read_stdin && !target_directory)
+// < PZK
     {
       if (2 <= n_files
           && target_directory_operand (file[n_files - 1], &sb, &new_dst))
@@ -612,6 +1112,761 @@ do_copy (int n_files, char **file, const
                quote (file[n_files - 1]));
     }
 
+// PZK >
+#ifdef _OPENMP
+  int pid = 0, procs = 1;
+  int hash_stat_done = 1;
+  int main_done = 0;
+# if HAVE_LIBMPI
+  if (x->mpi) {
+    MPI_Init(NULL, NULL);
+    MPI_Comm_rank(MPI_COMM_WORLD, &pid);
+    MPI_Comm_size(MPI_COMM_WORLD, &procs);
+    // add a thread for MPI handler on main node
+    if (pid == 0) x->threads++;
+  }
+# endif
+  // add a thread for TCP handler on main node
+  if (x->listen_port) x->threads++;
+  // add a thread for file/TCP-MPI handler on main/other nodes
+  x->threads++;
+  // add a thread for stat/hash handler on main node
+  if (!x->mgr_port && pid == 0 &&
+        (x->print_stats || x->print_hash || x->store_hash)) {
+    x->threads++;
+    hash_stat_done = 0;
+  }
+
+  omp_set_num_threads(x->threads);
+  bool oks[x->threads];
+  omp_q_t task_q;
+  omp_q_init(&task_q, x->threads, sizeof(copy_reg_t));
+  x->task_q = &task_q;
+  omp_q_t open_q;
+  omp_q_init(&open_q, x->threads, sizeof(void *));
+  x->open_q = &open_q;
+  omp_q_t send_q;
+  omp_q_init(&send_q, x->threads, sizeof(void *));
+  x->send_q = &send_q;
+
+# if HAVE_LIBGCRYPT
+  gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);
+  if (!gcry_check_version(GCRYPT_VERSION))
+    error (EXIT_FAILURE, 0, _("libgcrypt version mismatch"));
+  gcry_control(GCRYCTL_DISABLE_SECMEM, 0);
+  gcry_control(GCRYCTL_ENABLE_M_GUARD, 0);
+  gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);
+# endif
+# if HAVE_LIBGNUTLS
+  if (x->listen_port || x->mgr_port) {
+    gnutls_global_init();
+    gnutls_global_init_extra();
+  }
+# endif
+
+# pragma omp parallel
+{
+  int tid = omp_get_thread_num();
+  oks[tid] = true;
+  if (!x->mgr_port && pid == 0 && tid == 2 &&
+        (x->print_stats || x->print_hash || x->store_hash)) {
+    ////////////////////////////////////
+    // stat/hash handler on main node //
+    ////////////////////////////////////
+    struct timespec tts[2];
+    if (x->print_stats) {
+      fprintf(stderr, _("      size        rd_mbs  wt_mbs  cp_mbs  file\n"));
+      fprintf(stderr, _("      ----        ------  ------  ------  ----\n"));
+      clock_gettime(CLOCK_REALTIME, &tts[0]);
+    }
+    off_t tsize = 0;
+    int maxcrts = 128;
+    copy_reg_t **crts = xcalloc(maxcrts, sizeof(copy_reg_t *));
+    int ncrts = 0;
+    long long done_tasks = 0;
+    while (!main_done || *x->hash_stat_tasks > done_tasks) {
+      copy_reg_t *crt = omp_q_pop(&send_q);
+      if (crt != NULL && crt->split != crt->nsplits) done_tasks++;
+      if (crt == NULL || crt->dst_name == NULL) {
+        //TODO: do something with error?
+        continue;
+      }
+      if (x->print_stats && crt->split != crt->nsplits) {
+        tsize += crt->stop_offset - crt->start_offset;
+        double mb = (crt->stop_offset - crt->start_offset) / 1000.0 / 1000.0;
+        fprintf(stderr, _("%16lld  %6.1f  %6.1f  %6.1f  %s"),
+            crt->stop_offset - crt->start_offset, mb / crt->read_time,
+            mb / crt->write_time, mb / crt->copy_time, crt->dst_name);
+        if (crt->nsplits > 1)
+            fprintf(stderr, _(" (%lu/%lu)"), crt->split + 1, crt->nsplits);
+        fprintf(stderr, _("\n"));
+      }
+
+      if (x->print_hash && crt->nsplits == 1) {
+        print_hash(x, crt);
+      }
+
+      if (!x->print_hash || crt->nsplits <= 1) {
+        free(crt->src_name);
+        free(crt->dst_name);
+        free(crt->hash_stack);
+        free(crt);
+        continue;
+      }
+
+      int index;
+      int empty = -1;
+      // find existing entry and/or free slot
+      for (index = 0; index < maxcrts; index++) {
+          if (crts[index] == NULL) {
+              if (empty < 0) empty = index;
+              continue;
+          }
+          if (!strcmp(crt->dst_name, crts[index]->dst_name)) break;
+      }
+      if (index >= maxcrts) {
+          // this is the first split received
+          if (empty == -1) {
+              // no free slot found so expand array
+              maxcrts *= 2;
+              //TODO: should probably error out if array gets too big
+              xrealloc(crts, maxcrts * sizeof(copy_reg_t *));
+              bzero(&crts[maxcrts / 2], maxcrts / 2 * sizeof(copy_reg_t *));
+              empty = index;
+          }
+          // first crt has special field values including
+          //   split = nsplits, stop_offset = file size,
+          //   dest_desc = open fd, and hash_stack of size nsplits * hash size
+          crts[empty] = crt;
+      } else {
+# if HAVE_LIBGCRYPT
+        // copy final hash onto shared hash stack
+        memcpy(&crts[index]->hash_stack[crt->split * x->hash_size],
+            crt->hash_stack, x->hash_size);
+        free(crt->hash_stack);
+# endif
+        free(crt->src_name);
+        free(crt->dst_name);
+        free(crt);
+        crt = crts[index];
+        // this works because split will be nsplits in first crt received
+        if (--crt->split == 0) {
+# if HAVE_LIBGCRYPT
+            // finalize hash if last
+            gcry_md_hd_t ctx;
+            gcry_md_open(&ctx, x->hash_type, 0);
+            hash_tree_t htt;
+            htt.n_hash_total = 0;
+            htt.hash_ctx = &ctx;
+            htt.hash_ctx_len = 0;
+//TODO:            if (x->store_hash) htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
+            htt.xattr_len = 0;
+            // this works because dest_desc will be open in first crt received
+            htt.fd = crt->dest_desc;
+            htt.stack_len = 0;
+            // don't compute root of tree when printing subtrees
+            if (!x->check_tree)
+                hash_final(&htt, crt, x, 0, crt->nsplits,
+                    crt->stop_offset - crt->start_offset);
+            // print hash
+            if (x->print_hash) {
+                print_hash(x, crt);
+            }
+            // clean up
+            gcry_md_close(ctx);
+            if (x->store_hash) {
+                close(crt->dest_desc);
+                free(htt.xattr);
+            }
+            free(crt->hash_stack);
+# endif
+            free(crt->src_name);
+            free(crt->dst_name);
+            free(crt);
+            crts[index] = NULL;
+            //TODO: if last, then set done for tcp, etc.
+        }
+      }
+    }
+    if (x->print_stats) {
+        clock_gettime(CLOCK_REALTIME, &tts[1]);
+        double tt = (double) (
+            (double) tts[1].tv_sec + (double) tts[1].tv_nsec / (double) 1.0e9 -
+            (double) tts[0].tv_sec - (double) tts[0].tv_nsec / (double) 1.0e9);
+        double mb = tsize / 1000.0 / 1000.0;
+        fprintf(stderr, _("      ----        ------  ------  ------  ----\n"));
+        fprintf(stderr, _("%16lld                  %6.1f  total\n"),
+            tsize, mb / tt);
+    }
+    hash_stat_done = 1;
+# if HAVE_LIBMPI
+    if (x->mpi) {
+        // send message to MPI handler on main node to break out of
+        // a final receive called just before hash_stat_done is set
+        long long sz = -1;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+    }
+# endif
+# if HAVE_LIBGNUTLS
+  } else if (x->mgr_port && tid == 0) {
+    ////////////////////////////////
+    // TCP handler on other nodes //
+    ////////////////////////////////
+    // initialize tls/srp
+    gnutls_session_t tls_sess;
+    gnutls_srp_client_credentials_t srp_cred;
+    gnutls_srp_allocate_client_credentials(&srp_cred);
+    gnutls_srp_set_client_credentials(srp_cred, x->user, x->pass);
+
+    int nulls = 0;
+    int null_task = 0;
+    int nonnull_task = 0;
+
+    while (nulls < x->threads - 1) {
+      copy_reg_t *crt = omp_q_pop(&send_q);
+      if (crt == NULL && null_task) {
+        nulls++;
+        omp_q_push(&task_q, NULL);
+        continue;
+      } else if (crt != NULL) {
+        nonnull_task = 1;
+      }
+
+      int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+      if (sock < 0)
+        error(EXIT_FAILURE, 0, _("unable to create socket"));
+
+      size_t src_size = 0, dst_size;
+      ssize_t rc = connect(sock, x->mgr_ai->ai_addr, sizeof(struct sockaddr_in));
+      if (!rc) {
+        // initialize tls session
+        gnutls_init(&tls_sess, GNUTLS_CLIENT);
+        gnutls_priority_set_direct(tls_sess, "NORMAL:+SRP", NULL);
+        gnutls_credentials_set(tls_sess, GNUTLS_CRD_SRP, srp_cred);
+        gnutls_transport_set_ptr(tls_sess, (gnutls_transport_ptr_t) sock);
+        if (gnutls_handshake(tls_sess) < 0) {
+            error(0, 0, _("unable to authenticate to server"));
+            //TODO: can this cause deadlocK?
+            omp_q_push(&send_q, crt);
+            continue;
+        }
+      } else {
+        if (nonnull_task) {
+            nulls++;
+            omp_q_push(&task_q, NULL);
+            continue;
+        }
+        error(0, errno, _("connect failed...sleeping"));
+        fflush(stderr);
+        // wait until server starts
+        sleep(1);
+        //TODO: can this cause deadlocK?
+        omp_q_push(&send_q, crt);
+        // probably want some check so don't loop forever
+        continue;
+      }
+
+      if (crt != NULL) {
+        // send final status with times and hash
+        src_size = strlen(crt->src_name) + 1;
+        dst_size = strlen(crt->dst_name) + 1;
+        rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+        rc |= gnutls_record_send(tls_sess, &dst_size, sizeof(dst_size));
+        rc |= gnutls_record_send(tls_sess, crt->src_name, src_size);
+        rc |= gnutls_record_send(tls_sess, crt->dst_name, dst_size);
+        rc |= gnutls_record_send(tls_sess, crt->hash_stack, x->hash_size);
+        rc |= gnutls_record_send(tls_sess, crt, sizeof(copy_reg_t));
+        if (rc < 0)
+            error(0, 0, _("unable to send final status to server"));
+            //TODO: do something else like requeue crt?
+        free(crt->src_name);
+        free(crt->dst_name);
+        free(crt->hash_stack);
+        free(crt);
+      } else {
+        // send task request
+        src_size = 0;
+        rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+
+        // receive task request
+        rc |= gnutls_record_recv(tls_sess, &src_size, sizeof(src_size));
+        if (rc < 0 || src_size == 0) {
+          null_task = 1;
+          nulls++;
+          omp_q_push(&task_q, NULL);
+        } else {
+          rc |= gnutls_record_recv(tls_sess, &dst_size, sizeof(dst_size));
+          if (rc > 0) {
+              char *src_tmp = xmalloc(src_size);
+              char *dst_tmp = xmalloc(dst_size);
+              crt = xmalloc(sizeof(copy_reg_t));
+              rc |= gnutls_record_recv(tls_sess, src_tmp, src_size);
+              rc |= gnutls_record_recv(tls_sess, dst_tmp, dst_size);
+              rc |= gnutls_record_recv(tls_sess, crt, sizeof(copy_reg_t));
+              //TODO: this section still needs work??
+              if (rc > 0) {
+                  crt->src_name = src_tmp;
+                  crt->dst_name = dst_tmp;
+                  crt->hash_stack = xmalloc(x->hash_size);
+                  omp_q_push(&task_q, crt);
+                  omp_q_pop(&open_q);
+                  if (gnutls_record_send(tls_sess, &rc, sizeof(rc)) <= 0)
+                      error(EXIT_FAILURE, 0,
+                          _("unable to send open status to server"));
+              } else {
+                  free(src_tmp);
+                  free(dst_tmp);
+                  free(crt);
+              }
+          }
+        }
+      }
+      if (rc >= 0 || src_size > 0) {
+        // shutdown tls session
+        gnutls_bye(tls_sess, GNUTLS_SHUT_RDWR);
+        shutdown(sock, SHUT_RDWR);
+        gnutls_deinit(tls_sess);
+      }
+    }
+    // free tls/srp resources
+    gnutls_srp_free_client_credentials(srp_cred);
+    gnutls_global_deinit();
+  } else if (x->listen_port && tid == 1) {
+    //////////////////////////////
+    // TCP handler on main node //
+    //////////////////////////////
+    // initialize tls/srp
+    gnutls_srp_server_credentials_t srp_cred;
+    gnutls_srp_allocate_server_credentials(&srp_cred);
+    gnutls_srp_set_server_credentials_file(srp_cred, x->pw_file, x->mg_file);
+
+    int server_sock, client_sock;
+    struct sockaddr_in server_sa, client_sa;
+    socklen_t client_len = sizeof(client_sa);
+
+    server_sa.sin_family = AF_INET;
+    server_sa.sin_addr.s_addr = htonl(INADDR_ANY);
+    server_sa.sin_port = htons(x->listen_port);
+
+    server_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+    if (server_sock < 0)
+        error(EXIT_FAILURE, 0, _("unable to create socket"));
+    if (fcntl(server_sock, F_SETFL, O_NONBLOCK) < 0)
+        error(EXIT_FAILURE, 0, _("unable to set socket option"));
+    if (bind(server_sock, (struct sockaddr *) &server_sa, sizeof(server_sa)) < 0)
+        error(EXIT_FAILURE, 0, _("unable to bind to socket"));
+    if (listen(server_sock, SOMAXCONN) < 0)
+        error(EXIT_FAILURE, 0, _("unable to listen on socket"));
+
+    struct pollfd sfds[1];
+    sfds[0].fd = server_sock;
+    sfds[0].events = POLLIN;
+
+    int null_task = 0;
+
+    while (!main_done || !hash_stat_done) {
+        if (poll(sfds, 1, 1000) <= 0) continue;
+
+        gnutls_session_t tls_sess;
+        gnutls_init(&tls_sess, GNUTLS_SERVER);
+        gnutls_priority_set_direct(tls_sess, "NORMAL:+SRP", NULL);
+        gnutls_credentials_set(tls_sess, GNUTLS_CRD_SRP, srp_cred);
+
+        client_sock =
+            accept(server_sock, (struct sockaddr *) &client_sa, &client_len);
+        if (client_sock < 0) continue;
+        gnutls_transport_set_ptr(tls_sess, (gnutls_transport_ptr_t) client_sock);
+        if (gnutls_handshake(tls_sess) < 0) {
+            close(client_sock);
+            gnutls_deinit(tls_sess);
+            error(0, 0, _("warning: failed authentication attempt from %s:%d"),
+                inet_ntoa(client_sa.sin_addr), ntohs(client_sa.sin_port));
+            continue;
+        }
+
+        size_t src_size, dst_size;
+        ssize_t rc = 0;
+        copy_reg_t *crt;
+        //TODO: need timeouts throughout here
+        if (gnutls_record_recv(tls_sess, &src_size, sizeof(src_size)) < 0) continue;
+        if (src_size > 0) {
+          if (gnutls_record_recv(tls_sess, &dst_size, sizeof(dst_size)) > 0) {
+              char *src_tmp = xmalloc(src_size);
+              char *dst_tmp = xmalloc(dst_size);
+              unsigned char *hash_tmp = xmalloc(x->hash_size);
+              crt = xmalloc(sizeof(copy_reg_t));
+              rc |= gnutls_record_recv(tls_sess, src_tmp, src_size);
+              rc |= gnutls_record_recv(tls_sess, dst_tmp, dst_size);
+              rc |= gnutls_record_recv(tls_sess, hash_tmp, x->hash_size);
+              rc |= gnutls_record_recv(tls_sess, crt, sizeof(copy_reg_t));
+              //TODO: this section still needs work??
+              if (rc > 0) {
+                  crt->src_name = src_tmp;
+                  crt->dst_name = dst_tmp;
+                  crt->hash_stack = hash_tmp;
+                  omp_q_push(&send_q, crt);
+              } else {
+                  free(src_tmp);
+                  free(dst_tmp);
+                  free(hash_tmp);
+                  crt->dst_name = NULL;
+                  // indicate error with null dst
+                  omp_q_push(&send_q, crt);
+                  //TODO: see if this technique can be used elsewhere
+              }
+          }
+        } else {
+            crt = null_task ? NULL : omp_q_pop(&task_q);
+            if (crt == NULL) {
+                null_task = 1;
+                src_size = 0;
+                rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+            } else {
+                // this assumes same arch on client/server
+                src_size = strlen(crt->src_name) + 1;
+                dst_size = strlen(crt->dst_name) + 1;
+                rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+                rc |= gnutls_record_send(tls_sess, &dst_size, sizeof(dst_size));
+                rc |= gnutls_record_send(tls_sess, crt->src_name, src_size);
+                rc |= gnutls_record_send(tls_sess, crt->dst_name, dst_size);
+                rc |= gnutls_record_send(tls_sess, crt, sizeof(copy_reg_t));
+                if (rc <= 0) {
+                    omp_q_push(&task_q, crt);
+                    error(0, 0, _("warning: failure responding to client (will retry)"));
+                } else {
+                    // wait for message indicating open
+                    //TODO: need timeout here
+                    gnutls_record_recv(tls_sess, &rc, sizeof(rc));
+                    // indicate that file has been opened to local master
+                    omp_q_push(&open_q, NULL);
+                    free(crt->src_name);
+                    free(crt->dst_name);
+                    free(crt->hash_stack);
+                    free(crt);
+                }
+            }
+        }
+        gnutls_bye(tls_sess, GNUTLS_SHUT_WR);
+        close(client_sock);
+        gnutls_deinit(tls_sess);
+    }
+    close(server_sock);
+    gnutls_srp_free_server_credentials(srp_cred);
+    gnutls_global_deinit();
+# endif
+# if HAVE_LIBMPI
+  } else if (pid != 0 && tid == 0) {
+    ////////////////////////////////
+    // MPI handler on other nodes //
+    ////////////////////////////////
+    int nulls = 0;
+    int null_task = 0;
+    int nonnull_task = 0;
+
+    while (nulls < x->threads - 1) {
+      copy_reg_t *crt = omp_q_pop(&send_q);
+      if (crt == NULL && null_task) {
+          nulls++;
+          omp_q_push(&task_q, NULL);
+          continue;
+      } else if (crt != NULL) {
+          nonnull_task = 1;
+      }
+
+      size_t src_size, dst_size;
+      long long sz;
+      int pos = 0;
+
+      if (crt != NULL) {
+        // send final status with times and hash
+        src_size = strlen(crt->src_name) + 1;
+        dst_size = strlen(crt->dst_name) + 1;
+        sz = src_size + dst_size + x->hash_size + sizeof(copy_reg_t);
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+
+        // pack crt into one big byte array
+        char pack[sz];
+        // this assumes same arch on client/server
+        MPI_Pack(&src_size, sizeof(src_size),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&dst_size, sizeof(dst_size),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(crt->src_name, src_size,
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(crt->dst_name, dst_size,
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        if (x->hash_size)
+            MPI_Pack(crt->hash_stack, x->hash_size,
+                MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->dst_mode, sizeof(crt->dst_mode),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->src_atime, sizeof(crt->src_atime),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->src_mtime, sizeof(crt->src_mtime),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->dst_blksize, sizeof(crt->dst_blksize),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->read_time, sizeof(crt->read_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->write_time, sizeof(crt->write_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->copy_time, sizeof(crt->copy_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->start_offset, sizeof(crt->start_offset),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->stop_offset, sizeof(crt->stop_offset),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->nsplits, sizeof(crt->nsplits),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&crt->split, sizeof(crt->split),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+
+        MPI_Send(pack, pos, MPI_PACKED, 0, 1, MPI_COMM_WORLD);
+
+        free(crt->src_name);
+        free(crt->dst_name);
+        free(crt->hash_stack);
+        free(crt);
+      } else {
+        // send task request
+        sz = 0;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+
+        // receive task request
+        MPI_Status stat;
+        int rc = MPI_Recv(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD, &stat);
+        if (rc || sz == 0) {
+            null_task = 1;
+            nulls++;
+            omp_q_push(&task_q, NULL);
+        } else {
+            // unpack crt from one big byte array
+            char pack[sz];
+            MPI_Recv(pack, sz, MPI_PACKED, 0, 1, MPI_COMM_WORLD, &stat);
+            // this assumes same arch on client/server
+            MPI_Unpack(pack, sz, &pos, &src_size, sizeof(src_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &dst_size, sizeof(dst_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            crt = xmalloc(sizeof(copy_reg_t));
+            crt->src_name = xmalloc(src_size);
+            crt->dst_name = xmalloc(dst_size);
+            crt->hash_stack = xmalloc(x->hash_size);
+            MPI_Unpack(pack, sz, &pos, crt->src_name, src_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, crt->dst_name, dst_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->dst_mode, sizeof(crt->dst_mode),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->src_atime, sizeof(crt->src_atime),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->src_mtime, sizeof(crt->src_mtime),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->dst_blksize, sizeof(crt->dst_blksize),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->read_time, sizeof(crt->read_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->write_time, sizeof(crt->write_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->copy_time, sizeof(crt->copy_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->start_offset, sizeof(crt->start_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->stop_offset, sizeof(crt->stop_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->nsplits, sizeof(crt->nsplits),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->split, sizeof(crt->split),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            omp_q_push(&task_q, crt);
+            omp_q_pop(&open_q);
+            sz = 0;
+            MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+        }
+      }
+    }
+  } else if (x->mpi && pid == 0 && tid == 1) {
+    //////////////////////////////
+    // MPI handler on main node //
+    //////////////////////////////
+    int null_task = 0;
+    MPI_Status stat;
+    long long sz;
+    int mpi_recv = 0;
+
+    while (!main_done || !hash_stat_done || x->mpi && mpi_recv < 2) {
+        if (MPI_Recv(&sz, 1, MPI_LONG_LONG, MPI_ANY_SOURCE, MPI_ANY_TAG,
+                MPI_COMM_WORLD, &stat)) break;
+
+        size_t src_size, dst_size;
+        copy_reg_t *crt;
+        int pos = 0;
+
+        if (sz > 0) {
+            // unpack crt from one big byte array
+            char pack[sz];
+            if (MPI_Recv(pack, sz, MPI_PACKED, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD, &stat)) continue;
+            // this assumes same arch on client/server
+            MPI_Unpack(pack, sz, &pos, &src_size, sizeof(src_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &dst_size, sizeof(dst_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            crt = xmalloc(sizeof(copy_reg_t));
+            crt->src_name = xmalloc(src_size);
+            crt->dst_name = xmalloc(dst_size);
+            crt->hash_stack = xmalloc(x->hash_size);
+            MPI_Unpack(pack, sz, &pos, crt->src_name, src_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, crt->dst_name, dst_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            if (x->hash_size)
+                MPI_Unpack(pack, sz, &pos, crt->hash_stack, x->hash_size,
+                    MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->dst_mode, sizeof(crt->dst_mode),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->src_atime, sizeof(crt->src_atime),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->src_mtime, sizeof(crt->src_mtime),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->dst_blksize, sizeof(crt->dst_blksize),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->read_time, sizeof(crt->read_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->write_time, sizeof(crt->write_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->copy_time, sizeof(crt->copy_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->start_offset, sizeof(crt->start_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->stop_offset, sizeof(crt->stop_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->nsplits, sizeof(crt->nsplits),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &crt->split, sizeof(crt->split),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            omp_q_push(&send_q, crt);
+        } else if (sz == 0) {
+            crt = null_task ? NULL : omp_q_pop(&task_q);
+            if (crt == NULL) {
+                null_task = 1;
+                sz = 0;
+                MPI_Send(&sz, 1, MPI_LONG_LONG, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD);
+            } else {
+                src_size = strlen(crt->src_name) + 1;
+                dst_size = strlen(crt->dst_name) + 1;
+                sz = src_size + dst_size + sizeof(copy_reg_t);
+                MPI_Send(&sz, 1, MPI_LONG_LONG, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD);
+                // pack crt into one big byte array
+                char pack[sz];
+                // this assumes same arch on client/server
+                MPI_Pack(&src_size, sizeof(src_size),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&dst_size, sizeof(dst_size),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(crt->src_name, src_size,
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(crt->dst_name, dst_size,
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->dst_mode, sizeof(crt->dst_mode),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->src_atime, sizeof(crt->src_atime),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->src_mtime, sizeof(crt->src_mtime),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->dst_blksize, sizeof(crt->dst_blksize),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->read_time, sizeof(crt->read_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->write_time, sizeof(crt->write_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->copy_time, sizeof(crt->copy_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->start_offset, sizeof(crt->start_offset),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->stop_offset, sizeof(crt->stop_offset),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->nsplits, sizeof(crt->nsplits),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&crt->split, sizeof(crt->split),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+
+                MPI_Send(pack, pos, MPI_PACKED, stat.MPI_SOURCE, stat.MPI_TAG,
+                    MPI_COMM_WORLD);
+                // wait for message indicating open
+                //TODO: need timeout here
+                MPI_Recv(&sz, 1, MPI_LONG_LONG, stat.MPI_SOURCE, stat.MPI_TAG,
+                    MPI_COMM_WORLD, &stat);
+                // indicate that file has been opened to local master
+                omp_q_push(&open_q, NULL);
+                free(crt->src_name);
+                free(crt->dst_name);
+                free(crt->hash_stack);
+                free(crt);
+            }
+        } else {
+            // main and hash/stat done message to prevent deadlock
+            mpi_recv++;
+        }
+    }
+# endif
+  } else if (tid != 0) {
+    ///////////////////////////////
+    // copy handler on all nodes //
+    ///////////////////////////////
+    // indicate ready for request on other nodes
+    if (x->mgr_port || pid != 0) omp_q_push(&send_q, NULL);
+    copy_reg_t *crt;
+    while ((crt = omp_q_pop(&task_q)) != NULL) {
+      crt->source_desc =
+        open(crt->src_name, (O_RDONLY | O_BINARY | x->read_mode |
+          (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+      if (crt->source_desc < 0 && x->read_mode)
+        crt->source_desc = open(crt->src_name, (O_RDONLY | O_BINARY |
+          (x->dereference == DEREF_NEVER ? O_NOFOLLOW : 0)));
+      if (crt->source_desc < 0)
+        error(0, errno, _("warning: unable to open %s for read"), quote(crt->src_name));
+      crt->dest_desc = open(crt->dst_name, O_WRONLY | O_BINARY | x->write_mode);
+      if (crt->dest_desc < 0)
+        error(0, errno, _("warning: unable to open %s for write"), quote(crt->dst_name));
+      if (lseek(crt->source_desc, crt->start_offset, SEEK_SET) < 0)
+        error(0, errno, _("warning: unable to seek in %s"), quote(crt->src_name));
+      if (lseek(crt->dest_desc, crt->start_offset, SEEK_SET) < 0)
+        error(0, errno, _("warning: unable to seek in %s"), quote(crt->dst_name));
+      //TODO: additional error handling if can't open or seek?
+      // indicate that file has been opened
+      omp_q_push(&open_q, NULL);
+      struct timespec ts[2];
+      if (x->print_stats) clock_gettime(CLOCK_REALTIME, &ts[0]);
+      oks[tid] &= copy_reg_task(crt, x);
+      if (x->print_stats) {
+        clock_gettime(CLOCK_REALTIME, &ts[1]);
+        crt->copy_time = (double) (
+          (double) ts[1].tv_sec + (double) ts[1].tv_nsec / (double) 1.0e9 -
+          (double) ts[0].tv_sec - (double) ts[0].tv_nsec / (double) 1.0e9);
+      }
+      if (x->print_stats || x->print_hash ||
+            x->store_hash && crt->nsplits > 1) {
+        omp_q_push(&send_q, crt);
+      } else {
+        free(crt->src_name);
+        free(crt->dst_name);
+        free(crt->hash_stack);
+        free(crt);
+      }
+      // indicate ready for request on other nodes
+      if (x->mgr_port || pid != 0) omp_q_push(&send_q, NULL);
+    }
+  } else {
+#endif
+// < PZK
+
   if (target_directory)
     {
       /* cp file1...filen edir
@@ -709,6 +1964,120 @@ do_copy (int n_files, char **file, const
           free (dst_name);
         }
     }
+// PZK >
+  else if (x->read_stdin)
+    {
+      /* Start with a buffer larger than PATH_MAX, but beware of systems
+         on which PATH_MAX is very large -- e.g., INT_MAX.  */
+      size_t buf_max = MIN(2 * PATH_MAX, 32 * 1024);
+      char *buf = xmalloc(buf_max);
+
+      char *new_dest;
+      char *source;
+      char *dest;
+      bool unused;
+
+      while (fgets(buf, buf_max, stdin) != NULL) {
+        buf[strcspn(buf, "\n")] = '\0';
+        if (buf[0] == '\0') {
+            //TODO: error handling if string too long
+            continue;
+        }
+        size_t ifile2 = strcspn(buf, " ");
+        if (buf[ifile2] == '\0') continue;
+        buf[ifile2++] = '\0';
+        size_t irange = strcspn(&buf[ifile2], " ");
+        if (buf[ifile2 + irange] == '\0') {
+            irange = 0;
+        } else {
+            irange = ifile2 + irange;
+            buf[irange++] = '\0';
+        }
+        source = unescape(buf, 0);
+        dest = unescape(&buf[ifile2], 0);
+        if (source == NULL || dest == NULL) {
+            //TODO: error handling if can't unescape
+            continue;
+        }
+
+        /* When the force and backup options have been specified and
+           the source and destination are the same name for an existing
+           regular file, convert the user's command, e.g.,
+           `cp --force --backup foo foo' to `cp --force foo fooSUFFIX'
+           where SUFFIX is determined by any version control options used.  */
+
+        if (x->unlink_dest_after_failed_open
+            && x->backup_type != no_backups
+            && STREQ (source, dest)
+            && !new_dst && S_ISREG (sb.st_mode))
+          {
+            static struct cp_options x_tmp;
+
+            new_dest = find_backup_file_name (dest, x->backup_type);
+            /* Set x->backup_type to `no_backups' so that the normal backup
+               mechanism is not used when performing the actual copy.
+               backup_type must be set to `no_backups' only *after* the above
+               call to find_backup_file_name -- that function uses
+               backup_type to determine the suffix it applies.  */
+            x_tmp = *x;
+            x_tmp.backup_type = no_backups;
+            x = &x_tmp;
+          }
+        else
+          {
+            new_dest = dest;
+          }
+
+        bool save_working_directory =
+          ! (IS_ABSOLUTE_FILE_NAME (source) && IS_ABSOLUTE_FILE_NAME (new_dest));
+        int status = EXIT_SUCCESS;
+
+        struct savewd wd;
+        savewd_init (&wd);
+        if (! save_working_directory)
+            savewd_finish (&wd);
+
+        if (mkancesdirs (new_dest, &wd, make_ancestor, x) == -1)
+          {
+            error (0, errno, _("cannot create directory %s"), new_dest);
+            status = EXIT_FAILURE;
+          }
+
+        if (save_working_directory)
+          {
+            int restore_result = savewd_restore (&wd, status);
+            int restore_errno = errno;
+            savewd_finish (&wd);
+            if (EXIT_SUCCESS < restore_result)
+                //TODO: error handling?
+                continue;
+            if (restore_result < 0 && status == EXIT_SUCCESS)
+              {
+                error (0, restore_errno, _("cannot create directory %s"), new_dest);
+                //TODO: error handling?
+                continue;
+              }
+          }
+
+        if (irange > 0) {
+            off_t x1, x2;
+            while (sscanf(&buf[irange], "%lld-%lld", &x1, &x2) == 2) {
+                x->offset = x1;
+                x->length = x2 - x1;
+                ok &= copy (source, new_dest, 0, x, &unused, NULL);
+                irange += strcspn(&buf[irange], ",");
+                if (buf[irange] == ',') irange++;
+            }
+        } else {
+            x->offset = 0;
+            x->length = 0;
+            ok = copy (source, new_dest, 0, x, &unused, NULL);
+        }
+        free(source);
+        free(dest);
+      }
+    }
+// < PZK
   else /* !target_directory */
     {
       char const *new_dest;
@@ -753,6 +2122,41 @@ do_copy (int n_files, char **file, const
 
       ok = copy (source, new_dest, 0, x, &unused, NULL);
     }
+// PZK >
+#ifdef _OPENMP
+    // indicate that main thread is done traversing file system
+    main_done = 1;
+    // send terminating NULL task to stat/hash thread
+    omp_q_push(&send_q, NULL);
+    // send terminating NULL task to all worker threads
+    for (int i = 0; i < x->threads - 1; i++)
+        omp_q_push(&task_q, NULL);
+# if HAVE_LIBMPI
+    if (x->mpi) {
+        // send message to MPI handler on main node to break out of
+        // a final receive called just before main_done is set
+        long long sz = -1;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+    }
+# endif
+  }
+}
+
+# if HAVE_LIBMPI
+  if (x->mpi) MPI_Finalize();
+# endif
+
+  // destroy all queues
+  omp_q_destroy(&send_q);
+  omp_q_destroy(&open_q);
+  omp_q_destroy(&task_q);
+
+  //TODO: this no longer works with mpi/tcp
+  // reduce oks array to single value
+  for (int i = 0; i < x->threads; i++)
+    ok &= oks[i];
+#endif
+// < PZK
 
   return ok;
 }
@@ -761,6 +2165,60 @@ static void
 cp_option_init (struct cp_options *x)
 {
   cp_options_default (x);
+// PZK >
+  x->buffer_size = DEFAULT_BUFFER_SIZE * 1024 * 1024;
+  x->check_tree = false;
+#if DEFAULT_DOUBLE_BUFFER
+  x->double_buffer = true;
+#else
+  x->double_buffer = false;
+#endif
+#if DEFAULT_FADVISE_READ
+  x->fadvise_read = true;
+#else
+  x->fadvise_read = false;
+#endif
+#if DEFAULT_FADVISE_WRITE
+  x->fadvise_write = true;
+#else
+  x->fadvise_write = false;
+#endif
+  x->hash_size = 0;
+  x->hash_stat_tasks = xcalloc(1, sizeof(long long));
+#if HAVE_LIBGCRYPT
+  x->hash_type = DEFAULT_HASH_TYPE;
+#endif
+  x->length = 0;
+  x->listen_port = 0;
+  x->mg_file = 0;
+  x->mgr_ai = NULL;
+  x->mgr_port = 0;
+  x->mpi = false;
+  x->offset = 0;
+  x->open_q = NULL;
+  x->pass = NULL;
+  x->print_hash = false;
+  x->print_stats = false;
+  x->pw_file = 0;
+#if DEFAULT_DIRECT_READ
+  x->read_mode = O_DIRECT;
+#else
+  x->read_mode = 0;
+#endif
+  x->read_stdin = false;
+  x->skip_chmod = false;
+  x->split_size = DEFAULT_SPLIT_SIZE * 1024 * 1024;
+  x->hash_leaf_size = x->split_size; // this must follow split_size
+  x->store_hash = false;
+  x->task_q = NULL;
+  x->threads = DEFAULT_THREADS;
+  x->user = NULL;
+#if DEFAULT_DIRECT_WRITE
+  x->write_mode = O_DIRECT;
+#else
+  x->write_mode = 0;
+#endif
+// < PZK
   x->copy_as_regular = true;
   x->dereference = DEREF_UNDEFINED;
   x->unlink_dest_before_opening = false;
@@ -929,6 +2387,153 @@ main (int argc, char **argv)
     {
       switch (c)
         {
+// PZK >
+        case BUFFER_SIZE_OPTION:
+          x.buffer_size = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.buffer_size < 1 || x.buffer_size > 128)
+            error (EXIT_FAILURE, 0, _("invalid buffer size"));
+          size_t tmp_bs = x.buffer_size;
+          size_t new_bs = 1;
+          while (tmp_bs >>= 1) new_bs <<= 1;
+          if (x.buffer_size != new_bs)
+            error(0, 0, _("note: buffer size has been adjusted to %lld"), new_bs);
+          x.buffer_size = new_bs * 1024 * 1024;
+          break;
+        case DIRECT_READ_OPTION:
+          x.read_mode = O_DIRECT;
+          break;
+        case DIRECT_WRITE_OPTION:
+          x.write_mode = O_DIRECT;
+          break;
+        case DOUBLE_BUFFER_OPTION:
+          x.double_buffer = true;
+          break;
+        case LENGTH_OPTION:
+          x.length = strtoll(optarg, (char **) NULL, 10);
+          if (x.length < 1)
+            error (EXIT_FAILURE, 0, _("invalid length"));
+          break;
+        case NO_DIRECT_READ_OPTION:
+          x.read_mode = 0;
+          break;
+        case NO_DIRECT_WRITE_OPTION:
+          x.write_mode = 0;
+          break;
+        case NO_DOUBLE_BUFFER_OPTION:
+          x.double_buffer = false;
+          break;
+        case OFFSET_OPTION:
+          x.offset = strtoll(optarg, (char **) NULL, 10);
+          if (x.offset < 0)
+            error (EXIT_FAILURE, 0, _("invalid offset"));
+          break;
+        case READ_STDIN_OPTION:
+          x.read_stdin = true;
+          break;
+        case SKIP_CHMOD_OPTION:
+          x.skip_chmod = true;
+          break;
+#ifdef POSIX_FADV_DONTNEED
+        case FADVISE_READ_OPTION:
+          x.fadvise_read = true;
+          break;
+        case FADVISE_WRITE_OPTION:
+          x.fadvise_write = true;
+          break;
+        case NO_FADVISE_READ_OPTION:
+          x.fadvise_read = false;
+          break;
+        case NO_FADVISE_WRITE_OPTION:
+          x.fadvise_write = false;
+          break;
+#endif
+#ifdef _OPENMP
+        case PRINT_STATS_OPTION:
+          x.print_stats = true;
+          break;
+        case SPLIT_SIZE_OPTION:
+          x.split_size = strtoll(optarg, (char **) NULL, 10);
+          if (x.split_size < 0)
+            error (EXIT_FAILURE, 0, _("invalid split size"));
+          if (x.split_size > 0) {
+            off_t tmp_ss = x.split_size;
+            off_t new_ss = 1;
+            while (tmp_ss >>= 1) new_ss <<= 1;
+            if (x.split_size != new_ss)
+              error(0, 0, _("note: split size has been adjusted to %lld"), new_ss);
+            x.split_size = new_ss * 1024 * 1024;
+          }
+          break;
+        case THREADS_OPTION:
+          x.threads = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.threads < 1 || x.threads > 512)
+            error (EXIT_FAILURE, 0, _("invalid number of threads"));
+          break;
+#endif
+#if HAVE_LIBLUSTREAPI
+        case PRINT_STRIPE_OPTION:
+          x.print_stripe = true;
+          break;
+#endif
+#if HAVE_LIBGCRYPT
+        case CHECK_TREE_OPTION:
+          x.check_tree = true;
+          break;
+        case HASH_LEAF_SIZE_OPTION:
+          x.hash_leaf_size = strtoll(optarg, (char **) NULL, 10);
+          if (x.hash_leaf_size < 1)
+            error (EXIT_FAILURE, 0, _("invalid hash leaf size"));
+          off_t tmp_ls = x.hash_leaf_size;
+          off_t new_ls = 1;
+          while (tmp_ls >>= 1) new_ls <<= 1;
+          if (x.hash_leaf_size != new_ls)
+            error(0, 0, _("note: hash leaf size has been adjusted to %lld"), new_ls);
+          x.hash_leaf_size = new_ls * 1024;
+          break;
+        case HASH_TYPE_OPTION:
+          x.hash_type = -1;
+          // 400 taken from libgcrypt benchmark code
+          for (int i = 1; i < 400; i++) {
+            if (!gcry_md_test_algo(i) &&
+                    !strcasecmp(optarg, gcry_md_algo_name(i))) {
+                x.hash_type = i;
+                break;
+            }
+          }
+          if (x.hash_type < 0) error (EXIT_FAILURE, 0, _("invalid hash type"));
+          break;
+        case PRINT_HASH_OPTION:
+          x.print_hash = true;
+          break;
+        case STORE_HASH_OPTION:
+          x.store_hash = true;
+          break;
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+        case MPI_OPTION:
+          x.mpi = true;
+          break;
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+        case LISTEN_PORT_OPTION:
+          x.listen_port = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.listen_port < 1 || x.listen_port > 65535)
+            error (EXIT_FAILURE, 0, _("invalid listen port"));
+          break;
+        case MANAGER_HOST_OPTION:
+          if (getaddrinfo(optarg, NULL, NULL, &x.mgr_ai))
+            error (EXIT_FAILURE, 0, _("unable to resolve manager host"));
+          break;
+        case MANAGER_PORT_OPTION:
+          x.mgr_port = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.mgr_port < 1 || x.mgr_port > 65535)
+            error (EXIT_FAILURE, 0, _("invalid manager port"));
+          break;
+        case PASSWORD_FILE_OPTION:
+          x.pw_file = xstrdup(optarg);
+          break;
+#endif
+// < PZK
         case SPARSE_OPTION:
           x.sparse_mode = XARGMATCH ("--sparse", optarg,
                                      sparse_type_string, sparse_type);
@@ -1151,6 +2756,98 @@ main (int argc, char **argv)
 
   hash_init ();
 
+// PZK >
+  if (target_directory && x.read_stdin)
+    error (EXIT_FAILURE, 0, _("cannot use --target-directory (-t) with --read-stdin"));
+  if (x.read_mode && x.fadvise_read) {
+#if DEFAULT_DIRECT_READ
+    x.read_mode = 0;
+#elif DEFAULT_FADVISE_READ
+    x.fadvise_read = false;
+#else
+    error(0, 0, _("note: --fadvise-read disabled in favor of --direct-read"));
+    x.fadvise_read = false;
+#endif
+  }
+  if (x.write_mode && x.fadvise_write) {
+#if DEFAULT_DIRECT_WRITE
+    x.write_mode = 0;
+#elif DEFAULT_FADVISE_WRITE
+    x.fadvise_write = false;
+#else
+    error(0, 0, _("note: --fadvise-write disabled in favor of --direct-write"));
+    x.fadvise_write = false;
+#endif
+  }
+#if HAVE_LIBGCRYPT
+  //TODO: temporarily disable options that excercise filesystem bugs
+  if (x.store_hash) {
+    error(0, 0, _("note: hash stores have been temporarily disabled in this version"));
+    x.store_hash = false;
+  }
+  //TODO: reenable above when filesystem bugs are fixed
+  if ((x.offset || x.length) && x.store_hash)
+    error(EXIT_FAILURE, 0, _("cannot store hash during partial file copy"));
+  if (x.split_size > 0 && x.split_size < x.buffer_size) {
+    error(0, 0, _("note: split size has been adjusted to the buffer size"));
+    x.split_size = x.buffer_size;
+  }
+  if (x.split_size > 0 && x.split_size < x.hash_leaf_size) {
+    error(0, 0, _("note: hash leaf size has been adjusted to the split size"));
+    x.hash_leaf_size = x.split_size;
+  }
+  if (!x.hash_leaf_size) {
+    error(0, 0, _("note: hash leaf size has been adjusted to 1GiB"));
+    x.hash_leaf_size = 1024 * 1024 * 1024;
+  }
+  x.hash_size = gcry_md_get_algo_dlen(x.hash_type);
+#endif
+#ifndef _OPENMP
+  x.threads = 0;
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  if (x.mgr_ai != NULL && x.mgr_port)
+    ((struct sockaddr_in *) x.mgr_ai->ai_addr)->sin_port = htons(x.mgr_port);
+  if (x.mgr_ai != NULL && x.mgr_port == 0 || x.mgr_ai == NULL && x.mgr_port)
+    error (EXIT_FAILURE, 0, _("must specify both manager host and manager port"));
+  if (x.listen_port && x.mgr_port)
+    error (EXIT_FAILURE, 0, _("cannot use --listen-port with --manager-port"));
+  if (x.listen_port && x.pw_file) {
+    struct stat st;
+    // delay changing pw_file until after password generation
+    char *tmppw = xmalloc(strlen(x.pw_file) + 4);
+    x.mg_file = xmalloc(strlen(x.pw_file) + 4);
+    sprintf(tmppw, "%s.pw", x.pw_file);
+    sprintf(x.mg_file, "%s.mg", x.pw_file);
+    if (stat(x.mg_file, &st) < 0 && stat(tmppw, &st) < 0) {
+      if (srp_generate_auth(x.pw_file, tmppw, x.mg_file) < 0)
+        error (EXIT_FAILURE, 0, _("unable to create manager password files"));
+    } else if (stat(x.mg_file, &st) < 0) {
+      error (EXIT_FAILURE, 0,
+          _("manager modulus/generator file %s does not exist"),
+          quote(x.mg_file));
+    } else if (stat(tmppw, &st) < 0) {
+      error (EXIT_FAILURE, 0, _("manager password file %s does not exist"),
+          quote(tmppw));
+    }
+    free(x.pw_file);
+    x.pw_file = tmppw;
+  } else if (x.pw_file) {
+    struct passwd *pw = getpwuid(getuid());
+    if (pw == NULL)
+        error (EXIT_FAILURE, 0, _("unable to determine user name"));
+    x.user = xstrdup(pw->pw_name);
+    FILE *f = fopen(x.pw_file, "r");
+    if (f == NULL)
+      error (EXIT_FAILURE, 0, _("unable to read user password file"));
+    x.pass = xmalloc(32);
+    if (fread(x.pass, 16, 1, f) < 1)
+      error (EXIT_FAILURE, 0, _("unable to read user password"));
+    x.pass[16] = 0;
+  }
+#endif
+// < PZK
+
   ok = do_copy (argc - optind, argv + optind,
                 target_directory, no_target_directory, &x);
 
@@ -1158,3 +2855,4 @@ main (int argc, char **argv)
 
   exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);
 }
+
diff -rupN orig/src/mcore-omp.h new/src/mcore-omp.h
--- orig/src/mcore-omp.h	1969-12-31 16:00:00.000000000 -0800
+++ new/src/mcore-omp.h	2012-10-08 13:50:49.056671471 -0700
@@ -0,0 +1,128 @@
+// PZK >
+/* mcore-omp.h -- OpenMP semaphores and semaphore-protected queues
+
+   Copyright 2010 United States Government National Aeronautics and
+   Space Administration (NASA).  No copyright is claimed in the United
+   States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License Version 3 with
+   Additional Terms below (per Section 7 of GPL V3).
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
+
+#ifndef MCORE_OMP_H
+# define MCORE_OMP_H
+
+# include <stdlib.h>
+
+# ifdef _OPENMP
+#  include <omp.h>
+
+typedef struct {
+    omp_lock_t mutex;
+    omp_lock_t *waits;
+    int free;
+    int size;
+} omp_sem_t;
+
+void omp_sem_init(omp_sem_t *s, int size, int free);
+void omp_sem_destroy(omp_sem_t *s);
+void omp_sem_procure(omp_sem_t *s);
+void omp_sem_vacate(omp_sem_t *s);
+int omp_sem_free(omp_sem_t *s);
+
+# endif
+
+typedef struct {
+# ifdef _OPENMP
+    omp_sem_t max_sem;
+    omp_sem_t min_sem;
+    omp_lock_t q_lock;
+# endif
+    int size;
+    size_t ptr_size;
+    int i_read;
+    int i_write;
+    void **vals;
+} omp_q_t;
+
+# ifdef _OPENMP
+
+void omp_q_init(omp_q_t *q, int size, size_t ptr_size);
+void omp_q_destroy(omp_q_t *q);
+void omp_q_push(omp_q_t *q, void *val);
+void *omp_q_pop(omp_q_t *q);
+int omp_q_size(omp_q_t *q);
+
+# endif
+#endif
+// < PZK
+
diff -rupN orig/src/mcore.c new/src/mcore.c
--- orig/src/mcore.c	1969-12-31 16:00:00.000000000 -0800
+++ new/src/mcore.c	2012-10-08 13:50:49.052715248 -0700
@@ -0,0 +1,598 @@
+// PZK >
+/* mcore.c -- core functions for copying/hashing files
+
+   Copyright 2010 United States Government National Aeronautics and
+   Space Administration (NASA).  No copyright is claimed in the United
+   States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License Version 3 with
+   Additional Terms below (per Section 7 of GPL V3).
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
+
+#include "mcore.h"
+
+///////////////////
+//// Hash Tree ////
+///////////////////
+
+#if HAVE_LIBGCRYPT
+# include <gcrypt.h>
+# include "copy.h"
+
+void hash_tree(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+        const char *buf, off_t n_read_total, off_t size)
+{
+    off_t n_hash = 0;
+    while (htt->n_hash_total + co->hash_leaf_size <= n_read_total) {
+        hash_leaf(htt, crt, co, &buf[n_hash],
+            co->hash_leaf_size - htt->hash_ctx_len);
+        n_hash += co->hash_leaf_size - htt->hash_ctx_len;
+        htt->hash_ctx_len = 0;
+        htt->n_hash_total += co->hash_leaf_size;
+    }
+    if (n_read_total >= crt->stop_offset - crt->start_offset) {
+        // last iteration
+        if (n_read_total > htt->n_hash_total)
+            hash_leaf(htt, crt, co, &buf[n_hash],
+                n_read_total - htt->n_hash_total - htt->hash_ctx_len);
+        if (co->store_hash && crt->split == 0) {
+            // first split will write summary info
+            char val[128];
+            sprintf(val, "%s", (char *) gcry_md_algo_name(co->hash_type));
+            //TODO:fsetxattr(htt->fd, "user.hash.type", val, strlen(val), 0);
+            //TODO: check for errors
+            sprintf(val, "%lld", co->hash_leaf_size);
+            //TODO:fsetxattr(htt->fd, "user.hash.leaf.size", val, strlen(val), 0);
+        }
+        if (co->store_hash && htt->xattr_len > 0) {
+            // store leftover xattr buffer
+            char name[128];
+            sprintf(name, "user.hash.tree.%lld.%lld",
+                crt->start_offset, crt->stop_offset);
+            //TODO:fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
+            //TODO: check for errors
+        }
+    } else {
+        // store in hash context for next iteration
+        if (n_read_total - htt->n_hash_total > 0)
+            gcry_md_write(*htt->hash_ctx, &buf[n_hash],
+                n_read_total - htt->n_hash_total - htt->hash_ctx_len);
+        htt->hash_ctx_len = n_read_total - htt->n_hash_total;
+    }
+}
+
+void hash_final(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+        size_t start, size_t end, off_t size)
+{
+    if (start + 1 >= end) return;
+
+    // find nearest power of 2 less than (end - start)
+    size_t n = 1;
+    size_t leafs = end - start;
+    while (n < leafs) n <<= 1;
+    n >>= 1;
+
+    // compute hash of left and right subtrees
+    gcry_md_hd_t ctx;
+    gcry_md_open(&ctx, co->hash_type, 0);
+    hash_final(htt, crt, co, start, start + n, size);
+    gcry_md_write(ctx, &crt->hash_stack[start * co->hash_size], co->hash_size);
+    if (end > start + n) {
+        hash_final(htt, crt, co, start + n, end, size);
+        gcry_md_write(ctx, &crt->hash_stack[(start + n) * co->hash_size],
+            co->hash_size);
+    }
+    unsigned char *hash = gcry_md_read(ctx, 0);
+    memcpy(&crt->hash_stack[start * co->hash_size], hash, co->hash_size);
+    gcry_md_close(ctx);
+
+    if (co->store_hash) {
+        // store start off_t
+        *((off_t *) &htt->xattr[htt->xattr_len]) = start * co->split_size;
+        htt->xattr_len += sizeof(off_t);
+
+        // store end off_t
+        off_t end_off = end * co->split_size;
+        if (end == crt->nsplits) end_off = size;
+        *((off_t *) &htt->xattr[htt->xattr_len]) = end_off;
+        htt->xattr_len += sizeof(off_t);
+
+        // store hash in xattr buffer
+        memcpy(&htt->xattr[htt->xattr_len],
+            &crt->hash_stack[start * co->hash_size], co->hash_size);
+        htt->xattr_len += co->hash_size;
+
+        if (htt->xattr_len + co->hash_size + 2 * sizeof(off_t) >
+                1/*TODO:ATTR_MAX_VALUELEN*/) {
+            // xattr is full so store contents and reset xattr buffer
+            char name[128];
+            sprintf(name, "user.hash.tree.%lld.%lld", start * co->split_size, end_off);
+            //TODO:fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
+            //TODO: check for errors
+
+            htt->xattr_len = 0;
+        }
+    }
+}
+
+void hash_leaf(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+        const char *buf, ssize_t buf_len)
+{
+    if (htt->hash_ctx_len + buf_len > 0 || htt->n_hash_total == 0) {
+        // something to hash or zero-length file
+
+        // compute hash of block [start, end)
+        if (buf_len > 0) gcry_md_write(*htt->hash_ctx, buf, buf_len);
+        unsigned char *hash = gcry_md_read(*htt->hash_ctx, 0);
+
+        // store hash on stack
+        memcpy(&htt->stack[htt->stack_len], hash, co->hash_size);
+        htt->stack_len += co->hash_size;
+
+        if (co->store_hash) {
+            // store start off_t
+            *((off_t *) &htt->xattr[htt->xattr_len]) =
+                crt->start_offset + htt->n_hash_total;
+            htt->xattr_len += sizeof(off_t);
+
+            // store end off_t
+            *((off_t *) &htt->xattr[htt->xattr_len]) =
+                crt->start_offset + htt->n_hash_total + htt->hash_ctx_len + buf_len;
+            htt->xattr_len += sizeof(off_t);
+
+            // store hash in xattr buffer
+            memcpy(&htt->xattr[htt->xattr_len], hash, co->hash_size);
+            htt->xattr_len += co->hash_size;
+
+            if (htt->xattr_len + co->hash_size + 2 * sizeof(off_t) >
+                    1/*TODO:ATTR_MAX_VALUELEN*/) {
+                // xattr is full so store contents and reset xattr buffer
+                char name[128];
+                sprintf(name, "user.hash.tree.%lld.%lld",
+                    crt->start_offset + htt->n_hash_total,
+                    crt->start_offset + htt->n_hash_total +
+                        htt->hash_ctx_len + buf_len);
+                //TODO:fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
+                //TODO: check for errors
+
+                htt->xattr_len = 0;
+            }
+        }
+    }
+
+    off_t total = htt->n_hash_total + htt->hash_ctx_len + buf_len;
+    off_t total_pow2 = total;
+
+    // for final partial leaf node, compute hash subtree as if it were full
+    if (htt->hash_ctx_len + buf_len < co->hash_leaf_size) {
+        off_t n = 1;
+        double leafs = total / (double) co->hash_leaf_size;
+        while (n < leafs) n <<= 1;
+        total_pow2 = n * co->hash_leaf_size;
+    }
+
+    // compute hash subtree from bottom up
+    ssize_t i = 1;
+    while (htt->stack_len >= 2 * co->hash_size && total_pow2 != 0 &&
+            total_pow2 / (i * co->hash_leaf_size) % 2 == 0) {
+        if (total_pow2 - i * co->hash_leaf_size < total) {
+            // compute hash of last two hashes on stack
+            gcry_md_reset(*htt->hash_ctx);
+            gcry_md_write(*htt->hash_ctx,&htt->stack[htt->stack_len - 2 * co->hash_size],
+                co->hash_size);
+            gcry_md_write(*htt->hash_ctx, &htt->stack[htt->stack_len - co->hash_size],
+                co->hash_size);
+            htt->stack_len -= 2 * co->hash_size;
+            unsigned char *hash = gcry_md_read(*htt->hash_ctx, 0);
+
+            // store hash on stack
+            memcpy(&htt->stack[htt->stack_len], hash, co->hash_size);
+            htt->stack_len += co->hash_size;
+
+            if (co->store_hash) {
+                // store start off_t
+                *((off_t *) &htt->xattr[htt->xattr_len]) =
+                    crt->start_offset + total_pow2 - 2 * i * co->hash_leaf_size;
+                htt->xattr_len += sizeof(off_t);
+
+                // store end off_t
+                *((off_t *) &htt->xattr[htt->xattr_len]) =
+                    crt->start_offset + total;
+                htt->xattr_len += sizeof(off_t);
+
+                // store hash in xattr buffer
+                memcpy(&htt->xattr[htt->xattr_len], hash, co->hash_size);
+                htt->xattr_len += co->hash_size;
+
+                if (htt->xattr_len + co->hash_size + 2 * sizeof(off_t) >
+                        1/*TODO:ATTR_MAX_VALUELEN*/) {
+                    // xattr is full so store contents and reset xattr buffer
+                    char name[128];
+                    sprintf(name, "user.hash.tree.%lld.%lld",
+                        crt->start_offset + total_pow2 - 2 * i * co->hash_leaf_size,
+                        crt->start_offset + total);
+                    //TODO:fsetxattr(htt->fd, name, htt->xattr, htt->xattr_len, 0);
+                    //TODO: check for errors
+
+                    htt->xattr_len = 0;
+                }
+            }
+        }
+        i *= 2;
+    }
+    gcry_md_reset(*htt->hash_ctx);
+}
+
+#endif
+
+
+////////////////////////////////
+//// OpenMP Semaphore Queue ////
+////////////////////////////////
+
+#ifdef _OPENMP
+
+void omp_sem_init(omp_sem_t *s, int size, int free) {
+    s->free = free;
+    s->size = size;
+    omp_init_lock(&s->mutex);
+    // an array of locks is used for waiting instead of a single lock
+    // as gcc does not seem to properly release multiple threads waiting
+    // on the same lock if multiple unlocks are executed before any
+    // waiting thread is actually released
+    s->waits = (omp_lock_t *) calloc(size, sizeof(omp_lock_t));
+    for (int i = 0; i < size; i++) {
+        omp_init_lock(&s->waits[i]);
+        omp_set_lock(&s->waits[i]);
+    }
+}
+
+void omp_sem_destroy(omp_sem_t *s) {
+    for (int i = 0; i < s->size; i++) {
+        omp_destroy_lock(&s->waits[i]);
+    }
+    free(s->waits);
+    omp_destroy_lock(&s->mutex);
+}
+
+void omp_sem_procure(omp_sem_t *s) {
+    omp_set_lock(&s->mutex);
+    s->free--;
+    if (s->free < 0) {
+        int lock = s->size + s->free;
+        omp_unset_lock(&s->mutex);
+        omp_set_lock(&s->waits[lock]);
+    } else {
+        omp_unset_lock(&s->mutex);
+    }
+}
+
+void omp_sem_vacate(omp_sem_t *s) {
+    omp_set_lock(&s->mutex);
+    if (s->free < 0) {
+        omp_unset_lock(&s->waits[s->size + s->free]);
+    }
+    s->free++;
+    omp_unset_lock(&s->mutex);
+}
+
+int omp_sem_free(omp_sem_t *s) {
+    return s->free;
+}
+
+void omp_q_init(omp_q_t *q, int size, size_t ptr_size) {
+    omp_sem_init(&q->max_sem, size, size);
+    omp_sem_init(&q->min_sem, size, 0);
+    omp_init_lock(&q->q_lock);
+    q->i_read = 0;
+    q->i_write = 0;
+    q->size = size;
+    q->ptr_size = ptr_size;
+    q->vals = (void **) calloc(size, ptr_size);
+}
+
+void omp_q_destroy(omp_q_t *q) {
+    free(q->vals);
+    omp_destroy_lock(&q->q_lock);
+    omp_sem_destroy(&q->min_sem);
+    omp_sem_destroy(&q->max_sem);
+}
+
+void omp_q_push(omp_q_t *q, void *val) {
+    omp_sem_procure(&q->max_sem);
+    omp_set_lock(&q->q_lock);
+    q->vals[q->i_write] = val;
+    q->i_write = (q->i_write + 1) % q->size;
+    omp_unset_lock(&q->q_lock);
+    omp_sem_vacate(&q->min_sem);
+}
+
+void *omp_q_pop(omp_q_t *q) {
+    omp_sem_procure(&q->min_sem);
+    omp_set_lock(&q->q_lock);
+    void *val = q->vals[q->i_read];
+    q->i_read = (q->i_read + 1) % q->size;
+    omp_unset_lock(&q->q_lock);
+    omp_sem_vacate(&q->max_sem);
+    return val;
+}
+
+int omp_q_size(omp_q_t *q) {
+    return (q->size + q->i_write - q->i_read) % q->size;
+}
+
+#endif
+
+
+////////////////////////////////
+//// Secure Remote Password ////
+////////////////////////////////
+
+#if HAVE_LIBGNUTLS
+
+/* Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Simon Josefsson
+ * Copyright (C) 2001,2003 Nikos Mavrogiannopoulos
+ * Copyright (C) 2004 Free Software Foundation
+ *
+ * Modified version of GNUTLS crypt.c distributed under GPLv3.
+ */
+ 
+# include <gcrypt.h>
+# include <pwd.h>
+# include <gnutls/gnutls.h>
+# include <gnutls/extra.h>
+
+static int generate_create_conf(char *tpasswd_conf) {
+    FILE *fd;
+    char line[5 * 1024];
+    int index = 1;
+    gnutls_datum_t g, n;
+    gnutls_datum_t str_g, str_n;
+
+    fd = fopen(tpasswd_conf, "w");
+    if (fd == NULL) return -1;
+
+    for (index = 1; index <= 3; index++) {
+        if (index == 1) {
+            n = gnutls_srp_1024_group_prime;
+            g = gnutls_srp_1024_group_generator;
+        } else if (index == 2) {
+            n = gnutls_srp_1536_group_prime;
+            g = gnutls_srp_1536_group_generator;
+        } else {
+            n = gnutls_srp_2048_group_prime;
+            g = gnutls_srp_2048_group_generator;
+        }
+
+        if (gnutls_srp_base64_encode_alloc(&n, &str_n) < 0) return -1;
+        if (gnutls_srp_base64_encode_alloc(&g, &str_g) < 0) return -1;
+
+        sprintf(line, "%d:%s:%s\n", index, str_n.data, str_g.data);
+
+        gnutls_free(str_n.data);
+        gnutls_free(str_g.data);
+
+        fwrite(line, 1, strlen(line), fd);
+    }
+
+    fclose(fd);
+
+    return 0;
+}
+
+/* this function parses tpasswd.conf file. Format is:
+ * int(index):base64(n):base64(g)
+ */
+static int read_conf_values(gnutls_datum_t * g, gnutls_datum_t * n, char *str) {
+    char *p;
+    int len;
+    int index, ret;
+    gnutls_datum_t dat;
+
+    index = atoi(str);
+
+    p = strrchr(str, ':');   /* we have g */
+    if (p == NULL) return -1;
+
+    *p = '\0';
+    p++;
+
+    /* read the generator */
+    len = strlen(p);
+    if (p[len - 1] == '\n') len--;
+
+    dat.data = p;
+    dat.size = len;
+    ret = gnutls_srp_base64_decode_alloc (&dat, g);
+
+    if (ret < 0) return -1;
+
+    /* now go for n - modulo */
+    p = strrchr(str, ':');   /* we have n */
+    if (p == NULL) return -1;
+
+    *p = '\0';
+    p++;
+
+    dat.data = p;
+    dat.size = strlen(p);
+
+    ret = gnutls_srp_base64_decode_alloc(&dat, n);
+
+    if (ret < 0) {
+        free(g->data);
+        return -1;
+    }
+
+    return index;
+}
+
+static char *_srp_crypt (const char *username, const char *passwd,
+        int salt_size, const gnutls_datum_t * g, const gnutls_datum_t * n) {
+    char salt[128];
+    static char result[1024];
+    gnutls_datum_t dat_salt, txt_salt;
+    gnutls_datum_t verifier, txt_verifier;
+
+    if ((unsigned) salt_size > sizeof(salt)) return NULL;
+
+    /* generate the salt */
+    gcry_create_nonce(salt, salt_size);
+
+    dat_salt.data = salt;
+    dat_salt.size = salt_size;
+
+    if (gnutls_srp_verifier(username, passwd, &dat_salt, g, n, &verifier) < 0)
+        return NULL;
+
+    /* base64 encode the verifier */
+    if (gnutls_srp_base64_encode_alloc(&verifier, &txt_verifier) < 0) {
+        free(verifier.data);
+        return NULL;
+    }
+
+    free (verifier.data);
+
+    if (gnutls_srp_base64_encode_alloc(&dat_salt, &txt_salt) < 0) return NULL;
+
+    sprintf(result, "%s:%s", txt_verifier.data, txt_salt.data);
+    free(txt_salt.data);
+    free(txt_verifier.data);
+
+    return result;
+}
+
+static int crypt_int (const char *username, const char *passwd, int salt_size,
+        char *tpasswd_conf, char *tpasswd, int uindex) {
+    FILE *fd;
+    char *cr;
+    gnutls_datum_t g, n;
+    char line[5 * 1024];
+    char *p, *pp;
+    int iindex;
+
+    fd = fopen(tpasswd_conf, "r");
+    if (fd == NULL) return -1;
+
+    /* find the specified uindex in file */
+    do {
+        p = fgets (line, sizeof (line) - 1, fd);
+        iindex = atoi(p);
+    } while (p != NULL && iindex != uindex);
+
+    if (p == NULL) return -1;
+    line[sizeof(line) - 1] = 0;
+
+    fclose (fd);
+    if ((iindex = read_conf_values(&g, &n, line)) < 0) return -1;
+
+    cr = _srp_crypt(username, passwd, salt_size, &g, &n);
+    if (cr == NULL) {
+        return -1;
+    } else {
+        /* delete previous entry */
+        struct stat st;
+        int put;
+
+        fd = fopen(tpasswd, "w");
+        if (fd == NULL) return -1;
+
+        fprintf(fd, "%s:%s:%u\n", username, cr, iindex);
+
+        fclose(fd);
+    }
+
+    return 0;
+}
+
+int srp_generate_auth(char *client_pw_file, char *pw_file, char *mg_file) {
+    mode_t umask_save = umask(077);
+    if (generate_create_conf(mg_file) < 0) return -1;
+    struct passwd *pw = getpwuid(getuid());
+    if (pw == NULL) return -1;
+    char *upass = gcry_random_bytes_secure(16, GCRY_STRONG_RANDOM);
+    if (upass == NULL) return -1;
+    // ensure printable ascii
+    for (int i = 0; i < 16; i++)
+      upass[i] = (upass[i] + 128) % 95 + 32;
+    if (crypt_int(pw->pw_name, upass, 16, mg_file, pw_file, 1) < 0)
+        return -1;
+    FILE *f = fopen(client_pw_file, "w");
+    if (f == NULL) return -1;
+    if (fwrite(upass, 16, 1, f) < 1) return -1;
+    fclose(f);
+    gcry_free(upass);
+    umask(umask_save);
+}
+ 
+#endif
+// < PZK
diff -rupN orig/src/mcore.h new/src/mcore.h
--- orig/src/mcore.h	1969-12-31 16:00:00.000000000 -0800
+++ new/src/mcore.h	2012-10-08 13:50:49.052715248 -0700
@@ -0,0 +1,128 @@
+// PZK >
+/* mcore.h -- core functions for copying/hashing files
+
+   Copyright 2010 United States Government National Aeronautics and
+   Space Administration (NASA).  No copyright is claimed in the United
+   States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License Version 3 with
+   Additional Terms below (per Section 7 of GPL V3).
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
+
+#ifndef MCORE_H
+# define MCORE_H
+
+# include <config.h>
+# include "copy.h"
+# include "mcore-omp.h"
+
+///////////////////
+//// Hash Tree ////
+///////////////////
+
+# if HAVE_LIBGCRYPT
+#  include <gcrypt.h>
+
+typedef struct {
+    off_t n_hash_total;
+    gcry_md_hd_t *hash_ctx;
+    size_t hash_ctx_len;
+    char *xattr;
+    size_t xattr_len;
+    char *stack;
+    size_t stack_len;
+    int fd;
+} hash_tree_t;
+
+void hash_final(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+        size_t start, size_t end, off_t size);
+void hash_leaf(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+    const char *buf, ssize_t buf_len);
+void hash_tree(hash_tree_t *htt, copy_reg_t *crt, struct cp_options *co,
+    const char *buf, off_t n_read_total, off_t size);
+
+# endif
+
+
+////////////////////////////////
+//// Secure Remote Password ////
+////////////////////////////////
+
+# if HAVE_LIBGNUTLS
+
+int srp_generate_auth(char *client_pw_file, char *pw_file, char *mg_file);
+
+# endif
+
+#endif
+// < PZK
+
diff -rupN orig/src/md5sum.c new/src/md5sum.c
--- orig/src/md5sum.c	2009-09-01 04:01:16.000000000 -0700
+++ new/src/md5sum.c	2012-10-08 16:05:38.772661658 -0700
@@ -1,10 +1,14 @@
 /* Compute MD5, SHA1, SHA224, SHA256, SHA384 or SHA512 checksum of files or strings
+
+   Copyright 2010 United States Government National Aeronautics and
+   Space Administration (NASA).  No copyright is claimed in the United
+   States under Title 17, U.S. Code.  All Other Rights Reserved.
+
    Copyright (C) 1995-2009 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
+   it under the terms of the GNU General Public License Version 3 with
+   Additional Terms below (per Section 7 of GPL V3).
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -14,7 +18,67 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>.  */
+/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>.
+   High performance multi-threaded modifications by Paul Kolano.  */
+
+/* Additional Terms per Section 7 of GNU General Public License Version 3
+
+1.  DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION
+
+    No Warranty: NASA PROVIDES THE COVERED WORKS "AS IS" WITHOUT ANY
+    WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
+    INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE COVERED WORKS
+    WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
+    INFRINGEMENT, ANY WARRANTY THAT THE COVERED WORKS WILL BE ERROR
+    FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM
+    TO THE COVERED WORKS. THIS AGREEMENT DOES NOT, IN ANY MANNER,
+    CONSTITUTE AN ENDORSEMENT BY NASA OR ANY OTHER RECIPIENT OF ANY
+    RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER
+    APPLICATIONS RESULTING FROM USE OF THE COVERED WORKS.  FURTHER, NASA
+    DISCLAIMS ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY
+    SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT
+    "AS IS."
+
+    Waiver and Indemnity: YOU AGREE TO WAIVE ANY AND ALL CLAIMS
+    AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
+    SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT.  IF YOUR USE OF THE
+    COVERED WORKS RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES, EXPENSES
+    OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM PRODUCTS
+    BASED ON, OR RESULTING FROM, YOUR USE OF THE COVERED WORKS, YOU
+    SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS
+    CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY OTHER RECIPIENT, TO
+    THE EXTENT PERMITTED BY LAW.  YOUR SOLE REMEDY FOR ANY SUCH MATTER
+    SHALL BE THE IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
+
+2.  You must ensure that the following copyright notice appears
+    prominently in the covered works:
+
+        Copyright 2010 United States Government National Aeronautics and
+        Space Administration (NASA).  No copyright is claimed in the United
+        States under Title 17, U.S. Code.  All Other Rights Reserved.
+
+3.  You must characterize Your alteration of the covered works as a
+    Modification or Contribution and must identify Yourself as the
+    originator of Your Modification or Contribution in a manner that
+    reasonably allows subsequent Recipients to identify the originator
+    of the Modification or Contribution.  In fulfillment of these
+    requirements, You must include a file (e.g., a change log file) that
+    describes the alterations made and the date of the alterations,
+    identifies You as originator of the alterations, and consents to
+    characterization of the alterations as a Modification or
+    Contribution, for example, by including a statement that the
+    Modification or Contribution is derived, directly or indirectly,
+    from covered work provided by NASA. Once consent is granted, it may
+    not thereafter be revoked.
+
+4.  You may not make any representation in the covered works or in any
+    promotional, advertising or other material that may be construed as
+    an endorsement by NASA or by any other Recipient of any product or
+    service provided by You, or that may seek to obtain commercial
+    advantage of NASA's or any other Recipient's participation in this
+    License.
+*/
 
 #include <config.h>
 
@@ -39,9 +103,42 @@
 #include "stdio--.h"
 #include "xfreopen.h"
 
+// PZK >
+#include "buffer-lcm.h"
+#include "mcore.h"
+#include "mkancesdirs.h"
+#include "quote.h"
+#include "savewd.h"
+#include <aio.h>
+#include <ctype.h>
+
+#if HAVE_LIBGCRYPT
+# include <gcrypt.h>
+# ifdef _OPENMP
+#  include <pthread.h>
+GCRY_THREAD_OPTION_PTHREAD_IMPL;
+# endif
+#endif
+
+#if HAVE_LIBMPI && defined(_OPENMP)
+# include "mpi.h"
+#endif
+
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+# include <arpa/inet.h>
+# include <gnutls/gnutls.h>
+# include <gnutls/extra.h>
+# include <netdb.h>
+# include <poll.h>
+# include <pthread.h>
+# include <pwd.h>
+# include <sys/socket.h>
+#endif
+// < PZK
+
 /* The official name of this program (e.g., no `g' prefix).  */
 #if HASH_ALGO_MD5
-# define PROGRAM_NAME "md5sum"
+# define PROGRAM_NAME "msum 1.76.6"
 # define DIGEST_TYPE_STRING "MD5"
 # define DIGEST_STREAM md5_stream
 # define DIGEST_BITS 128
@@ -89,10 +186,35 @@
 #define DIGEST_HEX_BYTES (DIGEST_BITS / 4)
 #define DIGEST_BIN_BYTES (DIGEST_BITS / 8)
 
+// PZK >
 #define AUTHORS \
   proper_name ("Ulrich Drepper"), \
   proper_name ("Scott Miller"), \
-  proper_name ("David Madore")
+  proper_name ("David Madore"), \
+  proper_name ("Paul Kolano")
+
+#ifndef DEFAULT_BUFFER_SIZE
+# define DEFAULT_BUFFER_SIZE 4
+#endif
+#ifndef DEFAULT_DIRECT_READ
+# define DEFAULT_DIRECT_READ 0
+#endif
+#ifndef DEFAULT_DOUBLE_BUFFER
+# define DEFAULT_DOUBLE_BUFFER 0
+#endif
+#ifndef DEFAULT_FADVISE_READ
+# define DEFAULT_FADVISE_READ 0
+#endif
+#if !defined(DEFAULT_HASH_TYPE) && HAVE_LIBGCRYPT
+# define DEFAULT_HASH_TYPE GCRY_MD_MD5
+#endif
+#ifndef DEFAULT_SPLIT_SIZE
+# define DEFAULT_SPLIT_SIZE 0
+#endif
+#ifndef DEFAULT_THREADS
+# define DEFAULT_THREADS 4
+#endif
+// < PZK
 
 /* The minimum length of a valid digest line.  This length does
    not include any newline character at the end of a line.  */
@@ -126,11 +248,79 @@ static bool quiet = false;
 enum
 {
   STATUS_OPTION = CHAR_MAX + 1,
+// PZK >
+  BUFFER_SIZE_OPTION,
+  DIRECT_READ_OPTION,
+  DOUBLE_BUFFER_OPTION,
+  LENGTH_OPTION,
+  NO_DIRECT_READ_OPTION,
+  NO_DOUBLE_BUFFER_OPTION,
+  OFFSET_OPTION,
+  READ_STDIN_OPTION,
+#ifdef POSIX_FADV_DONTNEED
+  FADVISE_READ_OPTION,
+  NO_FADVISE_READ_OPTION,
+#endif
+#ifdef _OPENMP
+  PRINT_STATS_OPTION,
+  SPLIT_SIZE_OPTION,
+  THREADS_OPTION,
+#endif
+#if HAVE_LIBGCRYPT
+  CHECK_TREE_OPTION,
+  HASH_LEAF_SIZE_OPTION,
+  HASH_TYPE_OPTION,
+  STORE_HASH_OPTION,
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+  MPI_OPTION,
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  LISTEN_PORT_OPTION,
+  MANAGER_HOST_OPTION,
+  MANAGER_PORT_OPTION,
+  PASSWORD_FILE_OPTION,
+#endif
+// < PZK
   QUIET_OPTION
 };
 
 static struct option const long_options[] =
 {
+// PZK >
+  {"buffer-size", required_argument, NULL, BUFFER_SIZE_OPTION},
+  {"direct-read", no_argument, NULL, DIRECT_READ_OPTION},
+  {"double-buffer", no_argument, NULL, DOUBLE_BUFFER_OPTION},
+  {"length", required_argument, NULL, LENGTH_OPTION},
+  {"no-direct-read", no_argument, NULL, NO_DIRECT_READ_OPTION},
+  {"no-double-buffer", no_argument, NULL, NO_DOUBLE_BUFFER_OPTION},
+  {"offset", required_argument, NULL, OFFSET_OPTION},
+  {"read-stdin", no_argument, NULL, READ_STDIN_OPTION},
+#ifdef POSIX_FADV_DONTNEED
+  {"fadvise-read", no_argument, NULL, FADVISE_READ_OPTION},
+  {"no-fadvise-read", no_argument, NULL, NO_FADVISE_READ_OPTION},
+#endif
+#ifdef _OPENMP
+  {"print-stats", no_argument, NULL, PRINT_STATS_OPTION},
+  {"split-size", required_argument, NULL, SPLIT_SIZE_OPTION},
+  {"threads", required_argument, NULL, THREADS_OPTION},
+#endif
+#if HAVE_LIBGCRYPT
+  {"check-tree", no_argument, NULL, CHECK_TREE_OPTION},
+  {"hash-leaf-size", required_argument, NULL, HASH_LEAF_SIZE_OPTION},
+  {"hash-type", required_argument, NULL, HASH_TYPE_OPTION},
+  {"store-hash", no_argument, NULL, STORE_HASH_OPTION},
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+  {"mpi", no_argument, NULL, MPI_OPTION},
+#endif
+#if HAVE_LIBGNUTLS
+  {"listen-port", required_argument, NULL, LISTEN_PORT_OPTION},
+  {"manager-host", required_argument, NULL, MANAGER_HOST_OPTION},
+  {"manager-port", required_argument, NULL, MANAGER_PORT_OPTION},
+  {"password-file", required_argument, NULL, PASSWORD_FILE_OPTION},
+#endif
+// < PZK
   { "binary", no_argument, NULL, 'b' },
   { "check", no_argument, NULL, 'c' },
   { "quiet", no_argument, NULL, QUIET_OPTION },
@@ -142,6 +332,404 @@ static struct option const long_options[
   { NULL, 0, NULL, 0 }
 };
 
+// PZK >
+#define sum_options cp_options
+#define sum_task_t copy_reg_t
+#define hash_time write_time
+#define sum_time copy_time
+#define hash_check dst_name
+
+static void
+sum_option_init (struct sum_options *x)
+{
+  x->buffer_size = DEFAULT_BUFFER_SIZE * 1024 * 1024;
+  x->check_tree = false;
+#if DEFAULT_DOUBLE_BUFFER
+  x->double_buffer = true;
+#else
+  x->double_buffer = false;
+#endif
+#if DEFAULT_FADVISE_READ
+  x->fadvise_read = true;
+#else
+  x->fadvise_read = false;
+#endif
+  x->hash_size = 0;
+  x->hash_stat_tasks = xcalloc(1, sizeof(long long));
+#if HAVE_LIBGCRYPT
+  x->hash_type = DEFAULT_HASH_TYPE;
+#endif
+  x->length = 0;
+  x->listen_port = 0;
+  x->mg_file = NULL;
+  x->mgr_ai = NULL;
+  x->mgr_port = 0;
+  x->mpi = false;
+  x->offset = 0;
+  x->pass = NULL;
+  x->print_stats = false;
+  x->pw_file = 0;
+#if DEFAULT_DIRECT_READ
+  x->read_mode = O_DIRECT;
+#else
+  x->read_mode = 0;
+#endif
+  x->read_stdin = false;
+  x->split_size = DEFAULT_SPLIT_SIZE * 1024 * 1024;
+  x->hash_leaf_size = x->split_size; // this must follow split_size
+  x->store_hash = false;
+  x->task_q = NULL;
+  x->threads = DEFAULT_THREADS;
+  x->user = NULL;
+}
+
+extern bool
+sum_task(sum_task_t *stt, struct sum_options *so)
+{
+  char *buf[2];
+  char *buf_alloc[2];
+  buf_alloc[0] = NULL;
+  buf_alloc[1] = NULL;
+  struct stat src_open_sb;
+  bool return_val = true;
+
+#if HAVE_LIBGCRYPT
+  hash_tree_t htt;
+#endif
+
+  int source_desc =
+    open(stt->src_name, O_RDONLY | O_BINARY | so->read_mode);
+  if (source_desc < 0)
+    error(0, errno, _("warning: unable to open %s for read"), quote(stt->src_name));
+  if (lseek(source_desc, stt->start_offset, SEEK_SET) < 0)
+    error(0, errno, _("warning: unable to seek in %s"), quote(stt->src_name));
+  //TODO: additional error handling if can't open or seek?
+
+  if (fstat (source_desc, &src_open_sb) != 0)
+    {
+      error (0, errno, _("cannot fstat %s"), quote (stt->src_name));
+      return_val = false;
+      goto task_close_src_and_dst_desc;
+    }
+
+  typedef uintptr_t word;
+  off_t n_read_total = 0;
+
+  /* Choose a suitable buffer size; it may be adjusted later.  */
+  size_t buf_alignment = lcm (getpagesize (), sizeof (word));
+  size_t buf_alignment_slop = sizeof (word) + buf_alignment - 1;
+  size_t buf_size = stt->dst_blksize;
+
+  /* Compute the least common multiple of the input and output
+     buffer sizes, adjusting for outlandish values.  */
+  size_t blcm_max = MIN (SIZE_MAX, SSIZE_MAX) - buf_alignment_slop;
+  size_t blcm = buffer_lcm (io_blksize (src_open_sb), buf_size,
+                                blcm_max);
+  blcm = so->buffer_size;
+  if (so->read_mode)
+    blcm = buffer_lcm (blcm, 512, blcm_max);
+
+  /* Do not bother with a buffer larger than the input file, plus one
+     byte to make sure the file has not grown while reading it.  */
+  if (S_ISREG (src_open_sb.st_mode) && src_open_sb.st_size < buf_size)
+    buf_size = src_open_sb.st_size + 1;
+
+  /* However, stick with a block size that is a positive multiple of
+     blcm, overriding the above adjustments.  Watch out for
+     overflow.  */
+  buf_size += blcm - 1;
+  buf_size -= buf_size % blcm;
+  if (buf_size == 0 || blcm_max < buf_size)
+    buf_size = blcm;
+
+  /* Make a buffer with space for a sentinel at the end.  */
+  buf_alloc[0] = xmalloc (buf_size + buf_alignment_slop);
+  buf[0] = ptr_align (buf_alloc[0], buf_alignment);
+  if (so->double_buffer) {
+    buf_alloc[1] = xmalloc (buf_size + buf_alignment_slop);
+    buf[1] = ptr_align (buf_alloc[1], buf_alignment);
+  }
+
+#if HAVE_LIBGCRYPT
+  gcry_md_hd_t ctx;
+  gcry_md_open(&ctx, so->hash_type, 0);
+  if (stt->nsplits > 1) {
+    htt.n_hash_total = 0;
+    htt.hash_ctx = &ctx;
+    htt.hash_ctx_len = 0;
+//TODO:    if (so->store_hash) htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
+    htt.xattr_len = 0;
+    //TODO: this is wrong since there is no writable dst
+    //htt.fd = stt->dest_desc;
+    htt.fd = -1;
+    htt.stack_len = 0;
+
+    // compute approximate height of split sub-tree
+    off_t leafs = (stt->stop_offset - stt->start_offset) /
+        so->hash_leaf_size + 1;
+    ssize_t n = 1;
+    while (leafs >>= 1) n++;
+    // stack needs space for at most height of tree hashes
+    htt.stack = xmalloc(n * so->hash_size);
+  }
+#endif
+
+  struct timespec rts[2], hts[2];
+  struct aiocb aio;
+  struct aiocb *aiol[1];
+  aiol[0] = NULL;
+  int aio_buf = 0;
+
+  for (;;)
+    {
+      if (n_read_total >= stt->stop_offset - stt->start_offset) break;
+
+      ssize_t n_read;
+      if (aiol[0] != NULL) {
+        // this will be skipped during the first double buffer iteration
+        aio_suspend((const struct aiocb * const *) aiol, 1, NULL);
+        n_read = aio_return(aiol[0]);
+      } else {
+        off_t to_read = MIN(buf_size,
+            stt->stop_offset - stt->start_offset - n_read_total);
+        // align offset for direct i/o and better performance when buffered
+        off_t align_read = (stt->start_offset + n_read_total) % 4096;
+        if (align_read != 0 && to_read > 4096) to_read = 4096 - align_read;
+        if (so->read_mode && to_read < buf_size) {
+            // turn off direct i/o if going to read unaligned block
+            int old_flags = fcntl(source_desc, F_GETFL);
+            if (fcntl(source_desc, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                    quote (stt->src_name));
+        }
+
+        if (so->print_stats) clock_gettime(CLOCK_REALTIME, &rts[0]);
+        n_read = read (source_desc, buf[aio_buf], to_read);
+
+        if (so->read_mode && align_read != 0) {
+            // turn direct i/o back on in case it was turned off
+            int old_flags = fcntl(source_desc, F_GETFL);
+            if (old_flags & O_DIRECT == 0 &&
+                fcntl(source_desc, F_SETFL, old_flags | O_DIRECT) != 0)
+                    error(0, errno, _("failed to turn on O_DIRECT: %s"),
+                        quote(stt->src_name));
+        }
+      }
+
+      if (so->print_stats) {
+        clock_gettime(CLOCK_REALTIME, &rts[1]);
+        stt->read_time += (double) (
+            (double) rts[1].tv_sec + (double) rts[1].tv_nsec / (double) 1.0e9 -
+            (double) rts[0].tv_sec - (double) rts[0].tv_nsec / (double) 1.0e9);
+      }
+
+      if (n_read < 0)
+        {
+#ifdef EINTR
+          if (errno == EINTR)
+            continue;
+#endif
+          error (0, errno, _("reading %s"), quote (stt->src_name));
+          return_val = false;
+          goto task_close_src_and_dst_desc;
+        }
+      if (n_read == 0)
+        break;
+
+#ifdef POSIX_FADV_DONTNEED
+      if (so->fadvise_read) {
+        // indicate done with read data
+        posix_fadvise(source_desc, stt->start_offset + n_read_total,
+            n_read, POSIX_FADV_DONTNEED);
+      }
+#endif
+
+      n_read_total += n_read;
+
+      off_t to_read = MIN(buf_size,
+        stt->stop_offset - stt->start_offset - n_read_total);
+      if (so->double_buffer && to_read > 0) {
+        if (so->read_mode && to_read < buf_size) {
+            // turn off direct i/o if going to read unaligned block
+            int old_flags = fcntl(source_desc, F_GETFL);
+            if (fcntl(source_desc, F_SETFL, old_flags & ~O_DIRECT) != 0)
+                error(0, errno, _("failed to turn off O_DIRECT: %s"),
+                    quote (stt->src_name));
+        }
+
+        if (so->print_stats) clock_gettime(CLOCK_REALTIME, &rts[0]);
+        memset(&aio, 0, sizeof(struct aiocb));
+        aio.aio_fildes = source_desc;
+        aio.aio_offset = stt->start_offset + n_read_total;
+        aio.aio_buf = buf[!aio_buf];
+        aio.aio_nbytes = to_read;
+        aiol[0] = &aio;
+        //TODO: error handling for bad aio_read
+        aio_read(&aio);
+      }
+
+      if (so->print_stats) clock_gettime(CLOCK_REALTIME, &hts[0]);
+#if HAVE_LIBGCRYPT
+       //TODO: is st_size right for partial files?
+      if (stt->nsplits > 1)
+        hash_tree(&htt, stt, so, buf[aio_buf], n_read_total, src_open_sb.st_size);
+      else
+        gcry_md_write(ctx, buf[aio_buf], n_read);
+#endif
+      if (so->print_stats) {
+        clock_gettime(CLOCK_REALTIME, &hts[1]);
+        stt->hash_time += (double) (
+            (double) hts[1].tv_sec + (double) hts[1].tv_nsec / (double) 1.0e9 -
+            (double) hts[0].tv_sec - (double) hts[0].tv_nsec / (double) 1.0e9);
+      }
+      if (so->double_buffer) aio_buf = !aio_buf;
+    }
+
+task_close_src_and_dst_desc:
+  if (close (source_desc) < 0)
+    {
+      error (0, errno, _("closing %s"), quote (stt->src_name));
+      return_val = false;
+    }
+
+  free (buf_alloc[0]);
+  free (buf_alloc[1]);
+  if (!return_val) {
+    error (0, 0, _("%s: FAILED open or read"), quote (stt->src_name));
+#if HAVE_LIBGCRYPT
+  } else {
+    // copy final hash onto stt hash stack
+    if (stt->nsplits > 1) {
+        memcpy(stt->hash_stack, htt.stack, so->hash_size);
+    } else {
+        memcpy(stt->hash_stack, gcry_md_read(ctx, 0), so->hash_size);
+    }
+#endif
+  }
+
+#if HAVE_LIBGCRYPT
+  gcry_md_close(ctx);
+  if (stt->nsplits > 1) {
+    if (so->store_hash) free(htt.xattr);
+    free(htt.stack);
+  }
+#endif
+
+  return return_val;
+}
+
+void print_check(struct sum_options *x, sum_task_t *stt)
+{
+//TODO: need to make this for general hash length
+    static const char bin2hex[] = { '0', '1', '2', '3',
+                                    '4', '5', '6', '7',
+                                    '8', '9', 'a', 'b',
+                                    'c', 'd', 'e', 'f' };
+    size_t digest_bin_bytes = digest_hex_bytes / 2;
+    size_t cnt, s;
+    unsigned char *stack = stt->hash_stack;
+    unsigned char *check = stt->hash_check;
+    int fail = 0;
+    if (!status_only) printf("%s: ", stt->src_name);
+
+    /* Compare generated binary number with text representation
+       in check file.  Ignore case of hex digits.  */
+    int nsplits = x->check_tree ? stt->nsplits : 1;
+    for (s = 0; s < nsplits; s++) {
+        for (cnt = 0; cnt < digest_bin_bytes; ++cnt) {
+            if (tolower (check[2 * cnt])
+                != bin2hex[stack[cnt] >> 4]
+                || (tolower (check[2 * cnt + 1])
+                    != (bin2hex[stack[cnt] & 0xf])))
+            break;
+        }
+        if (!status_only) {
+            if (cnt != digest_bin_bytes) {
+                if (!fail) {
+                    printf("%s", _("FAILED"));
+                    fail = 1;
+                }
+                if (stt->partial || x->check_tree) {
+                    off_t end = stt->start_offset + (s + 1) * x->split_size;
+                    if (end > stt->stop_offset) end = stt->stop_offset;
+                    printf(",%lld-%lld",
+                        stt->start_offset + s * x->split_size, end);
+                }
+            }
+        }
+        stack += digest_bin_bytes;
+        check += digest_hex_bytes;
+    }
+/*TODO: do something with this in hash thread
+    if (cnt != digest_bin_bytes)
+      ++n_mismatched_checksums;
+*/
+    if (!status_only) {
+        if (!quiet && !fail) {
+            printf("%s", _("OK"));
+            if (stt->partial)
+                printf(",%lld-%lld", stt->start_offset, stt->stop_offset);
+        }
+        if (fail || !quiet) printf("\n");
+        fflush (stdout);
+    }
+}
+
+
+//TODO: general hash length
+void print_hash(struct sum_options *x, sum_task_t *stt)
+{
+    size_t i;
+
+    // put non-standard output in comments
+    if (stt->nsplits > 1 || stt->partial) {
+        printf("#mutil#");
+        if (stt->partial)
+            printf("%lld-%lld", stt->start_offset, stt->stop_offset);
+        printf("#");
+    }
+
+    /* Output a leading backslash if the file name contains
+       a newline or backslash.  */
+    if (strchr (stt->src_name, '\n') || strchr (stt->src_name, '\\'))
+      putchar ('\\');
+
+    size_t bytes = digest_hex_bytes / 2;
+    if (x->check_tree) bytes *= stt->nsplits;
+    for (i = 0; i < bytes; ++i)
+      printf ("%02x", stt->hash_stack[i]);
+
+    putchar (' ');
+/*TODO: do something with this binary stuff
+    if (file_is_binary)
+      putchar ('*');
+    else
+*/
+      putchar (' ');
+
+    /* Translate each NEWLINE byte to the string, "\\n",
+       and each backslash to "\\\\".  */
+    for (i = 0; i < strlen (stt->src_name); ++i)
+      {
+        switch (stt->src_name[i])
+          {
+          case '\n':
+            fputs ("\\n", stdout);
+            break;
+
+          case '\\':
+            fputs ("\\\\", stdout);
+            break;
+
+          default:
+            putchar (stt->src_name[i]);
+            break;
+          }
+      }
+    putchar ('\n');
+}
+// < PZK
+
 void
 usage (int status)
 {
@@ -150,15 +738,120 @@ usage (int status)
              program_name);
   else
     {
+// PZK >
       printf (_("\
 Usage: %s [OPTION]... [FILE]...\n\
-Print or check %s (%d-bit) checksums.\n\
+Print or check checksums.\n\
 With no FILE, or when FILE is -, read standard input.\n\
 \n\
 "),
-              program_name,
-              DIGEST_TYPE_STRING,
-              DIGEST_BITS);
+              program_name);
+      fputs (_("Msum-specific options (defaults in brackets):\n"), stdout);
+      fprintf (stdout, _("\
+      --buffer-size=MBYTES     read/write buffer size [%d]\n"),
+        DEFAULT_BUFFER_SIZE);
+#if HAVE_LIBGCRYPT
+      fputs (_("\
+      --check-tree             print/check hash subtrees to pinpoint corruption\n\
+"), stdout);
+#endif
+#if !DEFAULT_DIRECT_READ
+      fputs (_("\
+      --direct-read            enable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if !DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
+      --double-buffer          enable use of double buffering during file I/O\n\
+"), stdout);
+#endif
+#ifdef POSIX_FADV_DONTNEED
+# if !DEFAULT_FADVISE_READ
+      fputs (_("\
+      --fadvise-read           enable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+#endif
+#if HAVE_LIBGCRYPT
+      fprintf (stdout, _("\
+      --hash-leaf-size=KBYTES  granularity of hash tree [%d]\n\
+      --hash-type=TYPE         hash type [%s], with TYPE one of:\n\
+                                 "),
+        DEFAULT_SPLIT_SIZE * 1024, gcry_md_algo_name(DEFAULT_HASH_TYPE));
+      int n = 33;
+      // 400 taken from libgcrypt benchmark code
+      for (int i = 1; i < 400; i++) {
+        if (gcry_md_test_algo(i)) continue;
+        char *name = gcry_md_algo_name(i);
+        if (n + strlen(name) > 78) {
+            fputs (_("\n                                 "), stdout);
+            n = 33;
+        }
+        n += strlen(name);
+        while (*name) fputc(tolower(*name++), stdout);
+        fputc(' ', stdout);
+      }
+      fputs(_("\n"), stdout);
+#endif
+      fputs (_("\
+      --length=LEN             hash LEN bytes beginning at --offset\n\
+                                 (or 0 if --offset not specified)\n\
+"), stdout);
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+      fputs (_("\
+      --listen-port=PORT       listen on port PORT for requests from\n\
+                                 cooperating hosts\n\
+      --manager-host=HOST      host name or IP address of management thread\n\
+                                 for multi-node/multi-host copies\n\
+      --manager-port=PORT      port on which to contact management thread\n\
+"), stdout);
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+      fputs (_("\
+      --mpi                    enable use of MPI for multi-node checksums\n\
+"), stdout);
+#endif
+#if DEFAULT_DIRECT_READ
+      fputs (_("\
+      --no-direct-read         disable use of direct I/O for reads\n\
+"), stdout);
+#endif
+#if DEFAULT_DOUBLE_BUFFER
+      fputs (_("\
+      --no-double-buffer       disable use of double buffering during file I/O\n\
+"), stdout);
+#endif
+#ifdef POSIX_FADV_DONTNEED
+# if DEFAULT_FADVISE_READ
+      fputs (_("\
+      --no-fadvise-read        disable use of posix_fadvise during reads\n\
+"), stdout);
+# endif
+#endif
+      fputs (_("\
+      --offset=POS             hash --length bytes beginning at POS\n\
+                                 (or to end if --length not specified)\n\
+"), stdout);
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+      fputs (_("\
+      --password-file=FILE     file to use for passwords (will be created\n\
+                                 if does not exist)\n\
+"), stdout);
+#endif
+#ifdef _OPENMP
+      fprintf (stdout, _("\
+      --read-stdin             perform a batch of operations read over stdin\n\
+                                 in the form 'FILE RANGES' where FILE must be\n\
+                                 a URI-escaped (RFC 3986) file name and RANGES\n\
+                                 is zero or more comma-separated ranges of the\n\
+                                 form 'START-END' for 0 <= START < END\n\
+      --split-size=MBYTES      size to split files for parallelization [%d]\n\
+      --threads=NUMBER         number of OpenMP worker threads to use [%d]\n\
+\n\
+"), DEFAULT_SPLIT_SIZE, DEFAULT_THREADS);
+#endif
+      fputs (_("Standard options:\n"), stdout);
+// < PZK
       if (O_BINARY)
         fputs (_("\
   -b, --binary            read in binary mode (default unless reading tty stdin)\n\
@@ -167,9 +860,10 @@ With no FILE, or when FILE is -, read st
         fputs (_("\
   -b, --binary            read in binary mode\n\
 "), stdout);
+// PZK >
       printf (_("\
-  -c, --check             read %s sums from the FILEs and check them\n"),
-              DIGEST_TYPE_STRING);
+  -c, --check             read sums from the FILEs and check them\n"));
+// < PZK
       if (O_BINARY)
         fputs (_("\
   -t, --text              read in text mode (default if reading tty stdin)\n\
@@ -188,13 +882,13 @@ The following three options are useful o
 "), stdout);
       fputs (HELP_OPTION_DESCRIPTION, stdout);
       fputs (VERSION_OPTION_DESCRIPTION, stdout);
+// PZK >
       printf (_("\
 \n\
-The sums are computed as described in %s.  When checking, the input\n\
-should be a former output of this program.  The default mode is to print\n\
-a line with checksum, a character indicating type (`*' for binary, ` ' for\n\
-text), and name for each FILE.\n"),
-              DIGEST_REFERENCE);
+When checking, the input should be a former output of this program.\n\
+The default mode is to print a line with checksum, a character indicating\n\
+type (`*' for binary, ` ' for text), and name for each FILE.\n"));
+// < PZK
       emit_bug_reporting_address ();
     }
 
@@ -247,6 +941,9 @@ bsd_split_3 (char *s, size_t s_len, unsi
    a hexadecimal digest, binary flag, and the file name.
    S is modified.  Return true if successful.  */
 
+// PZK >
+//TODO: need to modify this to take different hash sizes into account
+// < PZK
 static bool
 split_3 (char *s, size_t s_len,
          unsigned char **hex_digest, int *binary, char **file_name)
@@ -290,6 +987,11 @@ split_3 (char *s, size_t s_len,
      representation of the message digest.  If it is not followed
      immediately by a white space it's an error.  */
   i += digest_hex_bytes;
+// PZK >
+  //TODO: put this in for checktree
+  while (!ISWHITE (s[i]))
+    i++;
+// < PZK
   if (!ISWHITE (s[i]))
     return false;
 
@@ -355,6 +1057,10 @@ split_3 (char *s, size_t s_len,
 static bool
 hex_digits (unsigned char const *s)
 {
+// PZK >
+    //TODO: temporarily set this true until check-tree finalized
+    return true;
+// < PZK
   unsigned int i;
   for (i = 0; i < digest_hex_bytes; i++)
     {
@@ -377,12 +1083,96 @@ hex_digits (unsigned char const *s)
    Return true if successful.  */
 
 static bool
-digest_file (const char *filename, int *binary, unsigned char *bin_result)
+// PZK >
+digest_file (struct sum_options *x, unsigned char *h_check,
+    const char *filename, int *binary, unsigned char *bin_result)
+// < PZK
 {
   FILE *fp;
   int err;
   bool is_stdin = STREQ (filename, "-");
 
+// PZK >
+#if HAVE_LIBGCRYPT && defined(_OPENMP)
+  if (is_stdin) goto do_stdin;
+
+  struct stat src_sb;
+  if (stat (filename, &src_sb) != 0) {
+      error (0, errno, _("cannot stat %s"), quote (filename));
+      return false;
+  }
+
+  if (!S_ISREG(src_sb.st_mode)) {
+      error (0, 0, _("%s: Is not a regular file"), quote (filename));
+      return false;
+  }
+
+//TODO:  do something with binary?  why should that matter?
+  off_t pos = 0;
+  if (x->offset && x->offset > src_sb.st_size) pos = src_sb.st_size;
+  else if (x->offset) pos = x->offset;
+  off_t end = src_sb.st_size;
+  if (x->length && pos + x->length < end) end = pos + x->length;
+  size_t nsplits = 1, split = 0;
+  if (x->split_size > 0 && end - pos > 0)
+      nsplits = (end - pos) / x->split_size +
+          ((end - pos) % x->split_size ? 1 : 0);
+  while (pos == 0 || pos < end) {
+      sum_task_t *stt = xmalloc(sizeof(sum_task_t));
+      stt->src_name = xstrdup(filename);
+      stt->dst_blksize = io_blksize(src_sb);
+      stt->read_time = 0;
+      stt->hash_time = 0;
+      stt->sum_time = 0;
+      stt->nsplits = nsplits;
+      stt->split = split++;
+      stt->start_offset = pos;
+      stt->partial = x->offset || end < src_sb.st_size ? true : false;
+      stt->hash_stack = xmalloc(x->hash_size);
+      stt->hash_check = NULL;
+      *x->hash_stat_tasks += 1;
+      pos += x->split_size;
+      if (nsplits > 1) {
+          // stop after split size bytes
+          stt->stop_offset = MIN(pos, end);
+          if (stt->start_offset == x->offset) {
+              sum_task_t *sttcp = xmalloc(sizeof(sum_task_t));
+              sttcp->nsplits = nsplits;
+              sttcp->split = nsplits;
+              sttcp->start_offset = x->offset;
+              sttcp->stop_offset = end;
+              sttcp->partial = stt->partial;
+              sttcp->src_name = xstrdup(filename);
+              sttcp->hash_stack = xmalloc(nsplits * x->hash_size);
+              sttcp->hash_check = h_check;
+              if (x->store_hash) {
+                  //TODO: check that won't overflow file
+                  //      descriptors by keeping one open
+                  // need to keep open descriptor for xattr operations
+                /*TODO: this is different in msum since nothing is opened writable
+                  sttcp->dest_desc =
+                      open(dst_name, O_WRONLY | O_BINARY | x->write_mode);
+                  if (sttcp->dest_desc < 0)
+                      error(0, errno, _("warning: unable to open %s for storing hash"), quote(dst_name));
+                */
+                  //TODO: additional error handling?
+              }
+              // send stt copy to hash handler
+              omp_q_push(x->send_q, sttcp);
+          }
+      } else {
+          // stop at end of file
+          stt->stop_offset = end;
+          stt->hash_check = h_check;
+      }
+      omp_q_push(x->task_q, stt);
+      if (nsplits == 1) break;
+  }
+  return true;
+do_stdin:
+#endif
+// < PZK
+
   if (is_stdin)
     {
       have_read_stdin = true;
@@ -424,7 +1214,9 @@ digest_file (const char *filename, int *
 }
 
 static bool
-digest_check (const char *checkfile_name)
+// PZK >
+digest_check (struct sum_options *x, const char *checkfile_name)
+// < PZK
 {
   FILE *checkfile_stream;
   uintmax_t n_properly_formatted_lines = 0;
@@ -473,15 +1265,30 @@ digest_check (const char *checkfile_name
       if (line_length <= 0)
         break;
 
-      /* Ignore comment lines, which begin with a '#' character.  */
-      if (line[0] == '#')
-        continue;
-
       /* Remove any trailing newline.  */
       if (line[line_length - 1] == '\n')
         line[--line_length] = '\0';
 
-      if (! (split_3 (line, line_length, &hex_digest, &binary, &filename)
+// PZK >
+      off_t stop;
+      if (sscanf(line, "#mutil#%lld-%lld", &x->offset, &stop) != 2) {
+        x->offset = 0;
+        x->length = 0;
+      } else {
+        x->length = stop - x->offset;
+      }
+      size_t iline = 0;
+      if (!strncmp(line, "#mutil#", 7)) {
+        iline = strcspn(&line[7], "#") + 8;
+        if (iline > line_length) continue;
+        line_length -= iline;
+      } else
+      /* Ignore comment lines, which begin with a '#' character.  */
+      if (line[0] == '#')
+        continue;
+
+      if (! (split_3(&line[iline], line_length, &hex_digest, &binary, &filename)
+// < PZK
              && ! (is_stdin && STREQ (filename, "-"))
              && hex_digits (hex_digest)))
         {
@@ -504,7 +1311,11 @@ digest_check (const char *checkfile_name
 
           ++n_properly_formatted_lines;
 
-          ok = digest_file (filename, &binary, bin_buffer);
+// PZK >
+          unsigned char *h_check = xstrdup(hex_digest);
+          ok = digest_file (x, h_check, filename, &binary, bin_buffer);
+          continue;
+// < PZK
 
           if (!ok)
             {
@@ -598,6 +1409,74 @@ digest_check (const char *checkfile_name
           && n_open_or_read_failures == 0);
 }
 
+// PZK >
+/* unescape() based on curl_easy_escape() to which the following applies
+COPYRIGHT AND PERMISSION NOTICE
+
+Copyright (c) 1996 - 2009, Daniel Stenberg, <daniel@haxx.se>.
+
+All rights reserved.
+
+Permission to use, copy, modify, and distribute this software for any purpose
+with or without fee is hereby granted, provided that the above copyright
+notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN
+NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of a copyright holder shall not
+be used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization of the copyright holder.
+*/
+
+/*
+ * Unescapes the given URL escaped string of given length. Returns a
+ * pointer to a malloced string.
+ * If length == 0, the length is assumed to be strlen(string).
+ */
+char *unescape(const char *string, int length)
+{
+  int alloc = (length?length:(int)strlen(string))+1;
+  char *ns = xmalloc(alloc);
+  unsigned char in;
+  int strindex=0;
+  long hex;
+
+  if( !ns )
+    return NULL;
+
+  while(--alloc > 0) {
+    in = *string;
+    if(('%' == in) && isxdigit(string[1]) && isxdigit(string[2])) {
+      /* this is two hexadecimal digits following a '%' */
+      char hexstr[3];
+      char *ptr;
+      hexstr[0] = string[1];
+      hexstr[1] = string[2];
+      hexstr[2] = 0;
+
+      hex = strtol(hexstr, &ptr, 16);
+
+      in = (unsigned char)hex; /* this long is never bigger than 255 anyway */
+
+      string+=2;
+      alloc-=2;
+    }
+
+    ns[strindex++] = in;
+    string++;
+  }
+  ns[strindex]=0; /* terminate it */
+
+  return ns;
+}
+// < PZK
+
 int
 main (int argc, char **argv)
 {
@@ -618,9 +1497,138 @@ main (int argc, char **argv)
 
   atexit (close_stdout);
 
+// PZK >
+  struct sum_options x;
+  sum_option_init (&x);
+// < PZK
+
   while ((opt = getopt_long (argc, argv, "bctw", long_options, NULL)) != -1)
     switch (opt)
       {
+// PZK >
+        case BUFFER_SIZE_OPTION:
+          x.buffer_size = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.buffer_size < 1 || x.buffer_size > 128)
+            error (EXIT_FAILURE, 0, _("invalid buffer size"));
+          size_t tmp_bs = x.buffer_size;
+          size_t new_bs = 1;
+          while (tmp_bs >>= 1) new_bs <<= 1;
+          if (x.buffer_size != new_bs)
+            error(0, 0, _("Note: buffer size has been adjusted to %lld"), new_bs);
+          x.buffer_size = new_bs * 1024 * 1024;
+          break;
+        case DIRECT_READ_OPTION:
+          x.read_mode = O_DIRECT;
+          break;
+        case DOUBLE_BUFFER_OPTION:
+          x.double_buffer = true;
+          break;
+        case LENGTH_OPTION:
+          x.length = strtoll(optarg, (char **) NULL, 10);
+          if (x.length < 1)
+            error (EXIT_FAILURE, 0, _("invalid length"));
+          break;
+        case NO_DIRECT_READ_OPTION:
+          x.read_mode = 0;
+          break;
+        case NO_DOUBLE_BUFFER_OPTION:
+          x.double_buffer = false;
+          break;
+        case OFFSET_OPTION:
+          x.offset = strtoll(optarg, (char **) NULL, 10);
+          if (x.offset < 0)
+            error (EXIT_FAILURE, 0, _("invalid offset"));
+          break;
+        case READ_STDIN_OPTION:
+          x.read_stdin = true;
+          break;
+#ifdef POSIX_FADV_DONTNEED
+        case FADVISE_READ_OPTION:
+          x.fadvise_read = true;
+          break;
+        case NO_FADVISE_READ_OPTION:
+          x.fadvise_read = false;
+          break;
+#endif
+#ifdef _OPENMP
+        case PRINT_STATS_OPTION:
+          x.print_stats = true;
+          break;
+        case SPLIT_SIZE_OPTION:
+          x.split_size = strtoll(optarg, (char **) NULL, 10);
+          if (x.split_size < 0)
+            error (EXIT_FAILURE, 0, _("invalid split size"));
+          if (x.split_size > 0) {
+            off_t tmp_ss = x.split_size;
+            off_t new_ss = 1;
+            while (tmp_ss >>= 1) new_ss <<= 1;
+            if (x.split_size != new_ss)
+              error(0, 0, _("Note: split size has been adjusted to %lld"), new_ss);
+            x.split_size = new_ss * 1024 * 1024;
+          }
+          break;
+        case THREADS_OPTION:
+          x.threads = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.threads < 1 || x.threads > 512)
+            error (EXIT_FAILURE, 0, _("invalid number of threads"));
+          break;
+#endif
+#if HAVE_LIBGCRYPT
+        case CHECK_TREE_OPTION:
+          x.check_tree = true;
+          break;
+        case HASH_LEAF_SIZE_OPTION:
+          x.hash_leaf_size = strtoll(optarg, (char **) NULL, 10);
+          if (x.hash_leaf_size < 1)
+            error (EXIT_FAILURE, 0, _("invalid hash leaf size"));
+          off_t tmp_ls = x.hash_leaf_size;
+          off_t new_ls = 1;
+          while (tmp_ls >>= 1) new_ls <<= 1;
+          if (x.hash_leaf_size != new_ls)
+            error(0, 0, _("Note: hash leaf size has been adjusted to %lld"), new_ls);
+          x.hash_leaf_size = new_ls * 1024;
+          break;
+        case HASH_TYPE_OPTION:
+          x.hash_type = -1;
+          // 400 taken from libgcrypt benchmark code
+          for (int i = 1; i < 400; i++) {
+            if (!gcry_md_test_algo(i) &&
+                    !strcasecmp(optarg, gcry_md_algo_name(i))) {
+                x.hash_type = i;
+                break;
+            }
+          }
+          if (x.hash_type < 0) error (EXIT_FAILURE, 0, _("invalid hash type"));
+          break;
+        case STORE_HASH_OPTION:
+          x.store_hash = true;
+          break;
+#endif
+#if HAVE_LIBMPI && defined(_OPENMP)
+        case MPI_OPTION:
+          x.mpi = true;
+          break;
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+        case LISTEN_PORT_OPTION:
+          x.listen_port = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.listen_port < 1 || x.listen_port > 65535)
+            error (EXIT_FAILURE, 0, _("invalid listen port"));
+          break;
+        case MANAGER_HOST_OPTION:
+          if (getaddrinfo(optarg, NULL, NULL, &x.mgr_ai))
+            error (EXIT_FAILURE, 0, _("unable to resolve manager host"));
+          break;
+        case MANAGER_PORT_OPTION:
+          x.mgr_port = (int) strtol(optarg, (char **) NULL, 10);
+          if (x.mgr_port < 1 || x.mgr_port > 65535)
+            error (EXIT_FAILURE, 0, _("invalid manager port"));
+          break;
+        case PASSWORD_FILE_OPTION:
+          x.pw_file = xstrdup(optarg);
+          break;
+#endif
+// < PZK
       case 'b':
         binary = 1;
         break;
@@ -687,21 +1695,846 @@ main (int argc, char **argv)
 
   if (optind == argc)
     argv[argc++] = bad_cast ("-");
+// PZK >
+  else if (x.read_stdin)
+    error (EXIT_FAILURE, 0, _("--read-stdin cannot be used with other arguments"));
+  if (x.read_stdin && do_check)
+    error (EXIT_FAILURE, 0, _("--read-stdin cannot be used with -c/--check"));
+  if (x.read_mode && x.fadvise_read) {
+#if DEFAULT_DIRECT_READ
+    x.read_mode = 0;
+#elif DEFAULT_FADVISE_READ
+    x.fadvise_read = false;
+#else
+    error(0, 0, _("Note: --fadvise-read disabled in favor of --direct-read"));
+    x.fadvise_read = false;
+#endif
+  }
+#if HAVE_LIBGCRYPT
+  //TODO: temporarily disable options that excercise filesystem bugs
+  if (x.store_hash) {
+    error(0, 0, _("Note: hash stores have been temporarily disabled in this version"));
+    x.store_hash = false;
+  }
+  //TODO: reenable above when filesystem bugs are fixed
+  if ((x.offset || x.length) && x.store_hash)
+    error(EXIT_FAILURE, 0, _("cannot store hash during partial file copy"));
+  if (do_check && x.store_hash)
+    error (EXIT_FAILURE, 0, _("cannot use --store-hash when verifying checksums"));
+  if (x.split_size > 0 && x.split_size < x.buffer_size) {
+    error(0, 0, _("Note: split size has been adjusted to the buffer size"));
+    x.split_size = x.buffer_size;
+  }
+  if (x.split_size > 0 && x.split_size < x.hash_leaf_size) {
+    error(0, 0, _("Note: hash leaf size has been adjusted to the split size"));
+    x.hash_leaf_size = x.split_size;
+  }
+  if (!x.hash_leaf_size) {
+    error(0, 0, _("Note: hash leaf size has been adjusted to 1GiB"));
+    x.hash_leaf_size = 1024 * 1024 * 1024;
+  }
+  x.hash_size = gcry_md_get_algo_dlen(x.hash_type);
+  min_digest_line_length = 2 * x.hash_size + 2 + 1;
+  digest_hex_bytes = 2 * x.hash_size;
+#endif
+#if HAVE_LIBGNUTLS && defined(_OPENMP)
+  if (x.mgr_ai != NULL && x.mgr_port)
+    ((struct sockaddr_in *) x.mgr_ai->ai_addr)->sin_port = htons(x.mgr_port);
+  if (x.mgr_ai != NULL && x.mgr_port == 0 || x.mgr_ai == NULL && x.mgr_port)
+    error (EXIT_FAILURE, 0, _("must specify both manager host and manager port"));
+  if (x.listen_port && x.mgr_port)
+    error (EXIT_FAILURE, 0, _("cannot use --listen-port with --manager-port"));
+  if (x.listen_port && x.pw_file) {
+    struct stat st;
+    // delay changing pw_file until after password generation
+    char *tmppw = xmalloc(strlen(x.pw_file) + 4);
+    x.mg_file = xmalloc(strlen(x.pw_file) + 4);
+    sprintf(tmppw, "%s.pw", x.pw_file);
+    sprintf(x.mg_file, "%s.mg", x.pw_file);
+    if (stat(x.mg_file, &st) < 0 && stat(tmppw, &st) < 0) {
+      if (srp_generate_auth(x.pw_file, tmppw, x.mg_file) < 0)
+        error (EXIT_FAILURE, 0, _("unable to create manager password files"));
+    } else if (stat(x.mg_file, &st) < 0) {
+      error (EXIT_FAILURE, 0,
+          _("manager modulus/generator file %s does not exist"),
+          quote(x.mg_file));
+    } else if (stat(tmppw, &st) < 0) {
+      error (EXIT_FAILURE, 0, _("manager password file %s does not exist"),
+          quote(tmppw));
+    }
+    free(x.pw_file);
+    x.pw_file = tmppw;
+  } else if (x.pw_file) {
+    struct passwd *pw = getpwuid(getuid());
+    if (pw == NULL)
+        error (EXIT_FAILURE, 0, _("unable to determine user name"));
+    x.user = xstrdup(pw->pw_name);
+    FILE *f = fopen(x.pw_file, "r");
+    if (f == NULL)
+      error (EXIT_FAILURE, 0, _("unable to read user password file"));
+    x.pass = xmalloc(32);
+    if (fread(x.pass, 16, 1, f) < 1)
+      error (EXIT_FAILURE, 0, _("unable to read user password"));
+    x.pass[16] = 0;
+  }
+#endif
+
+#ifdef _OPENMP
+  int pid = 0, procs = 1;
+  int hash_stat_done = 0;
+  int main_done = 0;
+# if HAVE_LIBMPI
+  if (x.mpi) {
+    MPI_Init(NULL, NULL);
+    MPI_Comm_rank(MPI_COMM_WORLD, &pid);
+    MPI_Comm_size(MPI_COMM_WORLD, &procs);
+    // add a thread for MPI handler on main node
+    if (pid == 0) x.threads++;
+  }
+# endif
+  // add a thread for TCP handler on main node
+  if (x.listen_port) x.threads++;
+  // add a thread for file/TCP handler on main/other nodes
+  x.threads++;
+  // add a thread for stat/hash handler on main node
+  if (!x.mgr_port && pid == 0) x.threads++;
+
+  omp_set_num_threads(x.threads);
+  bool oks[x.threads];
+  omp_q_t task_q;
+  omp_q_init(&task_q, x.threads, sizeof(sum_task_t));
+  x.task_q = &task_q;
+  omp_q_t send_q;
+  omp_q_init(&send_q, x.threads, sizeof(void *));
+  x.send_q = &send_q;
+
+# if HAVE_LIBGCRYPT
+  gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);
+  if (!gcry_check_version(GCRYPT_VERSION))
+    error (EXIT_FAILURE, 0, _("libgcrypt version mismatch"));
+  gcry_control(GCRYCTL_DISABLE_SECMEM, 0);
+  gcry_control(GCRYCTL_ENABLE_M_GUARD, 0);
+  gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);
+# endif
+# if HAVE_LIBGNUTLS
+  if (x.listen_port || x.mgr_port) {
+    gnutls_global_init();
+    gnutls_global_init_extra();
+  }
+#endif
+
+# pragma omp parallel
+{
+  int tid = omp_get_thread_num();
+  oks[tid] = true;
+
+  if (!x.mgr_port && pid == 0 && tid == 2) {
+    ////////////////////////////////////
+    // stat/hash handler on main node //
+    ////////////////////////////////////
+    struct timespec tts[2];
+    if (x.print_stats) {
+      fprintf(stderr, _("      size        rd_mbs  hs_mbs  sm_mbs  file\n"));
+      fprintf(stderr, _("      ----        ------  ------  ------  ----\n"));
+      clock_gettime(CLOCK_REALTIME, &tts[0]);
+    }
+    off_t tsize = 0;
+    int maxstts = 128;
+    sum_task_t **stts = xcalloc(maxstts, sizeof(sum_task_t *));
+    int nstts = 0;
+    long long done_tasks = 0;
+    while (!main_done || *x.hash_stat_tasks > done_tasks) {
+      //TODO: timeout on pop?
+      sum_task_t *stt = omp_q_pop(&send_q);
+      if (stt != NULL && stt->split != stt->nsplits) done_tasks++;
+      if (stt == NULL || stt->src_name == NULL) {
+        //TODO: do something with error?
+        continue;
+      }
+      if (x.print_stats && stt->split != stt->nsplits) {
+        tsize += stt->stop_offset - stt->start_offset;
+        double mb = (stt->stop_offset - stt->start_offset) / 1000.0 / 1000.0;
+        fprintf(stderr, _("%16lld  %6.1f  %6.1f  %6.1f  %s"),
+            stt->stop_offset - stt->start_offset, mb / stt->read_time,
+            mb / stt->hash_time, mb / stt->sum_time, stt->src_name);
+        if (stt->nsplits > 1)
+            fprintf(stderr, _(" (%lu/%lu)"), stt->split + 1, stt->nsplits);
+        fprintf(stderr, _("\n"));
+      }
+
+      if (stt->nsplits == 1) {
+        if (stt->hash_check != NULL) {
+            print_check(&x, stt);
+        } else {
+            print_hash(&x, stt);
+        }
+      }
+
+      if (stt->nsplits <= 1) {
+        free(stt->src_name);
+        free(stt->hash_stack);
+        free(stt->hash_check);
+        free(stt);
+        continue;
+      }
+
+      int index;
+      int empty = -1;
+      // find existing entry and/or free slot
+      for (index = 0; index < maxstts; index++) {
+          if (stts[index] == NULL) {
+              if (empty < 0) empty = index;
+              continue;
+          }
+          if (!strcmp(stt->src_name, stts[index]->src_name)) break;
+      }
+      if (index >= maxstts) {
+          // this is the first split received
+          if (empty == -1) {
+              // no free slot found so expand array
+              maxstts *= 2;
+              //TODO: should probably error out if array gets too big
+              xrealloc(stts, maxstts * sizeof(sum_task_t *));
+              bzero(&stts[maxstts / 2], maxstts / 2 * sizeof(sum_task_t *));
+              empty = index;
+          }
+          // first stt has special field values including
+          //   split = nsplits, stop_offset = file size,
+          //   dest_desc = open fd, and hash_stack of size nsplits * hash size
+          stts[empty] = stt;
+      } else {
+#if HAVE_LIBGCRYPT
+        // copy final hash onto shared hash stack
+        memcpy(&stts[index]->hash_stack[stt->split * x.hash_size],
+            stt->hash_stack, x.hash_size);
+        free(stt->hash_stack);
+#endif
+        free(stt->src_name);
+        free(stt);
+        stt = stts[index];
+        // this works because split will be nsplits in first stt received
+        if (--stt->split == 0) {
+#if HAVE_LIBGCRYPT
+            // finalize hash if last
+            gcry_md_hd_t ctx;
+            gcry_md_open(&ctx, x.hash_type, 0);
+            hash_tree_t htt;
+            htt.n_hash_total = 0;
+            htt.hash_ctx = &ctx;
+            htt.hash_ctx_len = 0;
+//TODO:            if (x.store_hash) htt.xattr = xmalloc(ATTR_MAX_VALUELEN);
+            htt.xattr_len = 0;
+            // this works because dest_desc will be open in first stt received
+            //TODO: htt.fd = stt->dest_desc;
+            htt.stack_len = 0;
+            // don't compute root of tree when printing/checking subtrees
+            if (!x.check_tree)
+                hash_final(&htt, stt, &x, 0, stt->nsplits,
+                    stt->stop_offset - stt->start_offset);
+            // print or check hash
+            if (stt->hash_check != NULL) {
+                print_check(&x, stt);
+            } else {
+                print_hash(&x, stt);
+            }
+            // clean up
+            //TODO if (x.store_hash) close(stt->dest_desc);
+            gcry_md_close(ctx);
+            if (x.store_hash) free(htt.xattr);
+            free(stt->hash_stack);
+            free(stt->hash_check);
+#endif
+            free(stt->src_name);
+            free(stt);
+            stts[index] = NULL;
+            //TODO: if last, then set done for tcp, etc.
+        }
+      }
+    }
+//TODO: there is something in the 4n.8t case causing this to hang at the end
+     if (x.print_stats) {
+        clock_gettime(CLOCK_REALTIME, &tts[1]);
+        double tt = (double) (
+            (double) tts[1].tv_sec + (double) tts[1].tv_nsec / (double) 1.0e9 -
+            (double) tts[0].tv_sec - (double) tts[0].tv_nsec / (double) 1.0e9);
+        double mb = tsize / 1000.0 / 1000.0;
+        fprintf(stderr, _("      ----        ------  ------  ------  ----\n"));
+        fprintf(stderr, _("%16lld                  %6.1f  total\n"),
+            tsize, mb / tt);
+    }
+    hash_stat_done = 1;
+# if HAVE_LIBMPI
+    if (x.mpi) {
+        // send message to MPI handler on main node to break out of
+        // a final receive called just before hash_stat_done is set
+        long long sz = -1;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+    }
+# endif
+# if HAVE_LIBGNUTLS
+  } else if (x.mgr_port && tid == 0) {
+    ////////////////////////////////
+    // TCP handler on other nodes //
+    ////////////////////////////////
+    // initialize tls/srp
+    gnutls_session_t tls_sess;
+    gnutls_srp_client_credentials_t srp_cred;
+    gnutls_srp_allocate_client_credentials(&srp_cred);
+    gnutls_srp_set_client_credentials(srp_cred, x.user, x.pass);
+
+    int nulls = 0;
+    int null_task = 0;
+    int nonnull_task = 0;
+
+    while (nulls < x.threads - 1) {
+      sum_task_t *stt = omp_q_pop(&send_q);
+      if (stt == NULL && null_task) {
+        nulls++;
+        omp_q_push(&task_q, NULL);
+        continue;
+      } else if (stt != NULL) {
+        nonnull_task = 1;
+      }
+
+      int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+      if (sock < 0)
+        error(EXIT_FAILURE, 0, _("unable to create socket"));
+
+      size_t src_size = 0;
+      ssize_t rc = connect(sock, x.mgr_ai->ai_addr, sizeof(struct sockaddr_in));
+      if (!rc) {
+        // initialize tls session
+        gnutls_init(&tls_sess, GNUTLS_CLIENT);
+        gnutls_priority_set_direct(tls_sess, "NORMAL:+SRP", NULL);
+        gnutls_credentials_set(tls_sess, GNUTLS_CRD_SRP, srp_cred);
+        gnutls_transport_set_ptr(tls_sess, (gnutls_transport_ptr_t) sock);
+        if (gnutls_handshake(tls_sess) < 0) {
+            error(0, 0, _("unable to authenticate to server"));
+            //TODO: can this cause deadlocK?
+            omp_q_push(&send_q, NULL);
+            continue;
+        }
+      } else {
+        if (nonnull_task) {
+            nulls++;
+            omp_q_push(&task_q, NULL);
+            continue;
+        }
+        error(0, 0, _("connect failed...sleeping"));
+        fflush(stderr);
+        // wait until server starts
+        sleep(1);
+        //TODO: can this cause deadlocK?
+        omp_q_push(&send_q, NULL);
+        // probably want some check so don't loop forever
+        continue;
+      }
+
+
+      if (stt != NULL) {
+        // send final status with times and hash
+        src_size = strlen(stt->src_name) + 1;
+        rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+        rc |= gnutls_record_send(tls_sess, stt->src_name, src_size);
+        rc |= gnutls_record_send(tls_sess, stt->hash_stack, x.hash_size);
+        rc |= gnutls_record_send(tls_sess, stt, sizeof(sum_task_t));
+        if (stt->hash_check != NULL)
+            rc |= gnutls_record_send(tls_sess, stt->hash_check,
+                2 * x.hash_size);
+        if (rc < 0)
+            error(0, 0, _("unable to send final status to server"));
+            //TODO: do something else like requeue stt?
+        free(stt->src_name);
+        free(stt->hash_check);
+        free(stt->hash_stack);
+        free(stt);
+      } else {
+        // send task request
+        src_size = 0;
+        rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+
+        // receive task request
+        rc |= gnutls_record_recv(tls_sess, &src_size, sizeof(src_size));
+        if (rc < 0 || src_size == 0) {
+          null_task = 1;
+          nulls++;
+          omp_q_push(&task_q, NULL);
+        } else {
+          if (rc > 0) {
+              char *src_tmp = xmalloc(src_size);
+              stt = xmalloc(sizeof(sum_task_t));
+              stt->hash_check = NULL;
+              rc |= gnutls_record_recv(tls_sess, src_tmp, src_size);
+              rc |= gnutls_record_recv(tls_sess, stt, sizeof(sum_task_t));
+              if (rc > 0 && stt->hash_check != NULL) {
+                stt->hash_check = xmalloc(2 * x.hash_size + 1);
+                rc |= gnutls_record_recv(tls_sess, stt->hash_check,
+                    2 * x.hash_size);
+                stt->hash_check[2 * x.hash_size] = 0;
+              }
+              //TODO: this section still needs work??
+              if (rc > 0) {
+                  stt->src_name = src_tmp;
+                  stt->hash_stack = xmalloc(x.hash_size);
+                  omp_q_push(&task_q, stt);
+              } else {
+                  free(src_tmp);
+                  free(stt->hash_check);
+                  free(stt);
+              }
+          }
+        }
+      }
+      if (rc >= 0 || src_size > 0) {
+        // shutdown tls session
+        gnutls_bye(tls_sess, GNUTLS_SHUT_RDWR);
+        shutdown(sock, SHUT_RDWR);
+        gnutls_deinit(tls_sess);
+      }
+    }
+    // free tls/srp resources
+    gnutls_srp_free_client_credentials(srp_cred);
+    gnutls_global_deinit();
+  } else if (x.listen_port && tid == 1) {
+    //////////////////////////////
+    // TCP handler on main node //
+    //////////////////////////////
+    // initialize tls/srp
+    gnutls_srp_server_credentials_t srp_cred;
+    gnutls_srp_allocate_server_credentials(&srp_cred);
+    gnutls_srp_set_server_credentials_file(srp_cred, x.pw_file, x.mg_file);
+
+    int server_sock, client_sock;
+    struct sockaddr_in server_sa, client_sa;
+    socklen_t client_len = sizeof(client_sa);
+
+    server_sa.sin_family = AF_INET;
+    server_sa.sin_addr.s_addr = htonl(INADDR_ANY);
+    server_sa.sin_port = htons(x.listen_port);
+
+    server_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+    if (server_sock < 0)
+        error(EXIT_FAILURE, 0, _("unable to create socket"));
+    if (fcntl(server_sock, F_SETFL, O_NONBLOCK) < 0)
+        error(EXIT_FAILURE, 0, _("unable to set socket option"));
+    if (bind(server_sock, (struct sockaddr *) &server_sa, sizeof(server_sa)) < 0)
+        error(EXIT_FAILURE, 0, _("unable to bind to socket"));
+    if (listen(server_sock, SOMAXCONN) < 0)
+        error(EXIT_FAILURE, 0, _("unable to listen on socket"));
+
+    struct pollfd sfds[1];
+    sfds[0].fd = server_sock;
+    sfds[0].events = POLLIN;
+
+    int null_task = 0;
+
+    while (!main_done || !hash_stat_done) {
+        if (poll(sfds, 1, 1000) <= 0) continue;
+
+        gnutls_session_t tls_sess;
+        gnutls_init(&tls_sess, GNUTLS_SERVER);
+        gnutls_priority_set_direct(tls_sess, "NORMAL:+SRP", NULL);
+        gnutls_credentials_set(tls_sess, GNUTLS_CRD_SRP, srp_cred);
+
+        client_sock =
+            accept(server_sock, (struct sockaddr *) &client_sa, &client_len);
+        if (client_sock < 0) continue;
+        gnutls_transport_set_ptr(tls_sess, (gnutls_transport_ptr_t) client_sock);
+         if (gnutls_handshake(tls_sess) < 0) {
+            error(0, 0, _("warning: failed authentication attempt from %s:%d"),
+                inet_ntoa(client_sa.sin_addr), ntohs(client_sa.sin_port));
+            continue;
+        }
+
+        size_t src_size;
+        ssize_t rc = 0;
+        sum_task_t *stt;
+        //TODO: need timeouts throughout here
+        if (gnutls_record_recv(tls_sess, &src_size, sizeof(src_size)) < 0) continue;
+        if (src_size > 0) {
+          char *src_tmp = xmalloc(src_size);
+          unsigned char *hash_tmp = xmalloc(x.hash_size);
+          stt = xmalloc(sizeof(sum_task_t));
+          stt->hash_check = NULL;
+          rc |= gnutls_record_recv(tls_sess, src_tmp, src_size);
+          rc |= gnutls_record_recv(tls_sess, hash_tmp, x.hash_size);
+          rc |= gnutls_record_recv(tls_sess, stt, sizeof(sum_task_t));
+          if (rc > 0 && stt->hash_check != NULL) {
+              stt->hash_check = xmalloc(2 * x.hash_size + 1);
+              rc |= gnutls_record_recv(tls_sess, stt->hash_check,
+                  2 * x.hash_size);
+              stt->hash_check[2 * x.hash_size] = 0;
+          }
+          //TODO: this section still needs work??
+          if (rc > 0) {
+              stt->src_name = src_tmp;
+              stt->hash_stack = hash_tmp;
+              omp_q_push(&send_q, stt);
+          } else {
+              free(src_tmp);
+              free(hash_tmp);
+              free(stt->hash_check);
+              stt->src_name = NULL;
+              // indicate error with null src
+              omp_q_push(&send_q, stt);
+              //TODO: see if this technique can be used elsewhere
+          }
+        } else {
+            stt = null_task ? NULL : omp_q_pop(&task_q);
+            if (stt == NULL) {
+                null_task = 1;
+                src_size = 0;
+                rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+            } else {
+                // this assumes same arch on client/server
+                src_size = strlen(stt->src_name) + 1;
+                rc |= gnutls_record_send(tls_sess, &src_size, sizeof(src_size));
+                rc |= gnutls_record_send(tls_sess, stt->src_name, src_size);
+                rc |= gnutls_record_send(tls_sess, stt, sizeof(sum_task_t));
+                if (stt->hash_check != NULL)
+                    rc |= gnutls_record_send(tls_sess, stt->hash_check,
+                        2 * x.hash_size);
+                if (rc <= 0) {
+                    omp_q_push(&task_q, stt);
+                    error(0, 0, _("warning: failure responding to client (will retry)"));
+                } else {
+                    free(stt->src_name);
+                    free(stt->hash_check);
+                    free(stt->hash_stack);
+                    free(stt);
+                }
+            }
+        }
+        gnutls_bye(tls_sess, GNUTLS_SHUT_WR);
+        close(client_sock);
+        gnutls_deinit(tls_sess);
+    }
+    close(server_sock);
+    gnutls_srp_free_server_credentials(srp_cred);
+    gnutls_global_deinit();
+# endif
+# if HAVE_LIBMPI
+  } else if (pid != 0 && tid == 0) {
+    ////////////////////////////////
+    // MPI handler on other nodes //
+    ////////////////////////////////
+    int nulls = 0;
+    int null_task = 0;
+    int nonnull_task = 0;
+
+    while (nulls < x.threads - 1) {
+      sum_task_t *stt = omp_q_pop(&send_q);
+      if (stt == NULL && null_task) {
+        nulls++;
+        omp_q_push(&task_q, NULL);
+        continue;
+      } else if (stt != NULL) {
+        nonnull_task = 1;
+      }
+
+      size_t src_size, chk_size;
+      long long sz;
+      int pos = 0;
+
+      if (stt != NULL) {
+        // send final status with times and hash
+        src_size = strlen(stt->src_name) + 1;
+        chk_size = stt->hash_check == NULL ?  0 : strlen(stt->hash_check) + 1;
+        sz = src_size + chk_size + x.hash_size + sizeof(sum_task_t);
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+
+        // pack stt into one big byte array
+        char pack[sz];
+        // this assumes same arch on client/server
+        MPI_Pack(&src_size, sizeof(src_size),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&chk_size, sizeof(chk_size),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(stt->src_name, src_size,
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        if (chk_size)
+            MPI_Pack(stt->hash_check, chk_size,
+                MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(stt->hash_stack, x.hash_size,
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->dst_blksize, sizeof(stt->dst_blksize),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->read_time, sizeof(stt->read_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->hash_time, sizeof(stt->hash_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->sum_time, sizeof(stt->sum_time),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->start_offset, sizeof(stt->start_offset),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->stop_offset, sizeof(stt->stop_offset),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->nsplits, sizeof(stt->nsplits),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+        MPI_Pack(&stt->split, sizeof(stt->split),
+            MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+
+        MPI_Send(pack, pos, MPI_PACKED, 0, 1, MPI_COMM_WORLD);
+
+        free(stt->src_name);
+        free(stt->hash_check);
+        free(stt->hash_stack);
+        free(stt);
+      } else {
+        // send task request
+        sz = 0;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+
+        // receive task request
+        MPI_Status stat;
+        int rc = MPI_Recv(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD, &stat);
+        if (rc || sz == 0) {
+            null_task = 1;
+            nulls++;
+            omp_q_push(&task_q, NULL);
+        } else {
+            // unpack stt from one big byte array
+            char pack[sz];
+            if (MPI_Recv(pack, sz, MPI_PACKED, 0, 1, MPI_COMM_WORLD, &stat))
+                continue;
+            // this assumes same arch on client/server
+            MPI_Unpack(pack, sz, &pos, &src_size, sizeof(src_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &chk_size, sizeof(chk_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            stt = xmalloc(sizeof(sum_task_t));
+            stt->src_name = xmalloc(src_size);
+            stt->hash_stack = xmalloc(x.hash_size);
+            MPI_Unpack(pack, sz, &pos, stt->src_name, src_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            if (chk_size) {
+                stt->hash_check = xmalloc(chk_size);
+                MPI_Unpack(pack, sz, &pos, stt->hash_check, chk_size,
+                    MPI_BYTE, MPI_COMM_WORLD);
+            } else {
+                stt->hash_check = NULL;
+            }
+            MPI_Unpack(pack, sz, &pos, &stt->dst_blksize, sizeof(stt->dst_blksize),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->read_time, sizeof(stt->read_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->hash_time, sizeof(stt->hash_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->sum_time, sizeof(stt->sum_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->start_offset, sizeof(stt->start_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->stop_offset, sizeof(stt->stop_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->nsplits, sizeof(stt->nsplits),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->split, sizeof(stt->split),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            omp_q_push(&task_q, stt);
+        }
+      }
+    }
+  } else if (x.mpi && pid == 0 && tid == 1) {
+    //////////////////////////////
+    // MPI handler on main node //
+    //////////////////////////////
+    int null_task = 0;
+    MPI_Status stat;
+    long long sz;
+    int mpi_recv = 0;
+
+    while (!main_done || !hash_stat_done || x.mpi && mpi_recv < 2) {
+        if (MPI_Recv(&sz, 1, MPI_LONG_LONG, MPI_ANY_SOURCE, MPI_ANY_TAG,
+                MPI_COMM_WORLD, &stat)) break;
+
+        size_t src_size, chk_size;
+        sum_task_t *stt;
+        int pos = 0;
+
+        if (sz > 0) {
+            // unpack stt from one big byte array
+            char pack[sz];
+            if (MPI_Recv(pack, sz, MPI_PACKED, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD, &stat)) continue;
+            // this assumes same arch on client/server
+            MPI_Unpack(pack, sz, &pos, &src_size, sizeof(src_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &chk_size, sizeof(chk_size),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            stt = xmalloc(sizeof(sum_task_t));
+            stt->src_name = xmalloc(src_size);
+            stt->hash_stack = xmalloc(x.hash_size);
+            MPI_Unpack(pack, sz, &pos, stt->src_name, src_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            if (chk_size) {
+                stt->hash_check = xmalloc(chk_size);
+                MPI_Unpack(pack, sz, &pos, stt->hash_check, chk_size,
+                    MPI_BYTE, MPI_COMM_WORLD);
+            } else {
+                stt->hash_check = NULL;
+            }
+            MPI_Unpack(pack, sz, &pos, stt->hash_stack, x.hash_size,
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->dst_blksize, sizeof(stt->dst_blksize),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->read_time, sizeof(stt->read_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->hash_time, sizeof(stt->hash_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->sum_time, sizeof(stt->sum_time),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->start_offset, sizeof(stt->start_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->stop_offset, sizeof(stt->stop_offset),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->nsplits, sizeof(stt->nsplits),
+                MPI_BYTE, MPI_COMM_WORLD);
+            MPI_Unpack(pack, sz, &pos, &stt->split, sizeof(stt->split),
+                MPI_BYTE, MPI_COMM_WORLD);
+
+            omp_q_push(&send_q, stt);
+        } else if (sz == 0) {
+            stt = null_task ? NULL : omp_q_pop(&task_q);
+            if (stt == NULL) {
+                null_task = 1;
+                sz = 0;
+                MPI_Send(&sz, 1, MPI_LONG_LONG, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD);
+            } else {
+                src_size = strlen(stt->src_name) + 1;
+                chk_size = stt->hash_check == NULL ?
+                    0 : strlen(stt->hash_check) + 1;
+                sz = src_size + chk_size + sizeof(sum_task_t);
+                MPI_Send(&sz, 1, MPI_LONG_LONG, stat.MPI_SOURCE,
+                    stat.MPI_TAG, MPI_COMM_WORLD);
+                // pack stt into one big byte array
+                char pack[sz];
+                // this assumes same arch on client/server
+                MPI_Pack(&src_size, sizeof(src_size),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&chk_size, sizeof(chk_size),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(stt->src_name, src_size,
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                if (chk_size)
+                    MPI_Pack(stt->hash_check, chk_size,
+                        MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->dst_blksize, sizeof(stt->dst_blksize),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->read_time, sizeof(stt->read_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->hash_time, sizeof(stt->hash_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->sum_time, sizeof(stt->sum_time),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->start_offset, sizeof(stt->start_offset),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->stop_offset, sizeof(stt->stop_offset),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->nsplits, sizeof(stt->nsplits),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+                MPI_Pack(&stt->split, sizeof(stt->split),
+                    MPI_BYTE, pack, sz, &pos, MPI_COMM_WORLD);
+
+                MPI_Send(pack, pos, MPI_PACKED, stat.MPI_SOURCE, stat.MPI_TAG,
+                    MPI_COMM_WORLD);
+                free(stt->src_name);
+                free(stt->hash_check);
+                free(stt->hash_stack);
+                free(stt);
+            }
+        } else {
+            // main and hash/stat done message to prevent deadlock
+            mpi_recv++;
+        }
+    }
+# endif
+  } else if (tid != 0) {
+    //////////////////////////////
+    // sum handler on all nodes //
+    //////////////////////////////
+    // indicate ready for request on other nodes
+    if (x.mgr_port || pid != 0) omp_q_push(&send_q, NULL);
+    sum_task_t *stt;
+    while ((stt = omp_q_pop(&task_q)) != NULL) {
+      struct timespec ts[2];
+      if (x.print_stats) clock_gettime(CLOCK_REALTIME, &ts[0]);
+      oks[tid] &= sum_task(stt, &x);
+      if (x.print_stats) {
+        clock_gettime(CLOCK_REALTIME, &ts[1]);
+        stt->sum_time = (double) (
+          (double) ts[1].tv_sec + (double) ts[1].tv_nsec / (double) 1.0e9 -
+          (double) ts[0].tv_sec - (double) ts[0].tv_nsec / (double) 1.0e9);
+      }
+      omp_q_push(&send_q, stt);
+      // indicate ready for request on other nodes
+      if (x.mgr_port || pid != 0) omp_q_push(&send_q, NULL);
+    }
+  } else {
+#endif
+// < PZK
 
   for (; optind < argc; ++optind)
     {
       char *file = argv[optind];
-
+// PZK >
+      if (x.read_stdin) {
+        size_t buf_max = MIN(PATH_MAX, 32 * 1024);
+        char *buf = xmalloc(buf_max);
+
+        while (fgets(buf, buf_max, stdin) != NULL) {
+            buf[strcspn(buf, "\n")] = '\0';
+            if (file[0] == '\0') {
+                //TODO: error handling if string too long
+                continue;
+            }
+            size_t irange = strcspn(buf, " ");
+            if (buf[irange] == '\0') irange = 0;
+            else buf[irange++] = '\0';
+            file = unescape(buf, 0);
+            if (file == NULL) {
+                //TODO: error handling if can't unescape
+                continue;
+            }
+            int file_is_binary = binary;
+            if (irange > 0) {
+                off_t x1, x2;
+                while (sscanf(&buf[irange], "%lld-%lld", &x1, &x2) == 2) {
+                    x.offset = x1;
+                    x.length = x2 - x1;
+                    if (! digest_file (&x, NULL, file, &file_is_binary,
+                            bin_buffer)) ok = false;
+                    irange += strcspn(&buf[irange], ",");
+                    if (buf[irange] == ',') irange++;
+                }
+            } else {
+                x.offset = 0;
+                x.length = 0;
+                if (! digest_file (&x, NULL, file, &file_is_binary, bin_buffer))
+                    ok = false;
+            }
+        }
+        break;
+      }
+// < PZK
       if (do_check)
-        ok &= digest_check (file);
+        ok &= digest_check (&x, file);
       else
         {
           int file_is_binary = binary;
 
-          if (! digest_file (file, &file_is_binary, bin_buffer))
+          if (! digest_file (&x, NULL, file, &file_is_binary, bin_buffer))
             ok = false;
           else
             {
+// PZK >
+#ifdef _OPENMP
+              if (!STREQ (file, "-")) continue;
+#endif
+// < PZK
               size_t i;
 
               /* Output a leading backslash if the file name contains
@@ -741,9 +2574,44 @@ main (int argc, char **argv)
             }
         }
     }
+// PZK >
+#ifdef _OPENMP
+    // indicate that main thread is done traversing file system
+    main_done = 1;
+    // send terminating NULL task to stat/hash thread
+    omp_q_push(&send_q, NULL);
+    // send terminating NULL task to all worker threads
+    for (int i = 0; i < x.threads - 1; i++)
+        omp_q_push(&task_q, NULL);
+# if HAVE_LIBMPI
+    if (x.mpi) {
+        // send message to MPI handler on main node to break out of
+        // a final receive called just before main_done is set
+        long long sz = -1;
+        MPI_Send(&sz, 1, MPI_LONG_LONG, 0, 1, MPI_COMM_WORLD);
+    }
+# endif
+  }
+}
+
+# if HAVE_LIBMPI
+  if (x.mpi) MPI_Finalize();
+# endif
+
+  // destroy all queues
+  omp_q_destroy(&send_q);
+  omp_q_destroy(&task_q);
+
+  //TODO: this no longer works with mpi/tcp
+  // reduce oks array to single value
+  for (int i = 0; i < x.threads; i++)
+    ok &= oks[i];
+#endif
+// < PZK
 
   if (have_read_stdin && fclose (stdin) == EOF)
     error (EXIT_FAILURE, errno, _("standard input"));
 
   exit (ok ? EXIT_SUCCESS : EXIT_FAILURE);
 }
+
diff -rupN orig/tests/Makefile.in new/tests/Makefile.in
--- orig/tests/Makefile.in	2009-09-10 22:56:44.000000000 -0700
+++ new/tests/Makefile.in	2012-10-08 13:50:48.948683365 -0700
@@ -139,27 +139,27 @@ am__aclocal_m4_deps = $(top_srcdir)/m4/0
 	$(top_srcdir)/m4/mbiter.m4 $(top_srcdir)/m4/mbrlen.m4 \
 	$(top_srcdir)/m4/mbrtowc.m4 $(top_srcdir)/m4/mbsinit.m4 \
 	$(top_srcdir)/m4/mbsrtowcs.m4 $(top_srcdir)/m4/mbstate_t.m4 \
-	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/md5.m4 \
-	$(top_srcdir)/m4/memcasecmp.m4 $(top_srcdir)/m4/memchr.m4 \
-	$(top_srcdir)/m4/memcmp.m4 $(top_srcdir)/m4/memcoll.m4 \
-	$(top_srcdir)/m4/memcpy.m4 $(top_srcdir)/m4/memmove.m4 \
-	$(top_srcdir)/m4/mempcpy.m4 $(top_srcdir)/m4/memrchr.m4 \
-	$(top_srcdir)/m4/memset.m4 $(top_srcdir)/m4/memxfrm.m4 \
-	$(top_srcdir)/m4/mgetgroups.m4 $(top_srcdir)/m4/mkancesdirs.m4 \
-	$(top_srcdir)/m4/mkdir-p.m4 $(top_srcdir)/m4/mkdir-slash.m4 \
-	$(top_srcdir)/m4/mkstemp.m4 $(top_srcdir)/m4/mktime.m4 \
-	$(top_srcdir)/m4/mmap-anon.m4 $(top_srcdir)/m4/mode_t.m4 \
-	$(top_srcdir)/m4/modechange.m4 $(top_srcdir)/m4/mountlist.m4 \
-	$(top_srcdir)/m4/mpsort.m4 $(top_srcdir)/m4/multiarch.m4 \
-	$(top_srcdir)/m4/nanosleep.m4 $(top_srcdir)/m4/netdb_h.m4 \
-	$(top_srcdir)/m4/netinet_in_h.m4 $(top_srcdir)/m4/nls.m4 \
-	$(top_srcdir)/m4/nocrash.m4 $(top_srcdir)/m4/open.m4 \
-	$(top_srcdir)/m4/openat.m4 $(top_srcdir)/m4/pathmax.m4 \
-	$(top_srcdir)/m4/perl.m4 $(top_srcdir)/m4/perror.m4 \
-	$(top_srcdir)/m4/physmem.m4 $(top_srcdir)/m4/po.m4 \
-	$(top_srcdir)/m4/posix-shell.m4 $(top_srcdir)/m4/posixtm.m4 \
-	$(top_srcdir)/m4/posixver.m4 $(top_srcdir)/m4/prereq.m4 \
-	$(top_srcdir)/m4/printf-frexp.m4 \
+	$(top_srcdir)/m4/mbswidth.m4 $(top_srcdir)/m4/mcore.m4 \
+	$(top_srcdir)/m4/md5.m4 $(top_srcdir)/m4/memcasecmp.m4 \
+	$(top_srcdir)/m4/memchr.m4 $(top_srcdir)/m4/memcmp.m4 \
+	$(top_srcdir)/m4/memcoll.m4 $(top_srcdir)/m4/memcpy.m4 \
+	$(top_srcdir)/m4/memmove.m4 $(top_srcdir)/m4/mempcpy.m4 \
+	$(top_srcdir)/m4/memrchr.m4 $(top_srcdir)/m4/memset.m4 \
+	$(top_srcdir)/m4/memxfrm.m4 $(top_srcdir)/m4/mgetgroups.m4 \
+	$(top_srcdir)/m4/mkancesdirs.m4 $(top_srcdir)/m4/mkdir-p.m4 \
+	$(top_srcdir)/m4/mkdir-slash.m4 $(top_srcdir)/m4/mkstemp.m4 \
+	$(top_srcdir)/m4/mktime.m4 $(top_srcdir)/m4/mmap-anon.m4 \
+	$(top_srcdir)/m4/mode_t.m4 $(top_srcdir)/m4/modechange.m4 \
+	$(top_srcdir)/m4/mountlist.m4 $(top_srcdir)/m4/mpsort.m4 \
+	$(top_srcdir)/m4/multiarch.m4 $(top_srcdir)/m4/nanosleep.m4 \
+	$(top_srcdir)/m4/netdb_h.m4 $(top_srcdir)/m4/netinet_in_h.m4 \
+	$(top_srcdir)/m4/nls.m4 $(top_srcdir)/m4/nocrash.m4 \
+	$(top_srcdir)/m4/open.m4 $(top_srcdir)/m4/openat.m4 \
+	$(top_srcdir)/m4/pathmax.m4 $(top_srcdir)/m4/perl.m4 \
+	$(top_srcdir)/m4/perror.m4 $(top_srcdir)/m4/physmem.m4 \
+	$(top_srcdir)/m4/po.m4 $(top_srcdir)/m4/posix-shell.m4 \
+	$(top_srcdir)/m4/posixtm.m4 $(top_srcdir)/m4/posixver.m4 \
+	$(top_srcdir)/m4/prereq.m4 $(top_srcdir)/m4/printf-frexp.m4 \
 	$(top_srcdir)/m4/printf-frexpl.m4 $(top_srcdir)/m4/printf.m4 \
 	$(top_srcdir)/m4/priv-set.m4 $(top_srcdir)/m4/progtest.m4 \
 	$(top_srcdir)/m4/putenv.m4 $(top_srcdir)/m4/quote.m4 \
@@ -837,6 +837,7 @@ NEXT_WCHAR_H = @NEXT_WCHAR_H@
 NEXT_WCTYPE_H = @NEXT_WCTYPE_H@
 NO_INSTALL_PROGS_DEFAULT = @NO_INSTALL_PROGS_DEFAULT@
 OBJEXT = @OBJEXT@
+OPENMP_CFLAGS = @OPENMP_CFLAGS@
 OPTIONAL_BIN_PROGS = @OPTIONAL_BIN_PROGS@
 OPTIONAL_PKGLIB_PROGS = @OPTIONAL_PKGLIB_PROGS@
 PACKAGE = @PACKAGE@
